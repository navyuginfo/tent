<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">
<span id='Tent'>/**
</span> * @class Tent
 * Namespace for the Tent widget colleciton
 * @singleton
 *
*/


(function() {

  if (this.Tent == null) {
    this.Tent = {};
  }

  this.Tent.Controllers = Em.Namespace.create;

  this.Tent.Data = Em.Namespace.create;

}).call(this);



<span id='Tent-I18n'>/**
</span>* @class Tent.I18n
* A general purpose class for I18n support.
*/


(function() {

  Tent.I18n = Ember.Namespace.create({
    language: {},
<span id='Tent-I18n-method-loadTranslations'>    /**
</span>    	* Loads a set of translations for localizing text
    	* @param {Object} translations A map of key:value pairs defining the translations to be used
    */

    loadTranslations: function(translations) {
      if (translations != null) {
        return this.set('language', $.extend(this.get('language'), translations));
      }
    },
    translate: function(code) {
      return &quot;t_&quot; + code;
    },
<span id='Tent-I18n-method-loc'>    /**
</span>    	* Replace a key with its translation
    	* @param {String} key
    	* @param {String|[Array| Object]} [vars] arguments to be interpolated in the translated string
    */

    loc: function(key, vars) {
      var idx, string;
      if (key != null) {
        string = Ember.get(this.language, key) || key;
        idx = 0;
        if (typeof vars === 'string') {
          vars = [vars];
        }
        return string.replace(/%@([0-9]|[a-zA-Z]+)?/g, function(s, argIndex) {
          argIndex = (argIndex != null) &amp;&amp; isNaN(argIndex) ? argIndex : (isNaN(parseInt(argIndex)) ? idx++ : parseInt(argIndex) - 1);
          s = vars != null ? vars[argIndex] : void 0;
          if ((s != null)) {
            return s;
          } else {
            return '';
          }
        });
      }
    }
  });

  Tent.translate = Tent.I18n.loc;

  Tent.I18n.loadTranslations({
    tent: {
      on: 'On',
      off: 'Off',
      pleaseSelect: 'Please Select...',
      button: {
        ok: 'Ok',
        yes: 'Yes',
        cancel: 'Cancel',
        save: 'Save',
        saveAs: 'Save As...',
        load: 'Load',
        no: 'No',
        proceed: 'Ignore warnings and proceed',
        dontProceed: 'No, return to page'
      },
      jqGrid: {
        hideShowAlt: 'Hide/Show Columns',
        hideShowCaption: 'Columns',
        hideShowTitle: 'Hide/Show Columns',
        horizontalScroll: 'Auto-Fit',
        &quot;export&quot;: {
          xml: 'XML',
          json: 'JSON',
          csv: 'CSV',
          xlsx: 'XLSX',
          xls: 'XLS',
          comma: 'COMMA',
          pipe: 'PIPE',
          semicolon: 'SEMI COLON',
          colon: 'COLON',
          _or: 'or',
          enterDelimiter: 'Enter Delimiter',
          headers: 'Column Headers',
          inclQuotes: 'Include Quotes',
          &quot;export&quot;: 'Export'
        },
        saveUi: {
          defaultName: ' ',
          &quot;default&quot;: 'No Customization',
          message: 'Save current settings as:'
        }
      },
      filter: {
        filter: 'Filter',
        availableFilters: 'Available Filters',
        selectedFilter: 'Selected Filter',
        currentFilter: 'Current Filter',
        saveFilter: 'Save Filter',
        newFilter: 'New Filter',
        filterLabel: 'Filter Label',
        filterDescription: 'Filter Description',
        save: 'Save',
        saveAs: 'Save As',
        cancel: 'Cancel',
        label: 'Label',
        more: 'more',
        description: 'Description',
        beginsWith: 'begins with',
        contains: 'contains',
        equal: 'equal',
        nEqual: 'not equal',
        before: 'before',
        after: 'after',
        beforeInc: 'before incl',
        afterInc: 'after incl',
        lThan: 'less than',
        gThan: 'greater than',
        lThanEq: 'less than or equal',
        gThanEq: 'greater than or equal',
        range: 'range',
        search: 'Search',
        clear: 'Clear',
        noFilter: 'No Filter',
        like: 'like'
      },
      warning: {
        header: 'Warnings Exist',
        warningsOnPage: 'The following warnings exist on this page. Do you wish to ignore them and proceed?'
      },
      grouping: {
        _groupBy: 'Group',
        range: {
          exact: 'Exact',
          tens: 'Tens',
          hundreds: 'Hundreds',
          thousands: 'Thousands',
          week: 'Week',
          weekStarting: 'Week starting',
          month: 'Month',
          quarter: 'Quarter',
          year: 'Year'
        },
        no_grouping: 'None',
        revert: 'Revert to Original',
        totals: 'Totals:'
      },
      rename: {
        main: 'Rename'
      },
      sorting: {
        main: 'Sort',
        ascending: 'Ascending',
        descending: 'Descending'
      }
    },
    error: {
      generic: 'Error',
      required: 'Field is required',
      numeric: 'Value must be numbers only',
      amount: 'Amount should be positive',
      positive: 'Value should be positive',
      email: 'Email format error',
      date: 'Date format error',
      dateBetween: 'Date should be between %@startDate and %@endDate',
      dateFuture: 'You provided a date in the future',
      maxLength: 'Length must be %@max characters or less',
      minLength: 'Length must be %@min characters or more',
      invalidCurrency: 'Invalid currency',
      regexp: 'Value must pass the regular expression %@regexp',
      minValue: 'Value must be greater than or equal to %@min',
      maxValue: 'Value must be less than or equal to %@max',
      valueBetween: 'Value must be between %@min and %@max'
    }
  });

}).call(this);


(function() {
}).call(this);


(function() {

  Tent.CURRENCIES_ISO_4217 = Ember.Object.create({
    AED: {
      cent: 2,
      name: &quot;United Arab Emirates dirham&quot;
    },
    AFN: {
      cent: 2,
      name: &quot;Afghan afghani&quot;
    },
    ALL: {
      cent: 2,
      name: &quot;Albanian lek&quot;
    },
    AMD: {
      cent: 2,
      name: &quot;Armenian dram&quot;
    },
    ANG: {
      cent: 2,
      name: &quot;Netherlands Antillean guilder&quot;
    },
    AOA: {
      cent: 2,
      name: &quot;Angolan kwanza&quot;
    },
    ARS: {
      cent: 2,
      name: &quot;Argentine peso&quot;
    },
    AUD: {
      cent: 2,
      name: &quot;Australian dollar&quot;
    },
    AWG: {
      cent: 2,
      name: &quot;Aruban florin&quot;
    },
    AZN: {
      cent: 2,
      name: &quot;Azerbaijani manat&quot;
    },
    BAM: {
      cent: 2,
      name: &quot;Bosnia and Herzegovina convertible mark&quot;
    },
    BBD: {
      cent: 2,
      name: &quot;Barbados dollar&quot;
    },
    BDT: {
      cent: 2,
      name: &quot;Bangladeshi taka&quot;
    },
    BGN: {
      cent: 2,
      name: &quot;Bulgarian lev&quot;
    },
    BHD: {
      cent: 3,
      name: &quot;Bahraini dinar&quot;
    },
    BIF: {
      cent: 0,
      name: &quot;Burundian franc&quot;
    },
    BMD: {
      cent: 2,
      name: &quot;Bermudian dollar (customarily known as Bermuda dollar)&quot;
    },
    BND: {
      cent: 2,
      name: &quot;Brunei dollar&quot;
    },
    BOB: {
      cent: 2,
      name: &quot;Boliviano&quot;
    },
    BOV: {
      cent: 2,
      name: &quot;Bolivian Mvdol (funds code)&quot;
    },
    BRL: {
      cent: 2,
      name: &quot;Brazilian real&quot;
    },
    BSD: {
      cent: 2,
      name: &quot;Bahamian dollar&quot;
    },
    BTN: {
      cent: 2,
      name: &quot;Bhutanese ngultrum&quot;
    },
    BWP: {
      cent: 2,
      name: &quot;Botswana pula&quot;
    },
    BYR: {
      cent: 0,
      name: &quot;Belarusian ruble&quot;
    },
    BZD: {
      cent: 2,
      name: &quot;Belize dollar&quot;
    },
    CAD: {
      cent: 2,
      name: &quot;Canadian dollar&quot;
    },
    CDF: {
      cent: 2,
      name: &quot;Congolese franc&quot;
    },
    CHE: {
      cent: 2,
      name: &quot;WIR Euro (complementary currency)&quot;
    },
    CHF: {
      cent: 2,
      name: &quot;Swiss franc&quot;
    },
    CHW: {
      cent: 2,
      name: &quot;WIR Franc (complementary currency)&quot;
    },
    CLF: {
      cent: 0,
      name: &quot;Unidad de Fomento (funds code)&quot;
    },
    CLP: {
      cent: 0,
      name: &quot;Chilean peso&quot;
    },
    CNY: {
      cent: 2,
      name: &quot;Chinese yuan&quot;
    },
    COP: {
      cent: 2,
      name: &quot;Colombian peso&quot;
    },
    COU: {
      cent: 2,
      name: &quot;Unidad de Valor Real&quot;
    },
    CRC: {
      cent: 2,
      name: &quot;Costa Rican colon&quot;
    },
    CUC: {
      cent: 2,
      name: &quot;Cuban convertible peso&quot;
    },
    CUP: {
      cent: 2,
      name: &quot;Cuban peso&quot;
    },
    CVE: {
      cent: 0,
      name: &quot;Cape Verde escudo&quot;
    },
    CZK: {
      cent: 2,
      name: &quot;Czech koruna&quot;
    },
    DJF: {
      cent: 0,
      name: &quot;Djiboutian franc&quot;
    },
    DKK: {
      cent: 2,
      name: &quot;Danish krone&quot;
    },
    DOP: {
      cent: 2,
      name: &quot;Dominican peso&quot;
    },
    DZD: {
      cent: 2,
      name: &quot;Algerian dinar&quot;
    },
    EGP: {
      cent: 2,
      name: &quot;Egyptian pound&quot;
    },
    ERN: {
      cent: 2,
      name: &quot;Eritrean nakfa&quot;
    },
    ETB: {
      cent: 2,
      name: &quot;Ethiopian birr&quot;
    },
    EUR: {
      cent: 2,
      name: &quot;Euro&quot;
    },
    FJD: {
      cent: 2,
      name: &quot;Fiji dollar&quot;
    },
    FKP: {
      cent: 2,
      name: &quot;Falkland Islands pound&quot;
    },
    GBP: {
      cent: 2,
      name: &quot;Pound sterling&quot;
    },
    GEL: {
      cent: 2,
      name: &quot;Georgian lari&quot;
    },
    GHS: {
      cent: 2,
      name: &quot;Ghanaian cedi&quot;
    },
    GIP: {
      cent: 2,
      name: &quot;Gibraltar pound&quot;
    },
    GMD: {
      cent: 2,
      name: &quot;Gambian dalasi&quot;
    },
    GNF: {
      cent: 0,
      name: &quot;Guinean franc&quot;
    },
    GTQ: {
      cent: 2,
      name: &quot;Guatemalan quetzal&quot;
    },
    GYD: {
      cent: 2,
      name: &quot;Guyanese dollar&quot;
    },
    HKD: {
      cent: 2,
      name: &quot;Hong Kong dollar&quot;
    },
    HNL: {
      cent: 2,
      name: &quot;Honduran lempira&quot;
    },
    HRK: {
      cent: 2,
      name: &quot;Croatian kuna&quot;
    },
    HTG: {
      cent: 2,
      name: &quot;Haitian gourde&quot;
    },
    HUF: {
      cent: 2,
      name: &quot;Hungarian forint&quot;
    },
    IDR: {
      cent: 2,
      name: &quot;Indonesian rupiah&quot;
    },
    ILS: {
      cent: 2,
      name: &quot;Israeli new shekel&quot;
    },
    INR: {
      cent: 2,
      name: &quot;Indian rupee&quot;
    },
    IQD: {
      cent: 3,
      name: &quot;Iraqi dinar&quot;
    },
    IRR: {
      cent: 0,
      name: &quot;Iranian rial&quot;
    },
    ISK: {
      cent: 0,
      name: &quot;Icelandic króna&quot;
    },
    JMD: {
      cent: 2,
      name: &quot;Jamaican dollar&quot;
    },
    JOD: {
      cent: 3,
      name: &quot;Jordanian dinar&quot;
    },
    JPY: {
      cent: 0,
      name: &quot;Japanese yen&quot;
    },
    KES: {
      cent: 2,
      name: &quot;Kenyan shilling&quot;
    },
    KGS: {
      cent: 2,
      name: &quot;Kyrgyzstani som&quot;
    },
    KHR: {
      cent: 2,
      name: &quot;Cambodian riel&quot;
    },
    KMF: {
      cent: 0,
      name: &quot;Comoro franc&quot;
    },
    KPW: {
      cent: 0,
      name: &quot;North Korean won&quot;
    },
    KRW: {
      cent: 0,
      name: &quot;South Korean won&quot;
    },
    KWD: {
      cent: 3,
      name: &quot;Kuwaiti dinar&quot;
    },
    KYD: {
      cent: 2,
      name: &quot;Cayman Islands dollar&quot;
    },
    KZT: {
      cent: 2,
      name: &quot;Kazakhstani tenge&quot;
    },
    LAK: {
      cent: 0,
      name: &quot;Lao kip&quot;
    },
    LBP: {
      cent: 0,
      name: &quot;Lebanese pound&quot;
    },
    LKR: {
      cent: 2,
      name: &quot;Sri Lankan rupee&quot;
    },
    LRD: {
      cent: 2,
      name: &quot;Liberian dollar&quot;
    },
    LSL: {
      cent: 2,
      name: &quot;Lesotho loti&quot;
    },
    LTL: {
      cent: 2,
      name: &quot;Lithuanian litas&quot;
    },
    LVL: {
      cent: 2,
      name: &quot;Latvian lats&quot;
    },
    LYD: {
      cent: 3,
      name: &quot;Libyan dinar&quot;
    },
    MAD: {
      cent: 2,
      name: &quot;Moroccan dirham&quot;
    },
    MDL: {
      cent: 2,
      name: &quot;Moldovan leu&quot;
    },
    MKD: {
      cent: 0,
      name: &quot;Macedonian denar&quot;
    },
    MMK: {
      cent: 0,
      name: &quot;Myanma kyat&quot;
    },
    MNT: {
      cent: 2,
      name: &quot;Mongolian tugrik&quot;
    },
    MOP: {
      cent: 2,
      name: &quot;Macanese pataca&quot;
    },
    MUR: {
      cent: 2,
      name: &quot;Mauritian rupee&quot;
    },
    MVR: {
      cent: 2,
      name: &quot;Maldivian rufiyaa&quot;
    },
    MWK: {
      cent: 2,
      name: &quot;Malawian kwacha&quot;
    },
    MXN: {
      cent: 2,
      name: &quot;Mexican peso&quot;
    },
    MXV: {
      cent: 2,
      name: &quot;Mexican Unidad de Inversion (UDI) (funds code)&quot;
    },
    MYR: {
      cent: 2,
      name: &quot;Malaysian ringgit&quot;
    },
    MZN: {
      cent: 2,
      name: &quot;Mozambican metical&quot;
    },
    NAD: {
      cent: 2,
      name: &quot;Namibian dollar&quot;
    },
    NGN: {
      cent: 2,
      name: &quot;Nigerian naira&quot;
    },
    NIO: {
      cent: 2,
      name: &quot;Nicaraguan córdoba&quot;
    },
    NOK: {
      cent: 2,
      name: &quot;Norwegian krone&quot;
    },
    NPR: {
      cent: 2,
      name: &quot;Nepalese rupee&quot;
    },
    NZD: {
      cent: 2,
      name: &quot;New Zealand dollar&quot;
    },
    OMR: {
      cent: 3,
      name: &quot;Omani rial&quot;
    },
    PAB: {
      cent: 2,
      name: &quot;Panamanian balboa&quot;
    },
    PEN: {
      cent: 2,
      name: &quot;Peruvian nuevo sol&quot;
    },
    PGK: {
      cent: 2,
      name: &quot;Papua New Guinean kina&quot;
    },
    PHP: {
      cent: 2,
      name: &quot;Philippine peso&quot;
    },
    PKR: {
      cent: 2,
      name: &quot;Pakistani rupee&quot;
    },
    PLN: {
      cent: 2,
      name: &quot;Polish złoty&quot;
    },
    PYG: {
      cent: 0,
      name: &quot;Paraguayan guaraní&quot;
    },
    QAR: {
      cent: 2,
      name: &quot;Qatari riyal&quot;
    },
    RON: {
      cent: 2,
      name: &quot;Romanian new leu&quot;
    },
    RSD: {
      cent: 2,
      name: &quot;Serbian dinar&quot;
    },
    RUB: {
      cent: 2,
      name: &quot;Russian rouble&quot;
    },
    RWF: {
      cent: 0,
      name: &quot;Rwandan franc&quot;
    },
    SAR: {
      cent: 2,
      name: &quot;Saudi riyal&quot;
    },
    SBD: {
      cent: 2,
      name: &quot;Solomon Islands dollar&quot;
    },
    SCR: {
      cent: 2,
      name: &quot;Seychelles rupee&quot;
    },
    SDG: {
      cent: 2,
      name: &quot;Sudanese pound&quot;
    },
    SEK: {
      cent: 2,
      name: &quot;Swedish krona/kronor&quot;
    },
    SGD: {
      cent: 2,
      name: &quot;Singapore dollar&quot;
    },
    SHP: {
      cent: 2,
      name: &quot;Saint Helena pound&quot;
    },
    SLL: {
      cent: 0,
      name: &quot;Sierra Leonean leone&quot;
    },
    SOS: {
      cent: 2,
      name: &quot;Somali shilling&quot;
    },
    SRD: {
      cent: 2,
      name: &quot;Surinamese dollar&quot;
    },
    SSP: {
      cent: 2,
      name: &quot;South Sudanese pound&quot;
    },
    STD: {
      cent: 0,
      name: &quot;São Tomé and Príncipe dobra&quot;
    },
    SYP: {
      cent: 2,
      name: &quot;Syrian pound&quot;
    },
    SZL: {
      cent: 2,
      name: &quot;Swazi lilangeni&quot;
    },
    THB: {
      cent: 2,
      name: &quot;Thai baht&quot;
    },
    TJS: {
      cent: 2,
      name: &quot;Tajikistani somoni&quot;
    },
    TMT: {
      cent: 2,
      name: &quot;Turkmenistani manat&quot;
    },
    TND: {
      cent: 3,
      name: &quot;Tunisian dinar&quot;
    },
    TOP: {
      cent: 2,
      name: &quot;Tongan paʻanga&quot;
    },
    TRY: {
      cent: 2,
      name: &quot;Turkish lira&quot;
    },
    TTD: {
      cent: 2,
      name: &quot;Trinidad and Tobago dollar&quot;
    },
    TWD: {
      cent: 2,
      name: &quot;New Taiwan dollar&quot;
    },
    TZS: {
      cent: 2,
      name: &quot;Tanzanian shilling&quot;
    },
    UAH: {
      cent: 2,
      name: &quot;Ukrainian hryvnia&quot;
    },
    UGX: {
      cent: 2,
      name: &quot;Ugandan shilling&quot;
    },
    USD: {
      cent: 2,
      name: &quot;United States dollar&quot;
    },
    USN: {
      cent: 2,
      name: &quot;United States dollar (next day) (funds code)&quot;
    },
    USS: {
      cent: 2,
      name: &quot;United States dollar (same day) (funds code) (one source[who?] claims it is no longer used, but it is still on the ISO 4217-MA list)&quot;
    },
    UYI: {
      cent: 0,
      name: &quot;Uruguay Peso en Unidades Indexadas (URUIURUI) (funds code)&quot;
    },
    UYU: {
      cent: 2,
      name: &quot;Uruguayan peso&quot;
    },
    UZS: {
      cent: 2,
      name: &quot;Uzbekistan som&quot;
    },
    VEF: {
      cent: 2,
      name: &quot;Venezuelan bolívar fuerte&quot;
    },
    VND: {
      cent: 0,
      name: &quot;Vietnamese dong&quot;
    },
    VUV: {
      cent: 0,
      name: &quot;Vanuatu vatu&quot;
    },
    WST: {
      cent: 2,
      name: &quot;Samoan tala&quot;
    },
    XAF: {
      cent: 0,
      name: &quot;CFA franc BEAC&quot;
    },
    XCD: {
      cent: 2,
      name: &quot;East Caribbean dollar&quot;
    },
    XOF: {
      cent: 0,
      name: &quot;CFA franc BCEAO&quot;
    },
    XPF: {
      cent: 0,
      name: &quot;CFP franc&quot;
    },
    YER: {
      cent: 2,
      name: &quot;Yemeni rial&quot;
    },
    ZAR: {
      cent: 2,
      name: &quot;South African rand&quot;
    }
  });

}).call(this);


(function() {

  Tent.TIMEZONES = [
    {
      name: &quot;Australian Central Daylight Time&quot;,
      abbr: &quot;ACDT&quot;,
      UTCOffset: &quot;GMT+1030&quot;
    }, {
      name: &quot;Australian Central Standard Time&quot;,
      abbr: &quot;ACST&quot;,
      UTCOffset: &quot;GMT+0930&quot;
    }, {
      name: &quot;ASEAN Common Time&quot;,
      abbr: &quot;ACT&quot;,
      UTCOffset: &quot;GMT+0800&quot;
    }, {
      name: &quot;Atlantic Daylight Time&quot;,
      abbr: &quot;ADT&quot;,
      UTCOffset: &quot;GMT-0300&quot;
    }, {
      name: &quot;Australian Eastern Daylight Time&quot;,
      abbr: &quot;AEDT&quot;,
      UTCOffset: &quot;GMT+1100&quot;
    }, {
      name: &quot;Australian Eastern Standard Time&quot;,
      abbr: &quot;AEST&quot;,
      UTCOffset: &quot;GMT+1000&quot;
    }, {
      name: &quot;Afghanistan Time&quot;,
      abbr: &quot;AFT&quot;,
      UTCOffset: &quot;GMT+0430&quot;
    }, {
      name: &quot;Alaska Daylight Time&quot;,
      abbr: &quot;AKDT&quot;,
      UTCOffset: &quot;GMT-0800&quot;
    }, {
      name: &quot;Alaska Standard Time&quot;,
      abbr: &quot;AKST&quot;,
      UTCOffset: &quot;GMT-0900&quot;
    }, {
      name: &quot;Armenia Summer Time&quot;,
      abbr: &quot;AMST&quot;,
      UTCOffset: &quot;GMT+0500&quot;
    }, {
      name: &quot;Armenia Time&quot;,
      abbr: &quot;AMT&quot;,
      UTCOffset: &quot;GMT+0400&quot;
    }, {
      name: &quot;Argentina Time&quot;,
      abbr: &quot;ART&quot;,
      UTCOffset: &quot;GMT-0300&quot;
    }, {
      name: &quot;Arab Standard Time (Kuwait, Riyadh)&quot;,
      abbr: &quot;AST&quot;,
      UTCOffset: &quot;GMT+0300&quot;
    }, {
      name: &quot;Arabian Standard Time (Abu Dhabi, Muscat)&quot;,
      abbr: &quot;AST&quot;,
      UTCOffset: &quot;GMT+0400&quot;
    }, {
      name: &quot;Arabic Standard Time (Baghdad)&quot;,
      abbr: &quot;AST&quot;,
      UTCOffset: &quot;GMT+0300&quot;
    }, {
      name: &quot;Atlantic Standard Time&quot;,
      abbr: &quot;AST&quot;,
      UTCOffset: &quot;GMT-0400&quot;
    }, {
      name: &quot;Australian Western Daylight Time&quot;,
      abbr: &quot;AWDT&quot;,
      UTCOffset: &quot;GMT+0900&quot;
    }, {
      name: &quot;Australian Western Standard Time&quot;,
      abbr: &quot;AWST&quot;,
      UTCOffset: &quot;GMT+0800&quot;
    }, {
      name: &quot;Azores Standard Time&quot;,
      abbr: &quot;AZOST&quot;,
      UTCOffset: &quot;GMT-0100&quot;
    }, {
      name: &quot;Azerbaijan Time&quot;,
      abbr: &quot;AZT&quot;,
      UTCOffset: &quot;GMT+0400&quot;
    }, {
      name: &quot;Brunei Time&quot;,
      abbr: &quot;BDT&quot;,
      UTCOffset: &quot;GMT+0800&quot;
    }, {
      name: &quot;British Indian Ocean Time&quot;,
      abbr: &quot;BIOT&quot;,
      UTCOffset: &quot;GMT+0600&quot;
    }, {
      name: &quot;Baker Island Time&quot;,
      abbr: &quot;BIT&quot;,
      UTCOffset: &quot;GMT-1200&quot;
    }, {
      name: &quot;Bolivia Time&quot;,
      abbr: &quot;BOT&quot;,
      UTCOffset: &quot;GMT-0400&quot;
    }, {
      name: &quot;Brasilia Time&quot;,
      abbr: &quot;BRT&quot;,
      UTCOffset: &quot;GMT-0300&quot;
    }, {
      name: &quot;Bangladesh Standard Time&quot;,
      abbr: &quot;BST&quot;,
      UTCOffset: &quot;GMT+0600&quot;
    }, {
      name: &quot;British Summer Time (British Standard Time from Feb 1968 to Oct 1971)&quot;,
      abbr: &quot;BST&quot;,
      UTCOffset: &quot;GMT+0100&quot;
    }, {
      name: &quot;Bhutan Time&quot;,
      abbr: &quot;BTT&quot;,
      UTCOffset: &quot;GMT+0600&quot;
    }, {
      name: &quot;Central Africa Time&quot;,
      abbr: &quot;CAT&quot;,
      UTCOffset: &quot;GMT+0200&quot;
    }, {
      name: &quot;Cocos Islands Time&quot;,
      abbr: &quot;CCT&quot;,
      UTCOffset: &quot;GMT+0630&quot;
    }, {
      name: &quot;Central Daylight Time (North America)&quot;,
      abbr: &quot;CDT&quot;,
      UTCOffset: &quot;GMT-0500&quot;
    }, {
      name: &quot;Cuba Daylight Time[1]&quot;,
      abbr: &quot;CDT&quot;,
      UTCOffset: &quot;GMT-0400&quot;
    }, {
      name: &quot;Central European Daylight Time&quot;,
      abbr: &quot;CEDT&quot;,
      UTCOffset: &quot;GMT+0200&quot;
    }, {
      name: &quot;Central European Summer Time (Cf. HAEC)&quot;,
      abbr: &quot;CEST&quot;,
      UTCOffset: &quot;GMT+0200&quot;
    }, {
      name: &quot;Central European Time&quot;,
      abbr: &quot;CET&quot;,
      UTCOffset: &quot;GMT+0100&quot;
    }, {
      name: &quot;Chatham Daylight Time&quot;,
      abbr: &quot;CHADT&quot;,
      UTCOffset: &quot;GMT+1345&quot;
    }, {
      name: &quot;Chatham Standard Time&quot;,
      abbr: &quot;CHAST&quot;,
      UTCOffset: &quot;GMT+1245&quot;
    }, {
      name: &quot;Choibalsan&quot;,
      abbr: &quot;CHOT&quot;,
      UTCOffset: &quot;GMT-0800&quot;
    }, {
      name: &quot;Chamorro Standard Time&quot;,
      abbr: &quot;ChST&quot;,
      UTCOffset: &quot;GMT+1000&quot;
    }, {
      name: &quot;Chuuk Time&quot;,
      abbr: &quot;CHUT&quot;,
      UTCOffset: &quot;GMT+1000&quot;
    }, {
      name: &quot;Clipperton Island Standard Time&quot;,
      abbr: &quot;CIST&quot;,
      UTCOffset: &quot;GMT-0800&quot;
    }, {
      name: &quot;Central Indonesia Time&quot;,
      abbr: &quot;CIT&quot;,
      UTCOffset: &quot;GMT+0800&quot;
    }, {
      name: &quot;Cook Island Time&quot;,
      abbr: &quot;CKT&quot;,
      UTCOffset: &quot;GMT-1000&quot;
    }, {
      name: &quot;Chile Summer Time&quot;,
      abbr: &quot;CLST&quot;,
      UTCOffset: &quot;GMT-0300&quot;
    }, {
      name: &quot;Chile Standard Time&quot;,
      abbr: &quot;CLT&quot;,
      UTCOffset: &quot;GMT-0400&quot;
    }, {
      name: &quot;Colombia Summer Time&quot;,
      abbr: &quot;COST&quot;,
      UTCOffset: &quot;GMT-0400&quot;
    }, {
      name: &quot;Colombia Time&quot;,
      abbr: &quot;COT&quot;,
      UTCOffset: &quot;GMT-0500&quot;
    }, {
      name: &quot;Central Standard Time (North America)&quot;,
      abbr: &quot;CST&quot;,
      UTCOffset: &quot;GMT-0600&quot;
    }, {
      name: &quot;China Standard Time&quot;,
      abbr: &quot;CST&quot;,
      UTCOffset: &quot;GMT+0800&quot;
    }, {
      name: &quot;Central Standard Time (Australia)&quot;,
      abbr: &quot;CST&quot;,
      UTCOffset: &quot;GMT+0930&quot;
    }, {
      name: &quot;Central Summer Time (Australia)&quot;,
      abbr: &quot;CST&quot;,
      UTCOffset: &quot;GMT+1030&quot;
    }, {
      name: &quot;Cuba Standard Time&quot;,
      abbr: &quot;CST&quot;,
      UTCOffset: &quot;GMT-0500&quot;
    }, {
      name: &quot;China time&quot;,
      abbr: &quot;CT&quot;,
      UTCOffset: &quot;GMT+0800&quot;
    }, {
      name: &quot;Cape Verde Time&quot;,
      abbr: &quot;CVT&quot;,
      UTCOffset: &quot;GMT-0100&quot;
    }, {
      name: &quot;Central Western Standard Time (Australia)&quot;,
      abbr: &quot;CWST&quot;,
      UTCOffset: &quot;GMT+0845&quot;
    }, {
      name: &quot;Christmas Island Time&quot;,
      abbr: &quot;CXT&quot;,
      UTCOffset: &quot;GMT+0700&quot;
    }, {
      name: &quot;Davis Time&quot;,
      abbr: &quot;DAVT&quot;,
      UTCOffset: &quot;GMT+0700&quot;
    }, {
      name: &quot;Dumont d'Urville Time&quot;,
      abbr: &quot;DDUT&quot;,
      UTCOffset: &quot;GMT+1000&quot;
    }, {
      name: &quot;AIX specific equivalent of Central European Time[2]&quot;,
      abbr: &quot;DFT&quot;,
      UTCOffset: &quot;GMT+0100&quot;
    }, {
      name: &quot;Easter Island Standard Summer Time&quot;,
      abbr: &quot;EASST&quot;,
      UTCOffset: &quot;GMT-0500&quot;
    }, {
      name: &quot;Easter Island Standard Time&quot;,
      abbr: &quot;EAST&quot;,
      UTCOffset: &quot;GMT-0600&quot;
    }, {
      name: &quot;East Africa Time&quot;,
      abbr: &quot;EAT&quot;,
      UTCOffset: &quot;GMT+0300&quot;
    }, {
      name: &quot;Eastern Caribbean Time (does not recognise DST)&quot;,
      abbr: &quot;ECT&quot;,
      UTCOffset: &quot;GMT-0400&quot;
    }, {
      name: &quot;Ecuador Time&quot;,
      abbr: &quot;ECT&quot;,
      UTCOffset: &quot;GMT-0500&quot;
    }, {
      name: &quot;Eastern Daylight Time (North America)&quot;,
      abbr: &quot;EDT&quot;,
      UTCOffset: &quot;GMT-0400&quot;
    }, {
      name: &quot;Eastern European Daylight Time&quot;,
      abbr: &quot;EEDT&quot;,
      UTCOffset: &quot;GMT+0300&quot;
    }, {
      name: &quot;Eastern European Summer Time&quot;,
      abbr: &quot;EEST&quot;,
      UTCOffset: &quot;GMT+0300&quot;
    }, {
      name: &quot;Eastern European Time&quot;,
      abbr: &quot;EET&quot;,
      UTCOffset: &quot;GMT+0200&quot;
    }, {
      name: &quot;Eastern Greenland Summer Time&quot;,
      abbr: &quot;EGST&quot;,
      UTCOffset: &quot;GMT+0000&quot;
    }, {
      name: &quot;Eastern Greenland Time&quot;,
      abbr: &quot;EGT&quot;,
      UTCOffset: &quot;GMT-0100&quot;
    }, {
      name: &quot;Eastern Indonesian Time&quot;,
      abbr: &quot;EIT&quot;,
      UTCOffset: &quot;GMT+0900&quot;
    }, {
      name: &quot;Eastern Standard Time (North America)&quot;,
      abbr: &quot;EST&quot;,
      UTCOffset: &quot;GMT-0500&quot;
    }, {
      name: &quot;Eastern Standard Time (Australia)&quot;,
      abbr: &quot;EST&quot;,
      UTCOffset: &quot;GMT+1000&quot;
    }, {
      name: &quot;Further-eastern_European_Time&quot;,
      abbr: &quot;FET&quot;,
      UTCOffset: &quot;GMT+0300&quot;
    }, {
      name: &quot;Fiji Time&quot;,
      abbr: &quot;FJT&quot;,
      UTCOffset: &quot;GMT+1200&quot;
    }, {
      name: &quot;Falkland Islands Summer Time&quot;,
      abbr: &quot;FKST&quot;,
      UTCOffset: &quot;GMT-0300&quot;
    }, {
      name: &quot;Falkland Islands Time&quot;,
      abbr: &quot;FKT&quot;,
      UTCOffset: &quot;GMT-0400&quot;
    }, {
      name: &quot;Fernando de Noronha Time&quot;,
      abbr: &quot;FNT&quot;,
      UTCOffset: &quot;GMT-0200&quot;
    }, {
      name: &quot;Galapagos Time&quot;,
      abbr: &quot;GALT&quot;,
      UTCOffset: &quot;GMT-0600&quot;
    }, {
      name: &quot;Gambier Islands&quot;,
      abbr: &quot;GAMT&quot;,
      UTCOffset: &quot;GMT-0900&quot;
    }, {
      name: &quot;Georgia Standard Time&quot;,
      abbr: &quot;GET&quot;,
      UTCOffset: &quot;GMT+0400&quot;
    }, {
      name: &quot;French Guiana Time&quot;,
      abbr: &quot;GFT&quot;,
      UTCOffset: &quot;GMT-0300&quot;
    }, {
      name: &quot;Gilbert Island Time&quot;,
      abbr: &quot;GILT&quot;,
      UTCOffset: &quot;GMT+1200&quot;
    }, {
      name: &quot;Gambier Island Time&quot;,
      abbr: &quot;GIT&quot;,
      UTCOffset: &quot;GMT-0900&quot;
    }, {
      name: &quot;Greenwich Mean Time&quot;,
      abbr: &quot;GMT&quot;,
      UTCOffset: &quot;GMT+0000&quot;
    }, {
      name: &quot;South Georgia and the South Sandwich Islands&quot;,
      abbr: &quot;GST&quot;,
      UTCOffset: &quot;GMT-0200&quot;
    }, {
      name: &quot;Gulf Standard Time&quot;,
      abbr: &quot;GST&quot;,
      UTCOffset: &quot;GMT+0400&quot;
    }, {
      name: &quot;Guyana Time&quot;,
      abbr: &quot;GYT&quot;,
      UTCOffset: &quot;GMT-0400&quot;
    }, {
      name: &quot;Hawaii-Aleutian Daylight Time&quot;,
      abbr: &quot;HADT&quot;,
      UTCOffset: &quot;GMT-0900&quot;
    }, {
      name: &quot;Heure Avancée d'Europe Centrale francised name for CEST&quot;,
      abbr: &quot;HAEC&quot;,
      UTCOffset: &quot;GMT+0200&quot;
    }, {
      name: &quot;Hawaii-Aleutian Standard Time&quot;,
      abbr: &quot;HAST&quot;,
      UTCOffset: &quot;GMT-1000&quot;
    }, {
      name: &quot;Hong Kong Time&quot;,
      abbr: &quot;HKT&quot;,
      UTCOffset: &quot;GMT+0800&quot;
    }, {
      name: &quot;Heard and McDonald Islands Time&quot;,
      abbr: &quot;HMT&quot;,
      UTCOffset: &quot;GMT+0500&quot;
    }, {
      name: &quot;Khovd Time&quot;,
      abbr: &quot;HOVT&quot;,
      UTCOffset: &quot;GMT+0700&quot;
    }, {
      name: &quot;Hawaii Standard Time&quot;,
      abbr: &quot;HST&quot;,
      UTCOffset: &quot;GMT-1000&quot;
    }, {
      name: &quot;Indochina Time&quot;,
      abbr: &quot;ICT&quot;,
      UTCOffset: &quot;GMT+0700&quot;
    }, {
      name: &quot;Israel Daylight Time&quot;,
      abbr: &quot;IDT&quot;,
      UTCOffset: &quot;GMT+0300&quot;
    }, {
      name: &quot;Indian Ocean Time&quot;,
      abbr: &quot;IOT&quot;,
      UTCOffset: &quot;GMT+0300&quot;
    }, {
      name: &quot;Iran Daylight Time&quot;,
      abbr: &quot;IRDT&quot;,
      UTCOffset: &quot;GMT+0800&quot;
    }, {
      name: &quot;Irkutsk Time&quot;,
      abbr: &quot;IRKT&quot;,
      UTCOffset: &quot;GMT+0900&quot;
    }, {
      name: &quot;Iran Standard Time&quot;,
      abbr: &quot;IRST&quot;,
      UTCOffset: &quot;GMT+0330&quot;
    }, {
      name: &quot;Indian Standard Time&quot;,
      abbr: &quot;IST&quot;,
      UTCOffset: &quot;GMT+0530&quot;
    }, {
      name: &quot;Irish Standard Time[3]&quot;,
      abbr: &quot;IST&quot;,
      UTCOffset: &quot;GMT+0100&quot;
    }, {
      name: &quot;Israel Standard Time&quot;,
      abbr: &quot;IST&quot;,
      UTCOffset: &quot;GMT+0200&quot;
    }, {
      name: &quot;Japan Standard Time&quot;,
      abbr: &quot;JST&quot;,
      UTCOffset: &quot;GMT+0900&quot;
    }, {
      name: &quot;Kyrgyzstan time&quot;,
      abbr: &quot;KGT&quot;,
      UTCOffset: &quot;GMT+0600&quot;
    }, {
      name: &quot;Kosrae Time&quot;,
      abbr: &quot;KOST&quot;,
      UTCOffset: &quot;GMT+1100&quot;
    }, {
      name: &quot;Krasnoyarsk Time&quot;,
      abbr: &quot;KRAT&quot;,
      UTCOffset: &quot;GMT+0700&quot;
    }, {
      name: &quot;Korea Standard Time&quot;,
      abbr: &quot;KST&quot;,
      UTCOffset: &quot;GMT+0900&quot;
    }, {
      name: &quot;Lord Howe Standard Time&quot;,
      abbr: &quot;LHST&quot;,
      UTCOffset: &quot;GMT+1030&quot;
    }, {
      name: &quot;Lord Howe Summer Time&quot;,
      abbr: &quot;LHST&quot;,
      UTCOffset: &quot;GMT+1100&quot;
    }, {
      name: &quot;Line Islands Time&quot;,
      abbr: &quot;LINT&quot;,
      UTCOffset: &quot;GMT+1400&quot;
    }, {
      name: &quot;Magadan Time&quot;,
      abbr: &quot;MAGT&quot;,
      UTCOffset: &quot;GMT+1200&quot;
    }, {
      name: &quot;Marquesas Islands Time&quot;,
      abbr: &quot;MART&quot;,
      UTCOffset: &quot;GMT-0930&quot;
    }, {
      name: &quot;Mawson Station Time&quot;,
      abbr: &quot;MAWT&quot;,
      UTCOffset: &quot;GMT+0500&quot;
    }, {
      name: &quot;Mountain Daylight Time (North America)&quot;,
      abbr: &quot;MDT&quot;,
      UTCOffset: &quot;GMT-0600&quot;
    }, {
      name: &quot;Middle European Time Same zone as CET&quot;,
      abbr: &quot;MET&quot;,
      UTCOffset: &quot;GMT+0100&quot;
    }, {
      name: &quot;Middle European Saving Time Same zone as CEST&quot;,
      abbr: &quot;MEST&quot;,
      UTCOffset: &quot;GMT+0200&quot;
    }, {
      name: &quot;Marshall Islands&quot;,
      abbr: &quot;MHT&quot;,
      UTCOffset: &quot;GMT+1200&quot;
    }, {
      name: &quot;Macquarie Island Station Time&quot;,
      abbr: &quot;MIST&quot;,
      UTCOffset: &quot;GMT+1100&quot;
    }, {
      name: &quot;Marquesas Islands Time&quot;,
      abbr: &quot;MIT&quot;,
      UTCOffset: &quot;GMT-0930&quot;
    }, {
      name: &quot;Myanmar Time&quot;,
      abbr: &quot;MMT&quot;,
      UTCOffset: &quot;GMT+0630&quot;
    }, {
      name: &quot;Moscow Time&quot;,
      abbr: &quot;MSK&quot;,
      UTCOffset: &quot;GMT+0400&quot;
    }, {
      name: &quot;Malaysia Standard Time&quot;,
      abbr: &quot;MST&quot;,
      UTCOffset: &quot;GMT+0800&quot;
    }, {
      name: &quot;Mountain Standard Time (North America)&quot;,
      abbr: &quot;MST&quot;,
      UTCOffset: &quot;GMT-0700&quot;
    }, {
      name: &quot;Myanmar Standard Time&quot;,
      abbr: &quot;MST&quot;,
      UTCOffset: &quot;GMT+0630&quot;
    }, {
      name: &quot;Mauritius Time&quot;,
      abbr: &quot;MUT&quot;,
      UTCOffset: &quot;GMT+0400&quot;
    }, {
      name: &quot;Maldives Time&quot;,
      abbr: &quot;MVT&quot;,
      UTCOffset: &quot;GMT+0500&quot;
    }, {
      name: &quot;Malaysia Time&quot;,
      abbr: &quot;MYT&quot;,
      UTCOffset: &quot;GMT+0800&quot;
    }, {
      name: &quot;New Caledonia Time&quot;,
      abbr: &quot;NCT&quot;,
      UTCOffset: &quot;GMT+1100&quot;
    }, {
      name: &quot;Newfoundland Daylight Time&quot;,
      abbr: &quot;NDT&quot;,
      UTCOffset: &quot;GMT-0230&quot;
    }, {
      name: &quot;Norfolk Time&quot;,
      abbr: &quot;NFT&quot;,
      UTCOffset: &quot;GMT+1130&quot;
    }, {
      name: &quot;Nepal Time&quot;,
      abbr: &quot;NPT&quot;,
      UTCOffset: &quot;GMT+0545&quot;
    }, {
      name: &quot;Newfoundland Standard Time&quot;,
      abbr: &quot;NST&quot;,
      UTCOffset: &quot;GMT-0330&quot;
    }, {
      name: &quot;Newfoundland Time&quot;,
      abbr: &quot;NT&quot;,
      UTCOffset: &quot;GMT-0330&quot;
    }, {
      name: &quot;Niue Time&quot;,
      abbr: &quot;NUT&quot;,
      UTCOffset: &quot;GMT-1130&quot;
    }, {
      name: &quot;New Zealand Daylight Time&quot;,
      abbr: &quot;NZDT&quot;,
      UTCOffset: &quot;GMT+1300&quot;
    }, {
      name: &quot;New Zealand Standard Time&quot;,
      abbr: &quot;NZST&quot;,
      UTCOffset: &quot;GMT+1200&quot;
    }, {
      name: &quot;Omsk Time&quot;,
      abbr: &quot;OMST&quot;,
      UTCOffset: &quot;GMT+0600&quot;
    }, {
      name: &quot;Oral Time&quot;,
      abbr: &quot;ORAT&quot;,
      UTCOffset: &quot;GMT+0500&quot;
    }, {
      name: &quot;Pacific Daylight Time (North America)&quot;,
      abbr: &quot;PDT&quot;,
      UTCOffset: &quot;GMT-0700&quot;
    }, {
      name: &quot;Peru Time&quot;,
      abbr: &quot;PET&quot;,
      UTCOffset: &quot;GMT-0500&quot;
    }, {
      name: &quot;Kamchatka Time&quot;,
      abbr: &quot;PETT&quot;,
      UTCOffset: &quot;GMT+1200&quot;
    }, {
      name: &quot;Papua New Guinea Time&quot;,
      abbr: &quot;PGT&quot;,
      UTCOffset: &quot;GMT+1000&quot;
    }, {
      name: &quot;Phoenix Island Time&quot;,
      abbr: &quot;PHOT&quot;,
      UTCOffset: &quot;GMT+1300&quot;
    }, {
      name: &quot;Philippine Time&quot;,
      abbr: &quot;PHT&quot;,
      UTCOffset: &quot;GMT+0800&quot;
    }, {
      name: &quot;Pakistan Standard Time&quot;,
      abbr: &quot;PKT&quot;,
      UTCOffset: &quot;GMT+0500&quot;
    }, {
      name: &quot;Saint Pierre and Miquelon Daylight time&quot;,
      abbr: &quot;PMDT&quot;,
      UTCOffset: &quot;GMT-0200&quot;
    }, {
      name: &quot;Saint Pierre and Miquelon Standard Time&quot;,
      abbr: &quot;PMST&quot;,
      UTCOffset: &quot;GMT-0300&quot;
    }, {
      name: &quot;Pohnpei Standard Time&quot;,
      abbr: &quot;PONT&quot;,
      UTCOffset: &quot;GMT+1100&quot;
    }, {
      name: &quot;Pacific Standard Time (North America)&quot;,
      abbr: &quot;PST&quot;,
      UTCOffset: &quot;GMT-0800&quot;
    }, {
      name: &quot;Philippine Standard Time&quot;,
      abbr: &quot;PST&quot;,
      UTCOffset: &quot;GMT+0800&quot;
    }, {
      name: &quot;Réunion Time&quot;,
      abbr: &quot;RET&quot;,
      UTCOffset: &quot;GMT+0400&quot;
    }, {
      name: &quot;Rothera Research Station Time&quot;,
      abbr: &quot;ROTT&quot;,
      UTCOffset: &quot;GMT-0300&quot;
    }, {
      name: &quot;Sakhalin Island time&quot;,
      abbr: &quot;SAKT&quot;,
      UTCOffset: &quot;GMT+1100&quot;
    }, {
      name: &quot;Samara Time&quot;,
      abbr: &quot;SAMT&quot;,
      UTCOffset: &quot;GMT+0400&quot;
    }, {
      name: &quot;South African Standard Time&quot;,
      abbr: &quot;SAST&quot;,
      UTCOffset: &quot;GMT+0200&quot;
    }, {
      name: &quot;Solomon Islands Time&quot;,
      abbr: &quot;SBT&quot;,
      UTCOffset: &quot;GMT+1100&quot;
    }, {
      name: &quot;Seychelles Time&quot;,
      abbr: &quot;SCT&quot;,
      UTCOffset: &quot;GMT+0400&quot;
    }, {
      name: &quot;Singapore Time&quot;,
      abbr: &quot;SGT&quot;,
      UTCOffset: &quot;GMT+0800&quot;
    }, {
      name: &quot;Sri Lanka Time&quot;,
      abbr: &quot;SLT&quot;,
      UTCOffset: &quot;GMT+0530&quot;
    }, {
      name: &quot;Suriname Time&quot;,
      abbr: &quot;SRT&quot;,
      UTCOffset: &quot;GMT-0300&quot;
    }, {
      name: &quot;Samoa Standard Time&quot;,
      abbr: &quot;SST&quot;,
      UTCOffset: &quot;GMT-1100&quot;
    }, {
      name: &quot;Singapore Standard Time&quot;,
      abbr: &quot;SST&quot;,
      UTCOffset: &quot;GMT+0800&quot;
    }, {
      name: &quot;Showa Station Time&quot;,
      abbr: &quot;SYOT&quot;,
      UTCOffset: &quot;GMT+0300&quot;
    }, {
      name: &quot;Tahiti Time&quot;,
      abbr: &quot;TAHT&quot;,
      UTCOffset: &quot;GMT-1000&quot;
    }, {
      name: &quot;Thailand Standard Time&quot;,
      abbr: &quot;THA&quot;,
      UTCOffset: &quot;GMT+0700&quot;
    }, {
      name: &quot;Indian/Kerguelen&quot;,
      abbr: &quot;TFT&quot;,
      UTCOffset: &quot;GMT+0500&quot;
    }, {
      name: &quot;Tajikistan Time&quot;,
      abbr: &quot;TJT&quot;,
      UTCOffset: &quot;GMT+0500&quot;
    }, {
      name: &quot;Tokelau Time&quot;,
      abbr: &quot;TKT&quot;,
      UTCOffset: &quot;GMT+1400&quot;
    }, {
      name: &quot;Timor Leste Time&quot;,
      abbr: &quot;TLT&quot;,
      UTCOffset: &quot;GMT+0900&quot;
    }, {
      name: &quot;Turkmenistan Time&quot;,
      abbr: &quot;TMT&quot;,
      UTCOffset: &quot;GMT+0500&quot;
    }, {
      name: &quot;Tonga Time&quot;,
      abbr: &quot;TOT&quot;,
      UTCOffset: &quot;GMT+1300&quot;
    }, {
      name: &quot;Tuvalu Time&quot;,
      abbr: &quot;TVT&quot;,
      UTCOffset: &quot;GMT+1200&quot;
    }, {
      name: &quot;Coordinated Universal Time&quot;,
      abbr: &quot;UCT&quot;,
      UTCOffset: &quot;GMT+0000&quot;
    }, {
      name: &quot;Ulaanbaatar Time&quot;,
      abbr: &quot;ULAT&quot;,
      UTCOffset: &quot;GMT+0800&quot;
    }, {
      name: &quot;Coordinated Universal Time&quot;,
      abbr: &quot;GMT&quot;,
      UTCOffset: &quot;GMT+0000&quot;
    }, {
      name: &quot;Uruguay Summer Time&quot;,
      abbr: &quot;UYST&quot;,
      UTCOffset: &quot;GMT-0200&quot;
    }, {
      name: &quot;Uruguay Standard Time&quot;,
      abbr: &quot;UYT&quot;,
      UTCOffset: &quot;GMT-0300&quot;
    }, {
      name: &quot;Uzbekistan Time&quot;,
      abbr: &quot;UZT&quot;,
      UTCOffset: &quot;GMT+0500&quot;
    }, {
      name: &quot;Venezuelan Standard Time&quot;,
      abbr: &quot;VET&quot;,
      UTCOffset: &quot;GMT-0430&quot;
    }, {
      name: &quot;Vladivostok Time&quot;,
      abbr: &quot;VLAT&quot;,
      UTCOffset: &quot;GMT+1000&quot;
    }, {
      name: &quot;Volgograd Time&quot;,
      abbr: &quot;VOLT&quot;,
      UTCOffset: &quot;GMT+0400&quot;
    }, {
      name: &quot;Vostok Station Time&quot;,
      abbr: &quot;VOST&quot;,
      UTCOffset: &quot;GMT+0600&quot;
    }, {
      name: &quot;Vanuatu Time&quot;,
      abbr: &quot;VUT&quot;,
      UTCOffset: &quot;GMT+1100&quot;
    }, {
      name: &quot;Wake Island Time&quot;,
      abbr: &quot;WAKT&quot;,
      UTCOffset: &quot;GMT+1200&quot;
    }, {
      name: &quot;West Africa Summer Time&quot;,
      abbr: &quot;WAST&quot;,
      UTCOffset: &quot;GMT+0200&quot;
    }, {
      name: &quot;West Africa Time&quot;,
      abbr: &quot;WAT&quot;,
      UTCOffset: &quot;GMT+0100&quot;
    }, {
      name: &quot;Western European Daylight Time&quot;,
      abbr: &quot;WEDT&quot;,
      UTCOffset: &quot;GMT+0100&quot;
    }, {
      name: &quot;Western European Summer Time&quot;,
      abbr: &quot;WEST&quot;,
      UTCOffset: &quot;GMT+0100&quot;
    }, {
      name: &quot;Western European Time&quot;,
      abbr: &quot;WET&quot;,
      UTCOffset: &quot;GMT+0000&quot;
    }, {
      name: &quot;Western Standard Time&quot;,
      abbr: &quot;WST&quot;,
      UTCOffset: &quot;GMT+0800&quot;
    }, {
      name: &quot;Yakutsk Time&quot;,
      abbr: &quot;YAKT&quot;,
      UTCOffset: &quot;GMT+0900&quot;
    }, {
      name: &quot;Yekaterinburg Time&quot;,
      abbr: &quot;YEKT&quot;,
      UTCOffset: &quot;GMT+0500&quot;
    }
  ];

}).call(this);


(function() {
}).call(this);


(function() {

  Tent.Browsers = {};

  Tent.Browsers.getIEVersion = function() {
    var a, div, v, version;
    v = 3;
    div = document.createElement('div');
    a = div.all || [];
    while (v &lt; 10) {
      div.innerHTML = '&lt;!--[if gt IE ' + (++v) + ']&gt;&lt;i&gt;&lt;/i&gt;&lt;![endif]--&gt;';
      if (div.getElementsByTagName('i')[0] != null) {
        version = v;
      }
    }
    return version;
  };

  Tent.Browsers.isIE = function() {
    var res;
    res = this.getIEVersion() != null;
    this.isIE = function() {
      return res;
    };
    return res;
  };

}).call(this);


(function() {

  Tent.ResizeSupport = Ember.Mixin.create({
    resize: function() {
      var _ref;
      return (_ref = this.get('childViews')) != null ? _ref.forEach(function(child) {
        return typeof child.resize === &quot;function&quot; ? child.resize() : void 0;
      }) : void 0;
    }
  });

  Ember.$(document).ready(function() {
    return window.onresize = function() {
      return $.publish('/window/resize');
    };
  });

}).call(this);


(function() {

  Tent.DEFAULT_STRING_TRUNCATION_LENGTH = 30;

  Ember.mixin(String.prototype, {
    truncate: function(maxLength) {
      var length;
      length = Ember.none(maxLength) ? Tent.DEFAULT_STRING_TRUNCATION_LENGTH : maxLength;
      if (this.length &lt;= length) {
        return this.toString();
      } else {
        return this.substr(0, length) + '...';
      }
    },
    camelToWords: function() {
      var spaced;
      spaced = this.replace(/([A-Z])/g, &quot; $1&quot;);
      return spaced[0].toUpperCase() + spaced.substring(1);
    },
    isBlank: function() {
      return this.trim().length === 0;
    },
    toBoolean: function() {
      return this.toLowerCase() === 'true';
    }
  });

  if (!(String.prototype.trim != null)) {
    String.prototype.trim = function() {
      return this.replace(/^\s+|\s+$/g, '');
    };
  }

}).call(this);


(function() {

  if (Tent.computed == null) {
    Tent.computed = {};
  }

  Tent.computed.boolCoerceGently = function(dependentKey) {
    return Ember.computed(dependentKey, (function(key) {
      var value;
      value = this.get(dependentKey);
      if (typeof value === &quot;boolean&quot;) {
        return value;
      }
      if (typeof value === 'string') {
        return value.toBoolean();
      }
      if (typeof value === 'number') {
        return value !== 0;
      }
    }));
  };

  Tent.computed.translate = function(dependentKey) {
    return Ember.computed(dependentKey, (function(key) {
      var value;
      value = this.get(dependentKey) || '';
      return Tent.translate(value);
    }));
  };

}).call(this);


(function() {

  if (Tent.messages == null) {
    Tent.messages = {};
  }

  Tent.messages.GENERIC_ERROR = 'error.generic';

  Tent.messages.REQUIRED_ERROR = 'error.required';

  Tent.messages.NUMERIC_ERROR = &quot;error.numeric&quot;;

  Tent.messages.AMOUNT_ERROR = &quot;error.amount&quot;;

  Tent.messages.EMAIL_FORMAT_ERROR = &quot;error.email&quot;;

  Tent.messages.DATE_FORMAT_ERROR = &quot;error.date&quot;;

  Tent.messages.DATE_BETWEEN_ERROR = &quot;error.dateBetween&quot;;

  Tent.messages.DATE_FUTURE_ERROR = &quot;error.dateFuture&quot;;

  Tent.messages.MIN_LENGTH = &quot;error.minLength&quot;;

  Tent.messages.MAX_LENGTH = &quot;error.maxLength&quot;;

  Tent.messages.CURRENCY_ERROR = &quot;error.invalidCurrency&quot;;

  Tent.messages.REG_EXP = &quot;error.regexp&quot;;

  Tent.messages.MIN_VALUE_ERROR = &quot;error.minValue&quot;;

  Tent.messages.MAX_VALUE_ERROR = &quot;error.maxValue&quot;;

  Tent.messages.VALUE_BETWEEN_ERROR = &quot;error.valueBetween&quot;;

  Tent.messages.POSITIVE_ERROR = &quot;error.positive&quot;;

}).call(this);


(function() {

  Tent.SelectableArrayProxy = Ember.ArrayProxy.extend({
    init: function() {
      this._super();
      this.set('_selectedElementsArray', []);
      this.set('_selectedIndexArray', []);
      this.set('_selectedElement', null);
      this.set('_selectedIndex', -1);
      return this.set('_selection', null);
    },
    clearSelection: function() {
      return this.set('selected', null);
    },
    selectAll: function() {
      var _this = this;
      if (this.get('isMultipleSelectionAllowed')) {
        this.beginPropertyChanges();
        this.clearSelection();
        this.get('content').forEach(function(element) {
          return _this.set('selected', element);
        });
        return this.endPropertyChanges();
      }
    },
    selected: (function(key, value) {
      if (value !== undefined) {
        if (this.get('isMultipleSelectionAllowed')) {
          this.set('_selection', this._multiSelection(value).slice());
        } else {
          this.set('_selection', new Array(this._singleSelection(value)).slice());
        }
      }
      return this.get('_selection');
    }).property().volatile(),
    _singleSelection: (function(value) {
      if (value !== undefined) {
        if (value !== null) {
          if (value !== this.get('_selectedElement')) {
            if (this.indexOf(value &gt;= 0)) {
              this.set('_selectedElement', value);
              this.set('_selectedIndex', this.indexOf(value));
            }
          } else {
            this.set('_selectedElement', null);
            this.set('_selectedIndex', -1);
          }
        } else {
          this.set('_selectedElement', null);
          this.set('_selectedIndex', -1);
        }
      }
      return this.get('_selectedElement');
    }),
    _multiSelection: function(value) {
      var selectedElements, selectedIndices;
      if (value !== undefined) {
        if (value !== null) {
          selectedElements = this.get('_selectedElementsArray');
          selectedIndices = this.get('_selectedIndexArray');
          if (selectedElements.contains(value)) {
            selectedElements.removeObject(value);
            selectedIndices.splice(selectedIndices.indexOf(this.indexOf(value)), 1);
          } else {
            selectedElements.addObject(value);
            selectedIndices.push(this.indexOf(value));
          }
        } else {
          this.set('_selectedElementsArray', []);
          this.set('_selectedIndexArray', []);
        }
      }
      return this.get('_selectedElementsArray');
    },
    contentDidChange: (function() {
      var content, currentElement, currentElementsArray, currentIndex, currentIndexArray, element, newIndex, newIndexArray, _i, _j, _len, _len1, _results;
      content = this.get('content');
      if (this.get('isMultipleSelectionAllowed')) {
        currentIndexArray = this.get('_selectedIndexArray');
        currentElementsArray = this.get('_selectedElementsArray');
        newIndexArray = [];
        if (currentElementsArray.length !== 0) {
          for (_i = 0, _len = currentElementsArray.length; _i &lt; _len; _i++) {
            element = currentElementsArray[_i];
            if (content.contains(element)) {
              newIndexArray.push(content.indexOf(element));
            }
          }
          if (currentIndexArray.toString() !== newIndexArray.toString()) {
            this.set('_selectedElementsArray', []);
            this.set('_selectedIndexArray', []);
            if (newIndexArray.length !== 0) {
              _results = [];
              for (_j = 0, _len1 = newIndexArray.length; _j &lt; _len1; _j++) {
                element = newIndexArray[_j];
                _results.push(this.set('selected', content.objectAt(element)));
              }
              return _results;
            } else {
              return this.set('selected', null);
            }
          }
        }
      } else {
        currentIndex = this.get('_selectedIndex');
        currentElement = this.get('_selectedElement');
        if (currentElement !== null) {
          if (content.contains(currentElement)) {
            newIndex = this.indexOf(currentElement);
            if (newIndex !== currentIndex) {
              return this.set('_selectedIndex', content.indexOf(currentElement));
            }
          } else {
            return this.set('selected', null);
          }
        }
      }
    }).observes('content.@each')
  });

}).call(this);


(function() {

  accounting.settings = {
    currency: {
      symbol: &quot;$&quot;,
      format: &quot;%s%v&quot;,
      decimal: &quot;.&quot;,
      thousand: &quot;,&quot;,
      precision: 2
    },
    number: {
      precision: 2,
      thousand: &quot;,&quot;,
      decimal: &quot;.&quot;,
      pattern: 'xxx,xxx.xx'
    }
  };

  if (Tent.Formatting == null) {
    Tent.Formatting = {};
  }

<span id='Tent-Formatting'>  /**
</span>  * @class Tent.Formatting
  * 
  * Formatting methods for converting base values to and from presentation strings.
  *
  */


<span id='Tent-Formatting-amount'>  /**
</span>  * @class Tent.Formatting.amount
  */


  Tent.Formatting.amount = Ember.Object.create({
    cleanup: function(value) {
      if ((value != null) &amp;&amp; value !== '') {
        return Tent.Formatting.amount.format(accounting.unformat(value));
      } else {
        return &quot;&quot;;
      }
    },
<span id='Tent-Formatting-amount-method-format'>    /**
</span>    	* @method format
    	* Formats an amount
    	* @param {Number} amount The amount to format
    	* @param {Array} [settings] Optional setting to use for formatting
    	* @return {String} The formatted value
    */

    format: function(amount, settings) {
      if (amount != null) {
        if (settings != null) {
          settings = Tent.Formatting.amount.settingsFilter(settings);
          return accounting.formatNumber(amount, settings);
        } else {
          return accounting.formatNumber(amount);
        }
      } else {
        return &quot;&quot;;
      }
    },
<span id='Tent-Formatting-amount-method-unformat'>    /**
</span>    	* @method unformat
    	* Unformats an amount
    	* @param {String} amount The amount to format
    	* @param {Array} [settings] Optional setting to use for formatting
    	* @return {Number} The unformatted value
    */

    unformat: function(amount, settings) {
      if (amount != null) {
        if (settings != null) {
          settings = Tent.Formatting.amount.settingsFilter(settings);
          return accounting.unformat(amount, settings);
        } else {
          return accounting.unformat(amount);
        }
      } else {
        return null;
      }
    },
    settingsFilter: function(rawSettings) {
      return rawSettings;
    },
    cssClass: function() {
      return &quot;amount&quot;;
    },
<span id='Tent-Formatting-amount-property-serializer'>    /**
</span>    	* @Object serializer A serialization object which implements serialize() and deserialize() methods.
    */

    serializer: null
  });

  Tent.Formatting.date = Ember.Object.create({
    options: {
      dateFormat: &quot;mm/dd/yy&quot;
    },
    getFormat: function() {
      return this.get('options').dateFormat;
    },
    format: function(value, dateFormat) {
      var hours, minutes;
      if (dateFormat === &quot;dd-M-yy hh-mm tz&quot;) {
        hours = value.getHours();
        if (hours &lt; 10) {
          hours = &quot;0&quot; + hours;
        }
        minutes = value.getMinutes();
        if (minutes &lt; 10) {
          minutes = &quot;0&quot; + minutes;
        }
        return Tent.Formatting.date.format(value, &quot;dd-M-yy&quot;) + ' ' + hours + ':' + minutes + &quot; (&quot; + Tent.Date.getAbbreviatedTZFromDate(value) + &quot;)&quot;;
      } else {
        return $.datepicker.formatDate(dateFormat || Tent.Formatting.date.getFormat(), value);
      }
    },
    unformat: function(value, dateFormat) {
      if (dateFormat === &quot;dd-M-yy hh-mm tz&quot;) {
        return $.datepicker.parseDate(&quot;dd-M-yy&quot;, value.substring(0, 11));
      } else {
        return $.datepicker.parseDate(dateFormat || Tent.Formatting.date.getFormat(), value);
      }
    },
    cssClass: function() {
      return &quot;date&quot;;
    }
  });

  Tent.Formatting.number = Ember.Object.create({
    isValidNumber: function(value) {
      return (value !== '') &amp;&amp; !(isNaN(value) || isNaN(parseFloat(value)));
    },
    errorText: function() {
      return Tent.I18n.loc('formatting.number');
    },
    format: function(value) {
      if ((typeof value === 'number') || value === '') {
        return value.toString(10);
      } else if (value != null) {
        return value;
      } else {
        return &quot;&quot;;
      }
    },
    unformat: function(value) {
      var val;
      if (this.isValidNumber(value)) {
        return val = parseFloat(value);
      } else if (value === &quot;&quot;) {
        return null;
      } else {
        return value;
      }
    },
    cssClass: function() {
      return &quot;amount&quot;;
    },
<span id='Tent-Formatting-amount-property-serializer'>    /**
</span>    	* @Object serializer A serialization object which implements serialize() and deserialize() methods.
    */

    serializer: null
  });

  Tent.Formatting.percent = Ember.Object.create({
    isValidNumber: function(value) {
      return (value !== '') &amp;&amp; !(isNaN(value) || isNaN(parseFloat(value)));
    },
    errorText: function() {
      return Tent.I18n.loc('formatting.percent');
    },
    format: function(value) {
      if (typeof value === 'number') {
        return Math.round(1000 * value) / 10..toString(10) + &quot;%&quot;;
      } else if (value != null) {
        return value;
      } else {
        return &quot;&quot;;
      }
    },
    unformat: function(value) {
      var val;
      if (value === &quot;&quot; || !(value != null)) {
        return null;
      }
      if (value.indexOf('%') !== -1) {
        value = value.split('%')[0];
      }
      if (this.isValidNumber(value)) {
        return val = parseFloat((value / 100).toFixed(3));
      } else {
        return value;
      }
    },
    cssClass: function() {
      return &quot;amount&quot;;
    }
  });

}).call(this);



<span id='Tent-Validations'>/**
</span>* @class Tent.Validations
* Validations that can be applied to tent fields
*/


(function() {

  Tent.Validations = Ember.Object.create();

  Tent.Validation = Ember.Object.extend({
    ERROR_MESSAGE: Tent.messages.GENERIC_ERROR,
    isValueEmpty: function(value) {
      return !((value != null) &amp;&amp; value !== '');
    },
    getErrorMessage: function(value, options) {
      return Tent.I18n.loc(this.get('ERROR_MESSAGE'), options || []);
    }
  });

<span id='Tent-Validations-email'>  /**
</span>  * @class Tent.Validations.email Validates that the value conforms to an email format
  */


<span id='Tent-Validations-email-method-validate'>  /**
</span>  * @method validate
  * @param {String} value the value to test
  * @return {Boolean} the result of the validation
  */


  Tent.Validations.email = Tent.Validation.create({
    validate: function(value, options, message, view) {
      var isValid, pattern;
      pattern = /^(([A-Za-z0-9]+_+)|([A-Za-z0-9]+\-+)|([A-Za-z0-9]+\.+)|([A-Za-z0-9]+\++))*[A-Za-z0-9]+@((\w+\-+)|(\w+\.))*\w{1,63}\.[a-zA-Z]{2,6}$/i;
      return isValid = this.isValueEmpty(value) || pattern.test(value);
    },
    ERROR_MESSAGE: Tent.messages.EMAIL_FORMAT_ERROR
  });

<span id='Tent-Validations-datebetween'>  /**
</span>  * @class Tent.Validations.datebetween Validates that the date is between two specified dates
  */


  Tent.Validations.datebetween = Tent.Validation.create({
<span id='Tent-Validations-datebetween-method-validate'>    /**
</span>    * @method validate
    * @param {String} value the value to test
    * @param {Object} options the options to pass to the validation. options must contain a 
    * 'startDate' and an 'endDate' property
    * @return {Boolean} the result of the validation
    */

    validate: function(value, options, message, view) {
      var isValid;
      if (!(options != null) || !(options.startDate != null) || !(options.endDate != null)) {
        return false;
      }
      return isValid = this.isValueEmpty(value) || (this.convertToDate(value) &gt; this.convertToDate(options.startDate) &amp;&amp; this.convertToDate(value) &lt; this.convertToDate(options.endDate));
    },
    convertToDate: function(value) {
      if (!(value instanceof Date)) {
        return new Date(value);
      }
      return value;
    },
    ERROR_MESSAGE: Tent.messages.DATE_BETWEEN_ERROR
  });

<span id='Tent-Validations-futuredate'>  /**
</span>  * @class Tent.Validations.futuredate Validates that the date value is not later than today
  */


  Tent.Validations.futuredate = Tent.Validation.create({
<span id='Tent-Validations-futuredate-method-validate'>    /**
</span>    * @method validate
    * @param {String} value the value to test
    * @return {Boolean} the result of the validation
    */

    validate: function(value, options, message, view) {
      var today;
      today = new Date();
      if (!this.isValueEmpty(value) &amp;&amp; this.convertToDate(value, view.get('dateFormat')) &gt; today) {
        return false;
      }
      return true;
    },
    convertToDate: function(value, dateFormat) {
      if (!(value instanceof Date)) {
        return Tent.Formatting.date.unformat(value, dateFormat);
      }
      return value;
    },
    ERROR_MESSAGE: Tent.messages.DATE_FUTURE_ERROR
  });

<span id='Tent-Validations-minLength'>  /**
</span>  * @class Tent.Validations.minLength Validates that the value is greater than or equal to a defined length
  */


  Tent.Validations.minLength = Tent.Validation.create({
<span id='Tent-Validations-minLength-method-validate'>    /**
</span>    * @method validate
    * @param {String} value the value to test
    * @param {Object} options the options to pass to the validation. options must contain a 
    * 'min' value
    * @param {String} message an optional message to display if the validation fails
    * @return {Boolean} the result of the validation
    */

    validate: function(value, options, message, view) {
      if (!(options != null) || !(options.min != null)) {
        return false;
      }
      if (value != null) {
        value = value.trim();
      }
      return this.isValueEmpty(value) || value.length &gt;= options.min;
    },
    ERROR_MESSAGE: Tent.messages.MIN_LENGTH
  });

<span id='Tent-Validations-maxLength'>  /**
</span>  * @class Tent.Validations.maxLength Validates that the value is less than or equal to a defined length
  */


  Tent.Validations.maxLength = Tent.Validation.create({
<span id='Tent-Validations-maxLength-method-validate'>    /**
</span>    * @method validate
    * @param {String} value the value to test
    * @param {Object} options the options to pass to the validation. options must contain a 
    * 'max' value
    * @param {String} message an optional message to display if the validation fails
    * @return {Boolean} the result of the validation
    */

    validate: function(value, options, message, view) {
      if (!(options != null) || !(options.max != null)) {
        return false;
      }
      if (value != null) {
        value = value.trim();
      }
      return this.isValueEmpty(value) || value.length &lt;= options.max;
    },
    ERROR_MESSAGE: Tent.messages.MAX_LENGTH
  });

<span id='Tent-Validations-regExp'>  /**
</span>  * @class Tent.Validations.regExp Validates that the value matches a regular expression
  */


  Tent.Validations.regExp = Tent.Validation.create({
<span id='Tent-Validations-regExp-method-validate'>    /**
</span>    * @method validate
    * @param {String} value the value to test
    * @param {Object} options the options to pass to the validation. options must contain a 'regexp' property
    * @param {String} message an optional message to display if the validation fails
    * @return {Boolean} the result of the validation
    */

    validate: function(value, options, message, view) {
      if (!(options != null) || !(options.regexp != null)) {
        return false;
      }
      message = !(message != null) &amp;&amp; (options.message != null) ? options.message : Tent.messages.REG_EXP;
      if (message != null) {
        this.set('ERROR_MESSAGE', message);
      }
      return this.isValueEmpty(value) || options.regexp.test(value);
    },
    ERROR_MESSAGE: Tent.messages.REG_EXP
  });

<span id='Tent-Validations-valueBetween'>  /**
</span>  * @class Tent.Validations.valueBetween Validates that the value is between two numbers
  */


  Tent.Validations.valueBetween = Tent.Validation.create({
<span id='Tent-Validations-valueBetween-method-validate'>    /**
</span>    * @method validate
    * @param {String} value the value to test
    * @param {Object} options the options to pass to the validation. options must contain either a 
    * 'min' or a 'max' value or both
    * @param {String} message an optional message to display if the validation fails
    * @return {Boolean} the result of the validation
    */

    validate: function(value, options, message, view) {
      if (!(options != null) || !((options.min != null) || (options.max != null))) {
        return false;
      }
      message = !(message != null) &amp;&amp; (options.message != null) ? options.message : void 0;
      if (value) {
        if ((options.min != null) &amp;&amp; options.min &gt; value) {
          if (!message) {
            message = Tent.messages.MIN_VALUE_ERROR;
          }
          if (message != null) {
            this.set('ERROR_MESSAGE', message);
          }
          return false;
        } else if ((options.max != null) &amp;&amp; options.max &lt; value) {
          if (!message) {
            message = Tent.messages.MAX_VALUE_ERROR;
          }
          if (message != null) {
            this.set('ERROR_MESSAGE', message);
          }
          return false;
        } else {
          return true;
        }
      } else {
        return true;
      }
    },
    ERROR_MESSAGE: Tent.messages.VALUE_BETWEEN_ERROR
  });

<span id='Tent-Validations-positive'>  /**
</span>  * @class Tent.Validations.positive Validates that the value is positive (&gt;= 0)
  */


  Tent.Validations.positive = Tent.Validation.create({
<span id='Tent-Validations-positive-method-validate'>    /**
</span>    * @method validate
    * @param {String} value the value to test
    * @param {Object} options the options to pass to the validation. options must contain either a 
    * 'min' or a 'max' value or both
    * @param {String} message an optional message to display if the validation fails
    * @return {Boolean} the result of the validation
    */

    validate: function(value, options, message, view) {
      message = !(message != null) &amp;&amp; (options != null) &amp;&amp; (options.message != null) ? options.message : void 0;
      value = Tent.Formatting.amount.unformat(value);
      if (this.isValueEmpty(value) || value &gt;= 0) {
        return true;
      } else {
        return false;
      }
    },
    ERROR_MESSAGE: Tent.messages.POSITIVE_ERROR
  });

}).call(this);



<span id='Tent-Date'>/**
</span>* @class Tent.Date
* This class has methods used to fetch data associated with dates and timezones.
  Private methods used for getting UTCOffset, timezone name or abbreviations using different combinations of data available.
  A &quot;zone&quot; object = A javascript object having timezone name, abbreviation and UTCOffset
*/


(function() {
  var filterZoneUsingTZAbbreviation, filterZoneUsingTZName, getZonesFromAbbreviation, getZonesFromUTCOffset;

  Tent.Date = Ember.Object.create({
<span id='Tent-Date-method-getAbbreviatedTZFromUTCOffsetAndName'>    /**
</span>    * @method getAbbreviatedTZFromUTCOffsetAndName Returns time zone abbreviation
    (closest match of the supplied name string is considered as full names of timezones 
    might be different from what is in the Tent list). 
    Returns null if UTCOffset is missing
    * @param {String} UTCOffset string of type : &quot;GMT+0400&quot;
    * @param {String} name Optional argument which is the full name of timezone
    * @return {String}
    */

    getAbbreviatedTZFromUTCOffsetAndName: function(UTCOffset, name) {
      var zone, zones;
      if (name == null) {
        name = null;
      }
      if (UTCOffset == null) {
        return null;
      }
      zones = getZonesFromUTCOffset(UTCOffset);
      zone = (zones.length === 1 ? zones[0] : filterZoneUsingTZName(zones, name));
      if (zone) {
        return zone['abbr'];
      } else {
        return null;
      }
    },
<span id='Tent-Date-method-getFullTZFromUTCOffsetAndAbbreviation'>    /**
</span>    * @method getFullTZFromUTCOffsetAndAbbreviation Returns timezone name, returns null if UTC Offset is missing
    * @param {String} UTCOffset string of type : &quot;GMT+0400&quot; (Required)
    * @param {String} abbr Timezone abbreviation of type: &quot;IST&quot; (Optional)
    * @return {string}
    */

    getFullTZFromUTCOffsetAndAbbreviation: function(UTCOffset, abbr) {
      var zone, zones;
      if (abbr == null) {
        abbr = null;
      }
      if (UTCOffset == null) {
        return null;
      }
      zones = getZonesFromUTCOffset(UTCOffset);
      if (zones.length) {
        zone = (zones.length === 1 ? zones[0] : filterZoneUsingTZAbbreviation(zones, abbr));
      }
      if (zone) {
        return zone['name'];
      } else {
        return null;
      }
    },
<span id='Tent-Date-method-getAbbreviatedTZFromDate'>    /**
</span>    * @method getAbbreviatedTZFromDate Returns timezone abbreviation, returns null if date is missing
    * @param {Date Object} date (Required)
    * @return {string}
    */

    getAbbreviatedTZFromDate: function(date) {
      /* 
        Possible Dates:
        Mon Apr 01 2013 14:55:15 GMT+0530 (IST) - with TZ abbreviations &amp; GMT
        Mon Apr 01 2013 14:55:15 GMT+0530 (India Standard Time) - with TZ fullform &amp; GMT(Windows)
        Mon Apr 1 15:19:25 UTC+0530 2013 - In IE, if data doesn't exist for client's tz, it shows date in this format 
        Fri Apr 5 06:31:52 EDT 2013 - In IE, if there exists data for client's tz, it shows date in this format
      */

      var dateString, hours, match, min, offset, tz, tzOffset;
      if (date == null) {
        return null;
      }
      tzOffset = date.getTimezoneOffset();
      hours = Math.floor(Math.abs(tzOffset / 60));
      min = Math.abs(tzOffset % 60);
      if (min &lt; 10) {
        min = &quot;0&quot; + min;
      }
      if (hours &lt; 10) {
        hours = &quot;0&quot; + hours;
      }
      if (tzOffset &lt; 0) {
        offset = &quot;GMT+&quot; + hours + min;
      } else {
        offset = &quot;GMT-&quot; + hours + min;
      }
      dateString = date.toLongDateString();
      if (Tent.Browsers.isIE()) {
        match = /[A-Z]{3}/.exec(dateString);
      } else {
        match = /\((.+)\)/.exec(dateString);
      }
      if (match != null) {
        tz = match[0].replace(/[()]/g, &quot;&quot;);
      } else {
        tz = null;
      }
      if ((tz != null) &amp;&amp; tz.split(&quot; &quot;).length === 1) {
        return tz;
      }
      return Tent.Date.getAbbreviatedTZFromUTCOffsetAndName(offset, tz);
    },
<span id='Tent-Date-method-getFullTZFromDate'>    /** 
</span>    * @method getFullTZFromDate Returns timezone name, returns null if date is missing
    * @param {Date Object} date (Required)
    * @return {String}
    */

    getFullTZFromDate: function(date) {
      var dateString, tz;
      if (date == null) {
        return null;
      }
      dateString = date.toLongDateString();
      tz = dateString.substring(35, dateString.length - 1);
      if (tz.split(&quot; &quot;).length !== 1) {
        return tz;
      } else {
        return Tent.Date.getFullTZFromUTCOffsetAndAbbreviation(dateString.substring(25, 33), tz);
      }
    },
<span id='Tent-Date-method-getUTCOffsetFromTZ'>    /**
</span>    * @method getUTCOffsetFromTZ Returns UTCOffset given the timezone abbreviation and name. 
    * If name is not provided and there are more than one records with the given abbreviation,
    * null will be returned
    * @param {String} abbr (Required)
    * @param {String} name (Optional)
    * @return {String}
    */

    getUTCOffsetFromTZ: function(abbr, name) {
      var zone, zones;
      if (abbr == null) {
        return null;
      }
      zones = getZonesFromAbbreviation(abbr);
      zone = (zones.length === 1 ? zones[0] : (name != null ? filterZoneUsingTZName(zones, name) : null));
      if (zone) {
        return zone['UTCOffset'];
      } else {
        return null;
      }
    }
  });

<span id='Tent-Date-method-filterZoneUsingTZAbbreviation'>  /**
</span>  * @method filterZoneUsingTZAbbreviation (PRIVATE) Returns a zone object from an array of zone objects 
   if the given abbreviation matches any of the object abbreviations
   returns null if a list of 'zone' objects or abbreviation is not provided
  * @param {Array of Zone Objects} zones
  * @param {String} abbr
  * @return {Object} Zone object
  */


  filterZoneUsingTZAbbreviation = function(zones, abbr) {
    var zone;
    if (!((zones != null) || zones.length &gt; 0)) {
      return null;
    }
    if (abbr == null) {
      return zones[0];
    }
    zone = zones.find(function(item) {
      return item.abbr === abbr;
    });
    return zone;
  };

<span id='Tent-Date-method-filterZoneUsingTZName'>  /**
</span>  * @method filterZoneUsingTZName (PRIVATE) Returns an zone object from an array of zone objects
    if the given name exactly or almost matches any of the object names 
    (has the scope of &quot;almost matching strings&quot; as the name may not exactly match the ones in the Tent list)
    returns null if the list of 'zone' objects or name is not provided
  * @param {Array of Zone Objects} zones
  * @param {String} name
  * @return {Object} Zone object
  */


  filterZoneUsingTZName = function(zones, name) {
    var indices, min, zone;
    if (!((zones != null) || zones.length &gt; 0)) {
      return null;
    }
    if (name == null) {
      return zones[0];
    }
    zone = zones.find(function(item) {
      return item.name === name;
    });
    if (!zone) {
      zones.forEach(function(item) {
        var i, str;
        str = item.name;
        i = 0;
        while (str[i] === name[i] &amp;&amp; i &lt; str.length &amp;&amp; i &lt; name.length) {
          i += 1;
        }
        return item.index = i;
      });
      indices = zones.mapProperty('index');
      min = Math.max.apply(Math, indices);
      zone = (min === 0 ? null : zones[indices.indexOf(min)]);
      return zone;
    }
  };

<span id='Tent-Date-method-getZonesFromUTCOffset'>  /**
</span>  * @method getZonesFromUTCOffset (PRIVATE) Returns an array list of zone objects which have the given UTCOffset
  * @param {String} UTCOffset 
  * @return {Object} Zone object
  */


  getZonesFromUTCOffset = function(UTCOffset) {
    return Tent.TIMEZONES.filter(function(item) {
      return item[&quot;UTCOffset&quot;] === UTCOffset;
    });
  };

<span id='Tent-Date-method-getZonesFromAbbreviation'>  /** 
</span>  * @method getZonesFromAbbreviation (PRIVATE) Returns an array list of zone objects which have the given abbreviation
  * @param {String} abbr
  * @return {Object} Zone object
  */


  getZonesFromAbbreviation = function(abbr) {
    return Tent.TIMEZONES.filter(function(item) {
      return item[&quot;abbr&quot;] === abbr;
    });
  };

}).call(this);


(function() {
}).call(this);



<span id='Tent-SpanSupport'>/**
</span> * @class Tent.SpanSupport  
 * Some docs here...
*/


(function() {

  Tent.SpanSupport = Ember.Mixin.create({
<span id='Tent-SpanSupport-property-span'>    /**
</span>    * @property {Number} span The horizontal span which should be allocated to this widget
    */

<span id='Tent-SpanSupport-property-vspan'>    /**
</span>    * @property {Number} vspan The vertical span which should be allocated to this widget
    */

    estimateSpan: function() {
      var currentView, span;
      currentView = this;
      while (currentView) {
        span = Number(currentView.get('span'));
        if (!((span === 0) || isNaN(span))) {
          return span;
        }
        currentView = currentView.get('parentView');
      }
      return 12;
    },
    spanClass: (function() {
      if (this.get('span')) {
        return 'span' + this.get('span');
      }
    }).property('span'),
    vspanClass: (function() {
      if (this.get('vspan')) {
        return 'vspan' + this.get('vspan');
      }
    }).property('vspan')
  });

}).call(this);



<span id='Tent-VisibilitySupport'>/**
</span> * @class Tent.VisibilitySupport
 * Some docs here...
*/


(function() {

  Tent.VisibilitySupport = Ember.Mixin.create({
    isVisible: true,
    _widgetShowing: true,
    isVisibleAsBoolean: Tent.computed.boolCoerceGently('isVisible'),
    isHidden: Ember.computed.not('isVisibleAsBoolean'),
    observesVisibility: (function() {
      if (this.get('isVisibleAsBoolean')) {
        if (!this.get('_widgetShowing')) {
          this.$().show();
        }
        return this.set('_widgetShowing', true);
      } else {
        if (this.get('_widgetShowing')) {
          this.$().hide();
        }
        return this.set('_widgetShowing', false);
      }
    }).observes('isVisible')
  });

}).call(this);



<span id='Tent-ValidationSupport'>/**
</span> * @class Tent.ValidationSupport
 * Some docs here...
*/


(function() {

  Tent.ValidationSupport = Ember.Mixin.create({
<span id='Tent-ValidationSupport-property-validations'>    /**
</span>    * @property {String }validations A list of comma-separated custom validations which should be applied to the widget
    */

    validations: null,
    isValid: true,
    validationErrors: [],
    validationWarnings: [],
    processWarnings: true,
<span id='Tent-ValidationSupport-property-warnings'>    /**
</span>    * @property {String} warnings A list of comma-separated custom validations which should be applied to the widget, but are interpreted
    * as warnings which may be ignored.
    */

    warnings: null,
    init: function() {
      return this._super();
    },
    willDestroyElement: function() {
      this._super();
      return this.flushValidationErrors();
    },
    validate: function() {
      var valid;
      this.flushValidationErrors();
      this.flushValidationWarnings();
      valid = this.executeCustomValidations();
      this.set('isValid', valid);
      return valid;
    },
    validateWarnings: function() {
      this.flushValidationWarnings();
      if (this.get('processWarnings')) {
        return this.executeCustomWarnings();
      }
    },
    executeCustomValidations: function() {
      var isValid, options, vName, valid, validator, _i, _len, _ref;
      valid = true;
      if ((this.get('validations') != null) &amp;&amp; this.get('validations') !== &quot;&quot;) {
        _ref = this.get('validations').split(',');
        for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
          vName = _ref[_i];
          isValid = true;
          validator = Tent.Validations.get(vName.trim());
          if (!(validator != null)) {
            throw new Error('Validator [' + vName + '] cannot be found');
          }
          options = this.parseCustomValidationOptions(vName);
          isValid = isValid &amp;&amp; validator.validate(this.get('formattedValue'), options, null, this);
          if (!isValid) {
            this.addValidationError(validator.getErrorMessage(this.get('formattedValue'), options));
            valid = isValid;
          }
        }
      }
      return valid;
    },
    executeCustomWarnings: function() {
      var isValid, options, valid, validator, wName, _i, _len, _ref;
      valid = true;
      if ((this.get('warnings') != null) &amp;&amp; this.get('warnings') !== &quot;&quot;) {
        _ref = this.get('warnings').split(',');
        for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
          wName = _ref[_i];
          isValid = true;
          validator = Tent.Validations.get(wName.trim());
          if (!(validator != null)) {
            throw new Error('Validator [' + wName + '] cannot be found');
          }
          options = this.parseCustomValidationOptions(wName);
          isValid = isValid &amp;&amp; validator.validate(this.get('formattedValue'), options, null, this);
          if (!isValid) {
            this.addValidationWarning(validator.getErrorMessage(this.get('formattedValue'), options));
            valid = isValid;
          }
        }
      }
      return valid;
    },
    parseCustomValidationOptions: function(vName) {
      if (this.get('validationOptions') != null) {
        if (typeof this.get('validationOptions') === 'string') {
          return eval(&quot;(&quot; + this.get('validationOptions') + &quot;)&quot;)[vName];
        } else {
          return this.get('validationOptions')[vName];
        }
      }
      return null;
    },
    errorsDidChange: (function() {
      return this.updateErrorPanel();
    }).observes('validationErrors.@each'),
    warningsDidChange: (function() {
      return this.updateWarningPanel();
    }).observes('validationWarnings.@each'),
    updateErrorPanel: function() {
      var message;
      message = Tent.Message.create({
        messages: $.merge([], this.get('validationErrors')),
        type: Tent.Message.ERROR_TYPE,
        sourceId: this.get('elementId'),
        label: this.get('label')
      });
      return $.publish(&quot;/message&quot;, [message]);
    },
    updateWarningPanel: function() {
      var message;
      message = Tent.Message.create({
        messages: $.merge([], this.get('validationWarnings')),
        type: Tent.Message.WARNING_TYPE,
        sourceId: this.get('elementId'),
        label: this.get('label'),
        severity: this.get('warningseverity')
      });
      return $.publish(&quot;/message&quot;, [message]);
    },
    hasErrors: (function() {
      return !this.get('isValid');
    }).property('isValid'),
    hasWarnings: (function() {
      return this.get('validationWarnings').length &gt; 0;
    }).property('validationWarnings', 'validationWarnings.@each'),
    observesErrors: (function() {
      var classNames;
      classNames = this.get('classNames');
      if (classNames != null) {
        if (this.get('hasErrors')) {
          if (!classNames.contains('error')) {
            return classNames[classNames.length] = 'error';
          }
        } else {
          return classNames.removeObject('error');
        }
      }
    }).observes('hasErrors'),
    observesWarnings: (function() {
      var classNames;
      classNames = this.get('classNames');
      if (classNames != null) {
        if (this.get('hasWarnings')) {
          if (this.$('') != null) {
            this.$('').addClass('warning');
          }
          if (!classNames.contains('warning')) {
            return classNames[classNames.length] = 'warning';
          }
        } else {
          if (this.$('') != null) {
            this.$('').removeClass('warning');
          }
          return classNames.removeObject('warning');
        }
      }
    }).observes('validationWarnings', 'validationWarnings.@each'),
    flushValidationErrors: function() {
      this.set('validationErrors', []);
      return this.set('isValid', true);
    },
    flushValidationWarnings: function() {
      return this.set('validationWarnings', []);
    },
    addValidationError: function(error) {
      if (typeof error === &quot;string&quot;) {
        error = Tent.I18n.loc(error);
      }
      this.get('validationErrors').pushObject(error);
      return this.set('isValid', false);
    },
    addValidationWarning: function(warning) {
      if (typeof warning === &quot;string&quot;) {
        warning = Tent.I18n.loc(warning);
      }
      return this.get('validationWarnings').pushObject(warning);
    }
  });

}).call(this);



<span id='Tent-MandatorySupport'>/**
</span> * @class Tent.MandatorySupport
 * Some docs here...
*/


(function() {
Tent.MandatorySupport = Ember.Mixin.create({
<span id='Tent-MandatorySupport-property-required'>    /**
</span>    	* @property {Boolean} required Boolean property to determine whether a value must be provided
    */

    required: false,
    requiredAsBoolean: Tent.computed.boolCoerceGently('required'),
    validate: function() {
      var isRequired, isValid, value;
      isValid = this._super();
      value = this.get('valueForMandatoryValidation');
      isRequired = (!this.get('required') &amp;&amp; !this.get('isMandatory')) || (!this.isValueEmpty(value));
      if (!isRequired) {
        this.addValidationError(Tent.messages.REQUIRED_ERROR);
      }
      return isValid &amp;&amp; isRequired;
    },
    isValueEmpty: function(value) {
      return !((value != null) &amp;&amp; value !== '' &amp;&amp; (value.length != null ? value.length &gt; 0 : true));
    }
  });

}).call(this);



<span id='Tent-SerializerSupport'>/**
</span>* @class Tent.SerializerSupport.
*
* The host applications Model may apply serialization transforms on this field type. Where   
* this field is not bound to a model, SerializerSupport can apply those transforms explicitly.
* Set the {@link #serializer} property to and object that implements the {@link #from} and 
* {@link #to} methods.
*
*/


(function() {

  Tent.SerializerSupport = Ember.Mixin.create({
    serializer: null,
    deserialize: function(serialized) {
      if (this.get('serializer')) {
        return this.get('serializer').deserialize(serialized);
      } else {
        return serialized;
      }
    },
    serialize: function(deserialized) {
      if (this.get('serializer')) {
        return this.get('serializer').serialize(deserialized);
      } else {
        return deserialized;
      }
    },
    serializedValue: (function(key, value) {
      if (arguments.length === 1) {
        return this.serialize(this.get('value'));
      } else {
        return this.set('value', this.deserialize(value));
      }
    }).property('value')
  });

}).call(this);



<span id='Tent-FieldSupport'>/**
</span>* @class Tent.FieldSupport
* @mixins Tent.SpanSupport
* @mixins Tent.ValidationSupport
* @mixins Tent.VisibilitySupport
* @mixins Tent.MandatorySupport
* 
* This mixin provides all of the basic properties and behaviors for a form field view
*/


(function() {
Tent.FieldSupport = Ember.Mixin.create(Tent.SpanSupport, Tent.ValidationSupport, Tent.VisibilitySupport, Tent.MandatorySupport, {
<span id='Tent-FieldSupport-property-textDisplay'>    /**
</span>    * @property {Boolean} [textDisplay=false]
    * When set to true, the formatted value of the widget will be displayed, 
    * rather than the widget itself.
    */

    textDisplay: false,
<span id='Tent-FieldSupport-property-label'>    /**
</span>    * @property {String} label The label for the field.
    */

    label: &quot;&quot;,
<span id='Tent-FieldSupport-property-value'>    /**
</span>    * @property {String} value The current value of the field.
    */

    value: null,
<span id='Tent-FieldSupport-property-formattedValue'>    /**
</span>    * @property {String} formattedValue The current value of the field in its formatted form.
    */

    formattedValue: null,
<span id='Tent-FieldSupport-property-serializedValue'>    /**
</span>    * @property serializedValue If a {@link serializer} has been defined, this will contain the serialized
    * value. If this value is set, a deserialized version of it will be set on the 'value' property
    */

    serializedValue: null,
<span id='Tent-FieldSupport-property-readOnly'>    /**
</span>      * @property {String} [readOnly=false] A boolean indicating that the field is read-only.
      * Although this allows the user to interact with the field (highlight, copy etc), they are not able to change
      * its value.
    */

    readOnly: false,
<span id='Tent-FieldSupport-property-disabled'>    /**
</span>      * @property {String} [disabled=false] A boolean indicating that the field is disabled.
      * When disabled, the user is prevented from interacting with the field. In addition, if the field 
      * is tied to a form, its value will not be included in the form submission
    */

    disabled: false,
<span id='Tent-FieldSupport-property-placeholder'>    /**
</span>      * @property {String} placeholder A block of descriptive text to display in the field, usually hint as to the expected content.
      * The placeholder will not be recognised as a value, and will be hidden when text is entered into the field.
    */

    placeholder: null,
<span id='Tent-FieldSupport-property-helpBlock'>    /**
</span>    * @property {String} helpBlock A block of text which provides additional help for completing the field
    */

    helpBlock: null,
    fieldClass: 'field',
    mixinClasses: 'control-group',
    classNames: ['tent-widget'],
    classNameBindings: ['mixinClasses', 'requiredAsBoolean:required', 'isHidden:hidden', 'isViewOnly:view-only', 'hasErrors:error', 'spanClass'],
<span id='Tent-FieldSupport-property-isEditable'>    /**
</span>    * @property {Boolean} [isEditable=true] A boolean value indicating whether the field is editable
    */

    isEditable: true,
    isEditableAsBoolean: Tent.computed.boolCoerceGently('isEditable'),
    isViewOnly: Ember.computed.not('isEditableAsBoolean'),
<span id='Tent-FieldSupport-property-hasPrefix'>    /**
</span>    * @property {Boolean} [hasPrefix=false] A boolean indicating whether a prefix should be displayed before the value
    */

    hasPrefix: false,
<span id='Tent-FieldSupport-property-prefix'>    /**
</span>    * @property {String} prefix A string value to display as the prefix
    */

    prefix: null,
    translatedPlaceholder: (function() {
      return Tent.I18n.loc(this.get('placeholder'));
    }).property('placeholder'),
    isTextDisplay: (function() {
      return this.get('textDisplay') || (!this.get('isEditable'));
    }).property('textDisplay', 'isEditable'),
    forId: (function() {
      return this.get('inputIdentifier');
    }).property('inputIdentifier'),
    errorId: (function() {
      return this.get('elementId') + &quot;_error&quot;;
    }).property('elementId'),
    helpId: (function() {
      return this.get('elementId') + &quot;_help&quot;;
    }).property('elementId'),
    inputSizeClass: (function() {
      return 'input-medium';
    }).property(),
    widthExpectation: (function() {
      var fieldSize, formStyle;
      formStyle = this.get('form.formStyle');
      fieldSize = Tent.FieldSupport.SIZE_MAP[this.get('inputSizeClass')];
      if (formStyle === 'horizontal') {
        return fieldSize + 150;
      } else {
        return Math.max(fieldSize, 150);
      }
    }).property('form'),
    form: (function() {
      if (this.$() != null) {
        return Ember.View.views[this.$().closest('form').attr('id')];
      }
    }).property(),
    enableWarningProcessing: (function() {
      return this.set('processWarnings', true);
    }).observes('value'),
    focus: function() {
      return $('#' + this.get('inputIdentifier')).focus();
    },
    resize: function() {
      this._super();
      return this.estimateFormStyle();
    },
    clear: function() {
      return this.set('value', null);
    },
    didInsertElement: function() {
      this._super();
      return this.estimateFormStyle();
    },
    estimateFormStyle: function() {},
    unEditableClass: (function() {
      if (!this.get('isEditable')) {
        return 'uneditable-input';
      }
    }).property('isEditable')
  });

  Tent.FieldSupport.SIZE_CLASSES = ['input-mini', 'input-small', 'input-mini', 'input-medium', 'input-large', 'input-xlarge', 'input-xlarge', 'input-xlarge', 'input-xxlarge', 'input-xxlarge', 'input-xxlarge', 'input-xxlarge'];

  Tent.FieldSupport.SIZE_MAP = {
    'input-mini': 60,
    'input-small': 90,
    'input-medium': 150,
    'input-large': 210,
    'input-xlarge': 270,
    'input-xxlarge': 530
  };

}).call(this);



<span id='Tent-FormattingSupport'>/**
</span> * @class Tent.FormattingSupport 
 * Allows the 'value' property of the view to be bound to a controller while
 * displaying the 'formattedValue' in the DOM
 * The format() and unFormat() methods, which should be overridedn by your view class, 
 * define the data transformation between the value and formatted value
 * Note that all validation will be executed against the 'value' property
*/


(function() {

  Tent.FormattingSupport = Ember.Mixin.create({
    init: function() {
      this._super();
      return this.set('formattedValue', this.format(this.get('value')));
    },
    valueDidChange: (function() {
      this.set(&quot;formattedValue&quot;, this.format(this.get('value')));
      return this.set('isValid', this.validate());
    }).observes('value'),
    format: function(value) {
      if (value) {
        return value.trim();
      }
    },
    unFormat: function(value) {
      return value;
    }
  });

}).call(this);



<span id='Tent-TooltipSupport'>/**
</span> * @class Tent.TooltipSupport
 * Some docs here...
*/


(function() {

  Tent.TooltipSupport = Ember.Mixin.create({
<span id='Tent-TooltipSupport-property-tooltip'>    /**
</span>    	* @property {String} tooltip A detailed information message presented as a hover-icon beside the field
    */

    tooltip: null,
    didInsertElement: function() {
      this._super();
      return this.$(&quot;a[rel=tooltip]&quot;).tooltip();
    },
    tooltipT: (function() {
      return Tent.I18n.loc(this.get('tooltip'));
    }).property('tooltip')
  });

}).call(this);


(function() {

  Tent.Constants = Ember.Object.create({
    OPERATOR_BEGINS_WITH: &quot;begin&quot;,
    OPERATOR_CONTAINS: &quot;contain&quot;,
    OPERATOR_LIKE: &quot;like&quot;,
    OPERATOR_EQUALS: &quot;eql&quot;,
    OPERATOR_NOT_EQUALS: &quot;not&quot;,
    OPERATOR_LESS_THAN: &quot;lt&quot;,
    OPERATOR_GREATER_THAN: &quot;gt&quot;,
    OPERATOR_LESS_THAN_EQUALS: &quot;lte&quot;,
    OPERATOR_GREATER_THAN_EQUALS: &quot;gte&quot;,
    OPERATOR_RANGE: &quot;range&quot;
  });

}).call(this);


(function() {
<span id='Tent-FilteringSupport'>/**
</span>  * @class Tent.FilteringSupport 
  * Allows widgets to participate in filter panels, and provides them with a range of 
  * comparison operators
  */


  Tent.FilteringSupport = Ember.Mixin.create({
    isFilter: false,
    operators: [
      Ember.Object.create({
        label: &quot;tent.filter.beginsWith&quot;,
        operator: Tent.Constants.get('OPERATOR_BEGINS_WITH')
      }), Ember.Object.create({
        label: &quot;tent.filter.contains&quot;,
        operator: Tent.Constants.get('OPERATOR_CONTAINS')
      }), Ember.Object.create({
        label: &quot;tent.filter.equal&quot;,
        operator: Tent.Constants.get('OPERATOR_EQUALS')
      }), Ember.Object.create({
        label: &quot;tent.filter.nEqual&quot;,
        operator: Tent.Constants.get('OPERATOR_NOT_EQUALS')
      }), Ember.Object.create({
        label: &quot;tent.filter.like&quot;,
        operator: Tent.Constants.get('OPERATOR_LIKE')
      })
    ],
    init: function() {
      return this._super(arguments);
    },
    didInsertElement: function() {
      return this._super();
    },
    isRangeOperator: (function() {
      var currentFilterOperator;
      currentFilterOperator = this.get('filterOp');
      return currentFilterOperator === 'range';
    }).property('filterOp')
  });

}).call(this);



<span id='Tent-AriaSupport'>/**
</span> * @class Tent.AriaSupport
 * Some docs here...
*/


(function() {

  Tent.AriaSupport = Ember.Mixin.create({
    attributeBindings: ['ariaRequired:aria-required', 'ariaReadOnly:aria-readonly', 'ariaDisabled:aria-disabled', 'ariaDescribedBy:aria-describedby', 'ariaInvalid:aria-invalid'],
    ariaRequired: (function() {
      if (this.get('parentView.required')) {
        return 'true';
      } else {
        return 'false';
      }
    }).property('parentView.required'),
    ariaReadOnly: (function() {
      if (this.get('parentView.readOnly')) {
        return 'true';
      } else {
        return 'false';
      }
    }).property('parentView.readOnly'),
    ariaDisabled: (function() {
      if (this.get('parentView.disabled')) {
        return 'true';
      } else {
        return 'false';
      }
    }).property('parentView.disabled'),
    ariaDescribedBy: (function() {
      return this.get('parentView.errorId') + &quot; &quot; + this.get('parentView.helpId');
    }).property('parentView.errorId'),
    ariaInvalid: (function() {
      if (this.get('parentView.hasErrors')) {
        return 'true';
      } else {
        return 'false';
      }
    }).property('parentView.hasErrors')
  });

}).call(this);



<span id='Tent-ReadonlySupport'>/**
</span> * @class Tent.ReadonlySupport
 * Some docs here...
*/


(function() {

  Tent.ReadonlySupport = Ember.Mixin.create({
    attributeBindings: ['readOnly:readonly'],
    readOnly: (function() {
      if (this.get('parentView.readOnly') || this.get('parentView.isReadOnly')) {
        return true;
      } else {
        return false;
      }
    }).property('parentView.readOnly', 'parentView.isReadOnly')
  });

}).call(this);



<span id='Tent-DisabledSupport'>/**
</span> * @class Tent.DisabledSupport
 * Some docs here...
*/


(function() {

  Tent.DisabledSupport = Ember.Mixin.create({
    attributeBindings: ['disabled'],
    disabledBinding: 'parentView.disabled'
  });

}).call(this);



<span id='Tent-Html5Support'>/**
</span> * @class Tent.Html5Support
 * Some docs here...
*/


(function() {

  Tent.Html5Support = Ember.Mixin.create({
    attributeBindings: ['required'],
    required: (function() {
      return this.get('parentView.required');
    }).property('parentView.required')
  });

}).call(this);


Ember.TEMPLATES['text_field']=Ember.Handlebars.compile(&quot;&lt;label class=\&quot;control-label\&quot; {{bindAttr for=\&quot;view.forId\&quot;}}&gt;{{loc view.label}}\n  &lt;span class='tent-required'&gt;&lt;/span&gt;\n&lt;/label&gt;\n&lt;div class=\&quot;controls\&quot;&gt;\n  {{#if view.isFilter}}\n    {{#if view.operators}}\n      {{view Tent.Select listBinding=\&quot;view.operators\&quot; class=\&quot;embed no-label operators\&quot; \n        optionLabelPath=\&quot;content.label\&quot;\n        optionValuePath=\&quot;content.operator\&quot;\n        valueBinding=\&quot;view.filterOp\&quot;\n      }}\n    {{/if}}\n  {{/if}}\n  &lt;div class=\&quot;input-prepend\&quot;&gt;\n    {{#if view.isTextDisplay}}\n      &lt;span class=\&quot;text-display\&quot;&gt;{{#if view.hasPrefix}}&lt;span class=\&quot;prefix\&quot;&gt;{{loc view.prefix}}&lt;/span&gt;{{/if}}{{view.formattedValue}}&lt;/span&gt;\n    {{else}}\n      {{#if view.hasPrefix}}  \n        &lt;span class=\&quot;add-on\&quot;&gt;{{view.prefix}}&lt;/span&gt;\n      {{/if}} \n      {{view Tent.TextFieldInput \n        valueBinding=\&quot;view.formattedValue\&quot; \n        placeholderBinding=\&quot;view.translatedPlaceholder\&quot;\n        classBinding=\&quot;view.controlClass\&quot;\n        typeBinding=\&quot;view.type\&quot;\n      }}\n\n      {{#if view.isRangeOperator}}\n        {{view Tent.TextFieldInput \n          valueBinding=\&quot;view.value2\&quot; \n          placeholderBinding=\&quot;view.translatedPlaceholder\&quot;\n          classBinding=\&quot;view.controlClass\&quot;\n          classNames=\&quot;range-end\&quot;\n          typeBinding=\&quot;view.type\&quot;\n        }}\n      {{/if}}\n\n      {{#if view.hasHelpBlock}}\n        &lt;span class=\&quot;help-block\&quot; {{bindAttr id=\&quot;view.helpId\&quot;}}&gt;{{loc view.helpBlock}}&lt;/span&gt;\n      {{/if}}\n    {{/if}}\n    {{#if view.hasErrors}}\n      &lt;ul class=\&quot;help-inline\&quot; {{bindAttr id=\&quot;view.errorId\&quot;}}&gt;{{#each error in view.validationErrors}}&lt;li&gt;{{loc error}}&lt;/li&gt;{{/each}}&lt;/ul&gt;\n    {{/if}}  \n    {{#if view.hasWarnings}}\n      &lt;ul class=\&quot;help-inline warning\&quot; {{bindAttr id=\&quot;view.warningId\&quot;}}&gt;{{#each warning in view.validationWarnings}}&lt;li&gt;{{loc warning}}&lt;/li&gt;{{/each}}&lt;/ul&gt;\n    {{/if}}  \n\n  &lt;/div&gt;\n  {{#if view.tooltip}}\n    &lt;a href=\&quot;#\&quot; rel=\&quot;tooltip\&quot; data-placement=\&quot;right\&quot; {{bindAttr data-original-title=\&quot;view.tooltipT\&quot;}}&gt;&lt;/a&gt;\n  {{/if}}\n\n&lt;/div&gt;\n&quot;);


<span id='Tent-TextField'>/**
</span> * @class Tent.TextField
 * @mixins Tent.FormattingSupport
 * @mixins Tent.FieldSupport
 * @mixins Tent.TooltipSupport
 * Usage 
 *       {{view Tent.TextField 
          valueBinding=&quot;Pad.appName&quot; 
          label=&quot;Focused input&quot; 
          placeholder=&quot;Type here..&quot; 
          tooltip=&quot;Provide some information here&quot; 
         }}
 *
*/


(function() {
Tent.TextField = Ember.View.extend(Tent.FormattingSupport, Tent.FieldSupport, Tent.TooltipSupport, Tent.FilteringSupport, {
    templateName: 'text_field',
    classNames: ['tent-text-field', 'control-group'],
<span id='Tent-TextField-property-controlClass'>    /**
</span>    	* @property {String} controlClass Additional classes to be added to the input field (not added to the wrapping elements)
    */

    controlClass: '',
<span id='Tent-TextField-property-type'>    /**
</span>    	* @property {String} type The type of the input element ('text', 'password' etc)
    */

    type: 'text',
    didInsertElement: function() {
      this._super(arguments);
      return this.set('inputIdentifier', this.$('input').attr('id'));
    },
    valueForMandatoryValidation: (function() {
      return this.get('formattedValue');
    }).property('formattedValue'),
    change: function() {
      var unformatted;
      this._super(arguments);
      this.set('isValid', this.validate());
      if (this.get('isValid')) {
        unformatted = this.unFormat(this.get('formattedValue'));
        this.set('value', unformatted);
        this.set('formattedValue', this.format(unformatted));
        return this.validateWarnings();
      }
    }
  });

  Tent.TextFieldInput = Ember.TextField.extend(Tent.AriaSupport, Tent.Html5Support, Tent.ReadonlySupport, Tent.DisabledSupport);

}).call(this);



<span id='Tent-Tag'>/**
</span>* @class Tent.Tag
* A single tag item
* Usage
*      {{view Tent.Tag text=&quot;Important&quot;}}
*/


(function() {

  Tent.Tag = Ember.View.extend({
    tagName: 'span',
<span id='Tent-Tag-property-type'>    /**
</span>    * @property {String} [type=info] The type of tag to display
    */

    type: 'info',
    classNameBindings: ['labelClasses'],
    labelClasses: (function() {
      return 'label ' + 'label-' + this.get('type');
    }).property('type'),
    template: Ember.Handlebars.compile('{{view.text}}'),
    init: function() {
      var classNames, type;
      this._super();
      type = this.get('type');
      classNames = this.get('classNames');
      if (type) {
        return classNames.push('label-' + type);
      }
    }
  });

}).call(this);


(function() {
Tent.FilteringRangeSupport = Ember.Mixin.create(Tent.SerializerSupport, {
    operators: [
      Ember.Object.create({
        label: &quot;tent.filter.equal&quot;,
        operator: Tent.Constants.get('OPERATOR_EQUALS')
      }), Ember.Object.create({
        label: &quot;tent.filter.nEqual&quot;,
        operator: Tent.Constants.get('OPERATOR_NOT_EQUALS')
      }), Ember.Object.create({
        label: &quot;tent.filter.lThan&quot;,
        operator: Tent.Constants.get('OPERATOR_LESS_THAN')
      }), Ember.Object.create({
        label: &quot;tent.filter.lThanEq&quot;,
        operator: Tent.Constants.get('OPERATOR_LESS_THAN_EQUALS')
      }), Ember.Object.create({
        label: &quot;tent.filter.gThan&quot;,
        operator: Tent.Constants.get('OPERATOR_GREATER_THAN')
      }), Ember.Object.create({
        label: &quot;tent.filter.gThanEq&quot;,
        operator: Tent.Constants.get('OPERATOR_GREATER_THAN_EQUALS')
      }), Ember.Object.create({
        label: &quot;tent.filter.like&quot;,
        operator: Tent.Constants.get('OPERATOR_LIKE')
      }), Ember.Object.create({
        label: &quot;tent.filter.contains&quot;,
        operator: Tent.Constants.get('OPERATOR_CONTAINS')
      }), Ember.Object.create({
        label: &quot;tent.filter.range&quot;,
        operator: Tent.Constants.get('OPERATOR_RANGE')
      })
    ],
<span id='Tent-Tag-property-rangeValue'>    /**
</span>    * @property {Array} rangeValue The value containing the range array if a range operator is selected while filtering
    * If no range operator is selected, this property will just return the normal value.
    *
    */

    rangeValue: (function(key, value) {
      var strVal, value2, _ref, _ref1;
      if (arguments.length === 1) {
        if (this.get('isRangeOperator') &amp;&amp; (this.get('value2') != null)) {
          value = this.serialize((_ref = this.get('value')) != null ? _ref.toString().replace(/,/, '') : void 0);
          value2 = this.serialize((_ref1 = this.get('value2')) != null ? _ref1.toString().replace(/,/, '') : void 0);
          return &quot;&quot; + value + &quot;,&quot; + value2;
        } else {
          return this.serialize(this.get('value'));
        }
      } else {
        if (value != null) {
          strVal = &quot;&quot; + value;
          if (strVal.search(/,/) &gt; 0) {
            this.set('value', this.deserialize(parseInt(strVal.split(',')[0])));
            return this.set('value2', this.deserialize(parseInt(strVal.split(',')[1])));
          } else {
            return this.set('value', this.deserialize(value));
          }
        }
      }
    }).property('value', 'value2', 'isRangeOperator')
  });

}).call(this);



<span id='Tent-NumericTextField'>/**
</span>* @class Tent.NumericTextField
* @extends Tent.TextField
* Usage
*       {{view Tent.NumericTextField label=&quot;&quot; 
			valueBinding=&quot;&quot; 
			dateFormat=&quot;&quot;
         }}
*/


(function() {
Tent.NumericTextField = Tent.TextField.extend(Tent.FilteringRangeSupport, Tent.SerializerSupport, {
<span id='Tent-NumericTextField-property-serializer'>    /**
</span>    	* @property serializer An object which implements serialize() and deserialize(). It will be applied
    	* to the value and available on the {@link serializedValue} property
    */

    serializer: null,
    validate: function() {
      var didOtherValidationPass, isValidNumber, value;
      didOtherValidationPass = this._super();
      value = this.get('formattedValue');
      isValidNumber = this.isValueEmpty(value) || Tent.Formatting.number.isValidNumber(value);
      if (!isValidNumber) {
        this.addValidationError(Tent.messages.NUMERIC_ERROR);
      }
      if (didOtherValidationPass &amp;&amp; isValidNumber) {
        this.validateWarnings();
      }
      return didOtherValidationPass &amp;&amp; isValidNumber;
    },
    validateWarnings: function() {
      return this._super();
    },
    isValueEmpty: function(value) {
      return !((value != null) &amp;&amp; value !== '');
    },
    format: function(value) {
      return Tent.Formatting.number.format(value);
    },
    unFormat: function(value) {
      return Tent.Formatting.number.unformat(value);
    }
  });

}).call(this);



<span id='Tent-CurrencySupport'>/**
</span> * @class Tent.CurrencySupport
 * To get the centesimal value of a currency use the property 'centesimalValue'
 * To get the ISO name of a currency use the property 'name'
*/


(function() {
Tent.CurrencySupport = Ember.Mixin.create({
    centesimalValue: (function() {
      if (this.get('currency')) {
        if (this.get('isValidCurrency')) {
          return Tent.CURRENCIES_ISO_4217[this.get('currency')].cent;
        }
      }
    }).property('currency'),
    name: (function() {
      if (this.get('currency')) {
        if (this.get('isValidCurrency')) {
          return Tent.CURRENCIES_ISO_4217[this.get('currency')].name;
        }
      }
    }).property('currency'),
    isValidCurrency: (function() {
      return Tent.CURRENCIES_ISO_4217[this.get('currency')] != null;
    }).property('currency')
  });

}).call(this);



<span id='Tent-AmountField'>/**
</span>* @class Tent.AmountField
* @extends Tent.TextField
* 
* ##Usage
*
*       {{view Tent.AmountField valueBinding=&quot;&quot; 
          label=&quot;&quot; 
          currency=&quot;&quot; 
          required=false
          readOnly=false
          disabled=false 
          textDisplayBinding=false
          tooltip=&quot;&quot;
        }}
*/


(function() {
Tent.AmountField = Tent.TextField.extend(Tent.CurrencySupport, Tent.FilteringRangeSupport, Tent.SerializerSupport, {
    hasPrefix: true,
    hasHelpBlock: false,
    placeholder: accounting.settings.number.pattern,
    validAmountExp: /^(\-|\+)?(\d+\,?\d+)*\.?\d+$/,
    validations: 'positive',
<span id='Tent-AmountField-property-serializer'>    /**
</span>    * @property serializer An object which implements serialize() and deserialize(). It will be applied
    * to the value and available on the {@link serializedValue} property
    */

    serializer: null,
    prefix: (function() {
      if (this.get('currency')) {
        return Tent.I18n.loc(this.get('currency'));
      } else {
        return '...';
      }
    }).property('currency'),
    validate: function() {
      var didOtherValidationPass, formattedValue, isValidCurrency;
      this.set('formattedValue', Tent.Formatting.amount.cleanup(this.get('formattedValue')));
      didOtherValidationPass = this._super();
      formattedValue = this.get('formattedValue');
      isValidCurrency = this.get('isValidCurrency');
      if (!isValidCurrency) {
        this.addValidationError(Tent.messages.CURRENCY_ERROR);
      }
      if (isValidCurrency &amp;&amp; didOtherValidationPass) {
        this.validateWarnings();
      }
      return isValidCurrency &amp;&amp; didOtherValidationPass;
    },
    validateWarnings: function() {
      return this._super();
    },
    format: function(value) {
      return Tent.Formatting.amount.format(value, this.get('centesimalValue'));
    },
    unFormat: function(value) {
      return Tent.Formatting.amount.unformat(value);
    },
    focusOut: function() {
      if (this.get('isValid')) {
        return this.set('formattedValue', this.format(this.get('formattedValue')));
      }
    },
    observeCurrencyForValidationAndFormatting: (function() {
      this.get('validationErrors').removeObject(Tent.I18n.loc(Tent.messages.CURRENCY_ERROR));
      if (this.get('isValidCurrency')) {
        if (!this.get('validationErrors').length) {
          this.set('isValid', true);
        }
        this.set('formattedValue', this.format(this.get('formattedValue')));
        return this.set('value', this.unFormat(this.get('formattedValue')));
      } else {
        return this.addValidationError(Tent.messages.CURRENCY_ERROR);
      }
    }).observes('currency'),
    inputSizeClass: (function() {
      return Tent.AmountField.SIZE_CLASSES[this.estimateSpan() - 1];
    }).property()
  });

  Tent.AmountField.SIZE_CLASSES = ['input-mini', 'input-mini', 'input-mini', 'input-small', 'input-medium', 'input-large', 'input-xlarge', 'input-xlarge', 'input-xlarge', 'input-xxlarge', 'input-xxlarge', 'input-xxlarge'];

}).call(this);


Ember.TEMPLATES['table']=Ember.Handlebars.compile(&quot;&lt;thead&gt;\n\t{{#if view.isEditable}}\n    {{#if view.multiselection}} \n      &lt;th&gt;\n        {{view Ember.Checkbox nameBinding=\&quot;view.elementId\&quot; checkedBinding=\&quot;view.allSelected\&quot;}}\n      &lt;/th&gt;\n    {{else}}\n      &lt;th&gt;&lt;/th&gt;\n    {{/if}} \n  {{/if}}\n\t{{collection contentBinding=\&quot;view.visibleHeaders\&quot; itemViewClass=\&quot;Tent.TableHeader\&quot;}}\n&lt;/thead&gt;\n{{collection contentBinding=\&quot;view.list\&quot; tagName=\&quot;tbody\&quot; itemViewClass=\&quot;Tent.TableRow\&quot;}}&quot;);

Ember.TEMPLATES['table_row']=Ember.Handlebars.compile(&quot;{{#if view.parentTable.isEditable}}\n  {{#if view.parentTable.multiselection}}\n    &lt;td class=\&quot;tent-width-small\&quot;&gt;\n      {{view Ember.Checkbox nameBinding=\&quot;view.parentTable.elementId\&quot; valueBinding=\&quot;{{view.elementId}}\&quot;}}\n    &lt;/td&gt;\n  {{else}}\n    &lt;td class=\&quot;tent-width-small\&quot;&gt;\n\t  &lt;input type='radio' {{bindAttr name=\&quot;view.parentTable.elementId\&quot; value=\&quot;{{view.elementId}}\&quot;}}&gt;\n    &lt;/td&gt;\n  {{/if}}\n{{/if}}\n{{collection contentBinding=\&quot;view.parentTable.visibleColumns\&quot; itemViewClass=\&quot;Tent.TableCell\&quot;}}\n\n&quot;);

(function() {
Tent.Table = Ember.View.extend({
    classNames: ['table', 'table-condensed'],
    classNameBindings: ['isBordered:table-bordered'],
    tagName: 'table',
    templateName: 'table',
    isBordered: true,
    _columnHeaders: (function() {
      if (this.get('headers') != null) {
        return this.get('headers').split(',');
      }
    }).property('headers'),
    visibleHeaders: (function() {
      return this.get('_columnHeaders');
    }).property('_columnHeaders'),
    _columns: (function() {
      if (this.get('columns') != null) {
        return this.get('columns').split(',');
      }
    }).property('columns'),
    visibleColumns: (function() {
      return this.get('_columns');
    }).property('_columns'),
    init: function() {
      this._super();
      if (this.get('multiselection') === void 0) {
        this.set('multiselection', false);
      }
      if (this.get('isEditable') === void 0) {
        this.set('isEditable', true);
      }
      if (!(this.get('_list') != null)) {
        return this.createListProxy();
      }
    },
    createListProxy: function() {
      this.set('_list', Tent.SelectableArrayProxy.create({
        content: this.get('list')
      }));
      return this.get('_list').set('isMultipleSelectionAllowed', this.get('multiselection') || this.get('context.multiselection'));
    },
    isRowSelected: function(row) {
      var rowContent, selElements;
      if ((selElements = this.get('_list').get('selected')) !== null) {
        rowContent = row.get('content');
        if (selElements.contains(rowContent)) {
          return true;
        }
        return selElements.some(function(element) {
          var elementId, rowId;
          if (element === rowContent) {
            return true;
          }
          elementId = Ember.get(element, 'id');
          rowId = Ember.get(rowContent, 'id');
          if ((elementId != null) &amp;&amp; (rowId != null)) {
            return elementId === rowId;
          }
          return false;
        });
      } else {
        return false;
      }
    },
    select: function(selection) {
      var element, prevSelection, _i, _j, _len, _len1, _results;
      if (selection &amp;&amp; selection instanceof Array) {
        prevSelection = this.get('_list.selected');
        if (prevSelection) {
          for (_i = 0, _len = prevSelection.length; _i &lt; _len; _i++) {
            element = prevSelection[_i];
            this.select(element);
          }
        }
        if (selection) {
          _results = [];
          for (_j = 0, _len1 = selection.length; _j &lt; _len1; _j++) {
            element = selection[_j];
            _results.push(this.select(element));
          }
          return _results;
        }
      } else {
        if (!(this.get('_list') != null)) {
          this.createListProxy();
        }
        return this.get('_list').set('selected', selection);
      }
    },
    selectAll: (function() {
      if (this.get('allSelected')) {
        return this.get('_list').selectAll();
      } else {
        return this.get('_list').clearSelection();
      }
    }).observes('allSelected'),
    updateContent: (function() {
      return this.get('_list').set('content', this.get('list'));
    }).observes('list'),
    selection: (function(key, value) {
      if (value !== void 0) {
        return this.select(value);
      } else {
        return this.get('_list.selected');
      }
    }).property('_list.selected')
  });

  Tent.TableRow = Ember.View.extend({
    tagName: 'tr',
    templateName: 'table_row',
    classNameBindings: ['isSelected:tent-selected'],
    parentTableBinding: 'parentView.parentView',
    didInsertElement: function() {
      if (this.get('parentTable').get('isEditable')) {
        return this.checkSelection();
      }
    },
    format: function(columnName, columnValue) {
      var formatter, formatterProvider, tableContent;
      if ((formatterProvider = this.get('parentTable.formatter')) != null) {
        tableContent = this.get('parentTable.list');
        formatter = formatterProvider(tableContent, columnName);
        if (formatter != null) {
          return formatter.format(columnValue);
        }
      }
      return columnValue;
    },
    cssClass: function(columnName) {
      var formatter, formatterProvider, tableContent;
      if ((formatterProvider = this.get('parentTable.formatter')) != null) {
        tableContent = this.get('parentTable.list');
        formatter = formatterProvider(tableContent, columnName);
        if ((formatter != null) &amp;&amp; (formatter.cssClass != null)) {
          return formatter.cssClass();
        }
      }
      return &quot;&quot;;
    },
    isSelected: (function() {
      return this.get('parentTable').isRowSelected(this);
    }).property('parentTable.selection'),
    checkSelection: (function() {
      if (this.get('isSelected')) {
        return this.$('input').prop('checked', true);
      } else {
        return this.$('input').prop('checked', false);
      }
    }).observes('isSelected'),
    mouseUp: function(event) {
      if (this.get('parentTable').get('isEditable')) {
        this.get('parentTable').select(this.get('content'));
      }
      return this.$(&quot;input&quot;).click(function(event) {
        if ($(this).prop('checked')) {
          $(this).prop('checked', false);
        }
        if (event.target === this) {
          return false;
        }
      });
    }
  });

  Tent.TableCell = Ember.View.extend({
    tagName: 'td',
    classNameBindings: ['isRadio:tent-width-small', 'cssClass'],
    defaultTemplate: Ember.Handlebars.compile('{{view.formattedColumnValue}}'),
    row: (function() {
      return this.get('parentView').get('parentView');
    }).property('parentView'),
    formattedColumnValue: (function() {
      var columnName, columnValue;
      columnName = this.get('content');
      columnValue = this.get('row.content.' + columnName);
      return this.get('row').format(columnName, columnValue);
    }).property('row', 'content'),
    cssClass: (function() {
      var columnName, row;
      columnName = this.get('content');
      row = this.get('row');
      return row.cssClass(columnName);
    }).property('row', 'content')
  });

  Tent.TableHeader = Ember.View.extend({
    tagName: 'th',
    defaultTemplate: Ember.Handlebars.compile('{{view.printableColumnName}}'),
    printableColumnName: (function() {
      var columnName;
      columnName = Tent.I18n.loc(this.get('content'));
      if (typeof columnName === 'string') {
        return columnName.camelToWords();
      }
    }).property('content')
  });

}).call(this);


Ember.TEMPLATES['jqgrid']=Ember.Handlebars.compile(&quot;{{#if view.content.isLoadable}}\n\t{{#unless view.content.isLoaded}}\n\t\t{{view Tent.WaitIcon}}\n  \t{{/unless}}\n{{/if}}\n\n&lt;div class=\&quot;jqgrid-backdrop\&quot; class=\&quot;\&quot;&gt;&lt;/div&gt;\n\n{{view Tent.JqGridHeaderView}}\n\n&lt;table class=\&quot;grid-table\&quot;&gt;&lt;/table&gt;\n&lt;div class=\&quot;gridpager\&quot;&gt;&lt;/div&gt;\n{{#if view.hasErrors}}\n\t&lt;span class=\&quot;help-inline\&quot; {{bindAttr id=\&quot;view.errorId\&quot;}}&gt;{{#each error in view.validationErrors}}{{loc error}}{{/each}}&lt;/span&gt;\n{{/if}}\n\n&quot;);

(function() {

  Tent.Grid = Ember.Namespace.create();

<span id='Tent-Grid-CollectionSupport'>  /**
</span>  * @class Tent.Grid.CollectionSupport
  * 
  * A mixin which allows the use of a collection to provide content and 
  * functionality for a grid
  *
  * The grid will bind to the following properties of the collection:
  *   
  * - columnsDescriptor: an array of descriptor objects defining the columns to be displayed
  *       e.g. [
          {id: &quot;id&quot;, name: &quot;id&quot;, title: &quot;_hID&quot;, field: &quot;id&quot;, sortable: true, hideable: false},
          {id: &quot;title&quot;, name: &quot;title&quot;, title: &quot;_hTitle&quot;, field: &quot;title&quot;, sortable: true},
          {id: &quot;amount&quot;, name: &quot;amount&quot;, title: &quot;_hAmount&quot;, field: &quot;amount&quot;, sortable: true, formatter: &quot;amount&quot;,  align: 'right'},
        ]
  * - totalRows: the total number of rows in the entire result set (including pages not visible)
  * - totalPages: The total number of pages of data available
  *
  * The collection should also provide the following methods:
  *
  * - sort(sortdata): Sort the collection according to the sortdata provided
  *       e.g. 
          {fields: [
                sortAsc: true
                field: 'title'
            ]
          }
  *        
  * - goToPage(pageNumber): Navigate to the pagenumber provided (1 = first page)
  *
  */


  Tent.Grid.CollectionSupport = Ember.Mixin.create({
<span id='Tent-Grid-CollectionSupport-property-collection'>    /**
</span>    * @property {Object} collection The collection object providing the API to the data source
    */

    collection: null,
<span id='Tent-Grid-CollectionSupport-property-paged'>    /**
</span>    * @property {Boolean} paged Boolean to indicate the data should be presented as a paged list
    */

    paged: false,
<span id='Tent-Grid-CollectionSupport-property-pageSize'>    /**
</span>    * @property {Number} pageSize The number of items in each page
    */

    pageSize: 12,
    pagingInfoBinding: 'collection.pagingInfo',
    sortingInfoBinding: 'collection.sortingInfo',
    columnInfoBinding: 'collection.columnInfo',
    groupingInfoBinding: 'collection.groupingInfo',
    init: function() {
      this._super(arguments);
      if (this.get('collection') != null) {
        return this.setupCustomizedProperties();
      }
    },
    addNavigationBar: function() {
      this._super();
      if (this.get('collection.personalizable')) {
        if (this.get('collection') != null) {
          this.renderSaveUIStateButton();
        }
        this.renderCollectionName();
        return this.populateCollectionDropdown();
      }
    },
    renderSaveUIStateButton: function() {
      var button, widget;
      widget = this;
      button = &quot;&lt;div class=\&quot;btn-group save-ui-state\&quot;&gt;\n  &lt;a data-toggle=\&quot;dropdown\&quot;&gt;&lt;i class=\&quot;icon-camera\&quot;&gt;&lt;/i&gt;&lt;span class=\&quot;custom-name\&quot;&gt;&lt;/span&gt;&lt;span class=\&quot;caret\&quot;&gt;&lt;/span&gt;&lt;/a&gt;\n  &lt;ul class=\&quot;dropdown-menu\&quot;&gt;\n    &lt;li&gt;&lt;a class=\&quot;save\&quot;&gt;&quot; + (Tent.I18n.loc(&quot;tent.button.save&quot;)) + &quot;&lt;/a&gt;&lt;/li&gt;\n    &lt;li class=\&quot;dropdown-submenu\&quot;&gt;\n      &lt;a&gt;&quot; + (Tent.I18n.loc(&quot;tent.button.saveAs&quot;)) + &quot;&lt;/a&gt;\n      &lt;ul class=\&quot;dropdown-menu save-as-panel\&quot;&gt;\n          &lt;p&gt;&quot; + (Tent.I18n.loc(&quot;tent.jqGrid.saveUi.message&quot;)) + &quot;&lt;/p&gt;\n          &lt;p&gt;&lt;input type=\&quot;text\&quot; class=\&quot;input-medium keep-open\&quot; value=\&quot;&quot; + (widget.get('collection.customizationName')) + &quot;\&quot;/&gt;&lt;/p&gt;\n          &lt;div&gt;&lt;a class='btn pull-left cancel'&gt;&quot; + (Tent.I18n.loc(&quot;tent.button.cancel&quot;)) + &quot;&lt;/a&gt;&lt;a class='btn pull-right saveas'&gt;&quot; + (Tent.I18n.loc(&quot;tent.button.save&quot;)) + &quot;&lt;/a&gt;&lt;/div&gt;\n      &lt;/ul&gt;\n    &lt;/li&gt; \n    &lt;li class=\&quot;dropdown-submenu\&quot;&gt;\n      &lt;a&gt;&quot; + (Tent.I18n.loc(&quot;tent.button.load&quot;)) + &quot;&lt;/a&gt;\n      &lt;ul class=\&quot;dropdown-menu load-panel\&quot;&gt;\n      &lt;/ul&gt;\n    &lt;/li&gt;  \n  &lt;/ul&gt;\n&lt;/div&gt;&quot;;
      this.$(&quot;.grid-header&quot;).append(button);
      this.$('.save-ui-state').bind('keyup', (function(e) {
        if (e.keyCode === 27) {
          return widget.toggleUIStatePanel();
        }
      }));
      this.$('.save-ui-state input').bind('keyup', (function(e) {
        widget.observeValueInput($(this));
        if (e.keyCode === 13) {
          return widget.saveAs($(this));
        }
      }));
      this.$('.save-ui-state .cancel').click(function() {
        return widget.toggleUIStatePanel();
      });
      this.$('.save-ui-state .save').click(function() {
        if (!$(this).hasClass('disabled')) {
          return widget.save();
        }
      });
      this.$('.save-ui-state .saveas').click(function() {
        if (!$(this).hasClass('disabled') &amp;&amp; widget.getInputField().val().trim() !== &quot;&quot;) {
          return widget.saveAs($(this));
        }
      });
      return $('.keep-open').click(function(e) {
        return e.stopPropagation();
      });
    },
    renderCollectionName: (function() {
      if ((this.get('collection') != null) &amp;&amp; this.get('collection.isCustomizable') &amp;&amp; (this.get('collection.customizationName') != null)) {
        this.$(&quot;.grid-header .custom-name&quot;).text(this.get('collection.customizationName'));
      }
      if (this.get('collection.isShowingDefault')) {
        this.disableSaveButton();
      } else {
        this.enableSaveButton();
      }
      return this.observeValueInput(this.getInputField());
    }).observes('collection.customizationName'),
    populateCollectionDropdown: (function() {
      var index, personalization, _i, _len, _ref,
        _this = this;
      if (this.$() != null) {
        this.$(&quot;.load-panel&quot;).empty();
        this.$(&quot;.load-panel&quot;).append('&lt;li&gt;&lt;a class=&quot;load&quot; data-index=&quot;-1&quot;&gt;' + Tent.I18n.loc(&quot;tent.jqGrid.saveUi.default&quot;) + '&lt;/a&gt;&lt;/li&gt;');
        if (this.get('collection.personalizations') != null) {
          _ref = this.get('collection.personalizations').toArray();
          for (index = _i = 0, _len = _ref.length; _i &lt; _len; index = ++_i) {
            personalization = _ref[index];
            this.$(&quot;.load-panel&quot;).append($('&lt;li&gt;&lt;a class=&quot;load&quot; data-index=&quot;' + index + '&quot; data-name=&quot;' + personalization.get('name') + '&quot;&gt;' + personalization.get('name') + '&lt;/a&gt;&lt;/li&gt;'));
          }
        }
        return this.$(&quot;.load-panel .load&quot;).click(function(e) {
          var name;
          index = $(e.target).attr('data-index');
          name = $(e.target).attr('data-name');
          _this.set('customizationIndex', index);
          _this.set('customizationName', name);
          return _this.initializeWithNewPersonalization(index);
        });
      }
    }).observes('collection.personalizations', 'collection.personalizations.@each'),
    getInputField: function() {
      return this.$('.save-ui-state input');
    },
    save: function() {
      this.toggleUIStatePanel();
      this.set('customizationName', this.get('collection.customizationName'));
      return this.saveUiState(this.get('collection.customizationName'));
    },
    saveAs: function(el) {
      this.toggleUIStatePanel();
      this.set('customizationName', el.parents('.save-ui-state').find('input').val());
      return this.saveUiState(this.get('customizationName'));
    },
    toggleUIStatePanel: function() {
      var panel, widget;
      widget = this;
      panel = this.$('.save-ui-state');
      return this.$('.save-ui-state').toggleClass('open');
    },
    saveUiState: function(name) {
      if (this.get('collection') != null) {
        return this.get('collection').saveUIState(name);
      }
    },
    disableSaveButton: function() {
      return this.$('.save-ui-state .save').addClass('disabled');
    },
    enableSaveButton: function() {
      return this.$('.save-ui-state .save').removeClass('disabled');
    },
    observeValueInput: function($input) {
      var input;
      input = $input.val();
      if (!(input != null) || input.trim() === &quot;&quot;) {
        return this.disableSaveAsButton();
      } else {
        return this.enableSaveAsButton();
      }
    },
    disableSaveAsButton: function() {
      return this.$('.save-ui-state .saveas').addClass('disabled');
    },
    enableSaveAsButton: function() {
      return this.$('.save-ui-state .saveas').removeClass('disabled');
    },
    setupCustomizedProperties: function() {
      this.setupPagingProperties();
      return this.setupSortingProperties();
    },
    setupPagingProperties: function() {
      return this.setPageSize();
    },
    setPageSize: function() {
      if (this.get('pagingInfo') != null) {
        if (this.get('paged') &amp;&amp; (this.get('pageSize') != null) &amp;&amp; !(this.get('pagingInfo.pageSize') != null)) {
          return this.set('pagingInfo.pageSize', this.get('pageSize'));
        }
      }
    },
    setupSortingProperties: function() {},
    setupColumnTitleProperties: function() {
      return this.set('colNames', []);
    },
    setupColumnVisibilityProperties: function() {
      var column, hidden, name, _ref, _results;
      if (this.get('collection.personalizable')) {
        _ref = this.get('columnInfo.hidden');
        _results = [];
        for (name in _ref) {
          hidden = _ref[name];
          _results.push((function() {
            var _i, _len, _ref1, _results1;
            _ref1 = this.get('columnModel');
            _results1 = [];
            for (_i = 0, _len = _ref1.length; _i &lt; _len; _i++) {
              column = _ref1[_i];
              if (column.name === name) {
                _results1.push(column.hidden = hidden);
              } else {
                _results1.push(void 0);
              }
            }
            return _results1;
          }).call(this));
        }
        return _results;
      }
    },
    setupColumnWidthProperties: function() {
      var column, name, width, _ref, _results;
      if (this.get('collection.personalizable')) {
        _ref = this.get('columnInfo.widths');
        _results = [];
        for (name in _ref) {
          width = _ref[name];
          _results.push((function() {
            var _i, _len, _ref1, _results1;
            _ref1 = this.get('columnModel');
            _results1 = [];
            for (_i = 0, _len = _ref1.length; _i &lt; _len; _i++) {
              column = _ref1[_i];
              if (column.name === name) {
                _results1.push(column.width = width);
              } else {
                _results1.push(void 0);
              }
            }
            return _results1;
          }).call(this));
        }
        return _results;
      }
    },
    setupColumnOrderingProperties: function() {
      var column, k, lastkey, order, permutation, position, v, _i, _j, _len, _len1, _ref, _ref1;
      if (this.get('collection.personalizable')) {
        if (this.get('columnInfo')) {
          if ((this.get('columnInfo.order') != null) &amp;&amp; !$.isEmptyObject(this.get('columnInfo.order'))) {
            permutation = [0];
            if (this.getColModel() &amp;&amp; this.getColModel().length &gt; 0 &amp;&amp; this.getColModel()[0].name !== 'cb') {
              delete this.get('columnInfo.order')[0];
              order = this.get('columnInfo.order');
              lastkey = null;
              for (k in order) {
                v = order[k];
                order[k - 1] = v - 1;
                lastkey = k;
              }
              delete this.get('columnInfo.order')[lastkey];
            }
            _ref = this.get('columnModel');
            for (position = _i = 0, _len = _ref.length; _i &lt; _len; position = ++_i) {
              column = _ref[position];
              if (this.getColModel()[0].name === 'cb') {
                position = position + 1;
              }
              column = this.get('columnInfo.order')[position];
              if (column != null) {
                permutation[column] = position;
              }
            }
            if (permutation.length &gt; 1) {
              return this.getTableDom().remapColumns(permutation, true, false);
            }
          } else {
            permutation = [0];
            _ref1 = this.get('columnModel');
            for (position = _j = 0, _len1 = _ref1.length; _j &lt; _len1; position = ++_j) {
              column = _ref1[position];
              permutation[position + 1] = column.order || (position + 1);
            }
            return this.set('columnInfo.oldOrder', permutation);
          }
        }
      }
    },
    setupColumnGroupingProperties: function() {
      if ((this.get('groupingInfo.columnName') != null) &amp;&amp; (this.get('groupingInfo.type') != null)) {
        return this.doRemoteGrouping(this.get('groupingInfo.type'), this.get('groupingInfo.columnName'));
      }
    },
    storeColumnDataToCollection: function() {
      var col, _i, _j, _len, _len1, _ref, _ref1, _results;
      if (this.getTableDom().length &gt; 0) {
        if (this.get('columnInfo') != null) {
          _ref = this.getColModel();
          for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
            col = _ref[_i];
            this.set('columnInfo.hidden.' + col.name, col.hidden);
          }
        }
        if (this.get('columnInfo') != null) {
          _ref1 = this.getTableDom().get(0).p.colModel;
          _results = [];
          for (_j = 0, _len1 = _ref1.length; _j &lt; _len1; _j++) {
            col = _ref1[_j];
            _results.push(this.set('columnInfo.widths.' + col.name, col.width));
          }
          return _results;
        }
      }
    },
    storeColumnOrderingToCollection: function(permutation) {
      var col, field, match, oldOrder, position, _i, _len;
      if (this.get('columnInfo') != null) {
        oldOrder = this.get('columnInfo.oldOrder');
        if (this.getColModel() &amp;&amp; this.getColModel().length &gt; 0 &amp;&amp; this.getColModel()[0].name !== 'cb') {
          permutation.unshift(0);
          permutation = permutation.map(function(item) {
            return item + 1;
          });
          permutation[0] = 0;
        }
        if (oldOrder != null) {
          for (position = _i = 0, _len = permutation.length; _i &lt; _len; position = ++_i) {
            col = permutation[position];
            match = null;
            for (field in oldOrder) {
              if (oldOrder[field] === col) {
                match = field;
              }
            }
            if (match != null) {
              this.set('columnInfo.order.' + match, position);
            }
          }
        }
        this.set('columnInfo.oldOrder', Ember.copy(this.get('columnInfo.order')));
        return console.log(&quot;Ordering = &quot; + this.get('columnInfo.order'));
      }
    },
    didInsertElement: function() {
      if (this.get('collection') != null) {
        return this.setupCustomizedProperties();
      }
    },
    onPageOrSort: function(postdata) {
      if (this.get('collection') != null) {
        if (this.shouldSort(postdata)) {
          this.getTableDom().jqGrid('groupingRemove', true);
          return this.get('collection').sort({
            fields: [
              {
                sortDir: postdata.sord,
                field: postdata.sidx
              }
            ]
          });
        } else {
          if (!(this.get('collection.personalizationsRecord') &amp;&amp; !this.get('collection.personalizationsRecord.isLoaded'))) {
            return this.get('collection').goToPage(postdata.page);
          }
        }
      }
    },
    shouldSort: function(postdata) {
      var columnDef, newSort, sortBy, sortable, _i, _len, _ref;
      sortable = false;
      sortBy = postdata.sidx.split(',');
      newSort = sortBy[sortBy.length - 1].trim();
      if (this.get('columns') != null) {
        _ref = this.get('columns');
        for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
          columnDef = _ref[_i];
          if (newSort.indexOf(columnDef.name) &gt; -1 &amp;&amp; (columnDef.sortable != null) &amp;&amp; columnDef.sortable) {
            postdata.sidx = columnDef.name;
            sortable = true;
          }
        }
      }
      return sortable &amp;&amp; postdata.sidx !== &quot;&quot; &amp;&amp; (postdata.sidx !== this.get('sortingInfo.fields.firstObject.field') || postdata.sord !== this.get('sortingInfo.fields.firstObject.sortDir'));
    },
    restoreUIState: (function() {
      return this.initializeWithNewPersonalization(0);
    }).observes('collection.personalizations'),
    initializeWithNewPersonalization: function(index) {
      var uiState;
      if (this.get('customizationName') !== this.get('collection.customizationName')) {
        if (parseInt(index) !== -1 &amp;&amp; (this.get('collection.personalizations').objectAt(index) != null)) {
          uiState = this.get('collection.personalizations').objectAt(index).get('settings');
        } else {
          uiState = this.get('collection.defaultPersonalization');
        }
        this.set('collection.customizationName', uiState.customizationName);
        if (uiState.paging != null) {
          this.set('collection.pagingInfo', jQuery.extend(true, {}, uiState.paging));
        }
        if (uiState.sorting != null) {
          this.set('collection.sortingInfo', jQuery.extend(true, {}, uiState.sorting));
        }
        if (uiState.filtering != null) {
          this.set('collection.filteringInfo', jQuery.extend(true, {}, uiState.filtering));
        }
        if (uiState.columns != null) {
          this.set('columnInfo', jQuery.extend(true, {}, uiState.columns));
        }
        if (uiState.grouping != null) {
          this.set('groupingInfo', jQuery.extend(true, {}, uiState.grouping));
        }
        this.applyStoredPropertiesToGrid();
        return this.populateCollectionDropdown();
      }
    }
  });

}).call(this);


(function() {

  Tent.Grid = Tent.Grid || Ember.Namespace.create();

<span id='Tent-Grid-SelectionSupport'>  /**
</span>  * @class Tent.Grid.SelectionSupport
  * Provides support for selecting items in a grid
  */


  Tent.Grid.SelectionSupport = Ember.Mixin.create({
    didSelectRow: function(itemId, status, e) {
      if (!this.get('multiSelect')) {
        this.selectItemSingleSelect(itemId);
      } else {
        this.selectItemMultiSelect(itemId, status);
      }
      if (this.get('afterSelectRow') != null) {
        return this.get('afterSelectRow').call(this, itemId, status, e);
      }
    },
    selectItemSingleSelect: function(itemId) {
      this.clearSelection();
      return this.selectItem(itemId);
    },
<span id='Tent-Grid-SelectionSupport-method-clearSelection'>    /**
</span>    * @method  clearSelection Removes all items from the selection array and resets the grid
    */

    clearSelection: function() {
      return this.set('selection', []);
    },
    selectItem: function(itemId) {
      var selectedItem, selection;
      selectedItem = this.getItemFromModel(itemId);
      selection = this.get('selection');
      if ((selectedItem != null) &amp;&amp; !selection.contains(selectedItem)) {
        return selection.pushObject(selectedItem);
      }
    },
    selectItemMultiSelect: function(itemId, status) {
      if (status !== false) {
        return this.selectItem(itemId);
      } else {
        return this.deselectItem(itemId);
      }
    },
    deselectItem: function(itemId) {
      return this.removeItemFromSelection(itemId);
    },
    removeItemFromSelection: function(id) {
      return this.set('selection', this.get('selection').filter(function(item, index) {
        return item.get('id') !== parseInt(id);
      }));
    },
    didSelectAll: function(rowIds, status) {
      var allPageItems, id, selectedIds, selectedItem, selection, _i, _j, _len, _len1;
      selectedIds = this.get('selectedIds');
      if (this.get('paged')) {
        if (status !== false) {
          allPageItems = [];
          selection = this.get('selection');
          for (_i = 0, _len = rowIds.length; _i &lt; _len; _i++) {
            id = rowIds[_i];
            selectedItem = this.getItemFromModel(id);
            if ((selectedItem != null) &amp;&amp; !selection.contains(selectedItem)) {
              allPageItems.push(selectedItem);
            }
          }
          selection.pushObjects(allPageItems);
        } else {
          allPageItems = [];
          for (_j = 0, _len1 = rowIds.length; _j &lt; _len1; _j++) {
            id = rowIds[_j];
            allPageItems.push(this.getItemFromModel(id));
          }
          this.get('selection').removeObjects(allPageItems);
        }
      } else {
        if (status !== false) {
          this.selectAllItems();
        } else {
          this.clearSelection();
        }
      }
      if (this.get('afterSelectAll') != null) {
        return this.get('afterSelectAll').call(this, rowIds, status);
      }
    },
    selectAllItems: function() {
      return this.set('selection', this.get('content').filter(function() {
        return true;
      }));
    },
    selectionDidChange: (function() {
      return this.updateGrid();
    }).observes('selection.@each')
  });

}).call(this);


(function() {

  Tent.Grid.Adapters = Ember.Mixin.create({
    columns: (function() {
      return this.get('collection.columnsDescriptor');
    }).property('collection.columnsDescriptor'),
    colNames: (function() {
      var column, name, names, t, title, _i, _len, _ref, _ref1;
      names = [];
      _ref = this.get('columnModel');
      for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
        column = _ref[_i];
        t = Tent.I18n.loc(column.title);
        if (this.get('columnInfo.titles') != null) {
          _ref1 = this.get('columnInfo.titles');
          for (name in _ref1) {
            title = _ref1[name];
            if (column.name === name) {
              t = title;
            }
          }
        }
        names.pushObject(t);
      }
      return names;
    }).property('columns'),
    columnModel: (function() {
      var column, columns, item, _i, _len, _ref;
      columns = Ember.A();
      if (this.get('columns') != null) {
        _ref = this.get('columns');
        for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
          column = _ref[_i];
          item = Ember.Object.create({
            name: column.name,
            index: column.name,
            align: column.align,
            editable: column.editable,
            formatter: column.formatter,
            formatoptions: column.formatoptions,
            edittype: Tent.JqGrid.editTypes[column.formatter] || 'text',
            editoptions: column.editoptions || Tent.JqGrid.editOptions[column.formatter],
            editrules: column.editrules || Tent.JqGrid.editRules[column.formatter],
            width: column.width || 80,
            position: &quot;right&quot;,
            hidden: column.hidden != null ? column.hidden : false,
            hideable: column.hideable,
            hidedlg: column.hideable === false ? true : void 0,
            sortable: column.sortable,
            groupable: column.groupable,
            resizable: true,
            title: Tent.I18n.loc(column.title),
            t: Tent.I18n.loc(column.title)
          });
          columns.pushObject(item);
        }
      }
      return columns;
    }).property('columns'),
    columnNames: (function() {
      var column, columnNames, _i, _len, _ref;
      columnNames = [];
      _ref = this.get('columnModel');
      for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
        column = _ref[_i];
        columnNames.pushObject(column.name);
      }
      return columnNames;
    }).property('columnModel', 'columnModel.@each'),
    fixedRows: (function() {
      return this.get('collection.totals');
    }).property('content', 'content.isLoaded'),
    fixedRowsCount: (function() {
      return this.get('fixedRows.length');
    }).property('fixedRows'),
    gridData: (function() {
      var cell, column, grid, item, model, models, _i, _j, _k, _len, _len1, _len2, _ref;
      grid = [];
      if (this.get('content') != null) {
        models = this.get('content').toArray();
        if (this.isShowingValidGroups()) {
          for (_i = 0, _len = models.length; _i &lt; _len; _i++) {
            model = models[_i];
            grid.push(model);
          }
        } else {
          for (_j = 0, _len1 = models.length; _j &lt; _len1; _j++) {
            model = models[_j];
            item = {
              &quot;id&quot;: model.get('id')
            };
            if (this.get('selectedIds').contains(model.get('id'))) {
              item.sel = true;
            }
            cell = [];
            _ref = this.get('columnModel');
            for (_k = 0, _len2 = _ref.length; _k &lt; _len2; _k++) {
              column = _ref[_k];
              cell.push(model.get(column.name));
            }
            item.cell = cell;
            if (model.get(&quot;presentationType&quot;) === &quot;summary&quot;) {
              grid;

            } else {
              grid.push(item);
            }
          }
        }
      }
      return grid;
    }).property('content', 'content.isLoaded', 'content.@each'),
    gridDataDidChange: (function() {
      var data, grid, _ref;
      this.getTableDom()[0].p.viewrecords = false;
      this.getTableDom().jqGrid('clearGridData');
      /*
      		* As soon as the required data is loaded set viewrecords attribute of jqGrid to true, and let it 
      		* calculate whether there are any records or not using the reccount attribute
      */

      if (this.get('content.isLoaded')) {
        this.getTableDom()[0].p.viewrecords = true;
      }
      data = {
        rows: this.get('gridData'),
        total: this.get('pagingInfo') != null ? this.get('pagingInfo.totalPages') : void 0,
        records: this.get('pagingInfo') != null ? this.get('pagingInfo.totalRows') : void 0,
        page: this.get('pagingInfo') != null ? this.get('pagingInfo').page : void 0,
        userdata: this.get('fixedRows'),
        remoteGrouping: this.isShowingValidGroups(),
        columns: this.get('columnModel')
      };
      this.resetGrouping();
      if (this.isShowingValidGroups()) {
        data.columnName = this.get('groupingInfo.columnName');
        data.columnType = this.get('groupingInfo.columnType');
        data.groupType = this.get('groupingInfo.type');
        data.columnTitle = this.getColumnTitle(data.columnName);
        data.showGroupTitle = this.get('showGroupTitle');
        grid = this.getTableDom()[0];
        this.updatePagingForGroups(grid, data);
        if (grid != null) {
          grid.addGroupingData(data);
        }
      } else {
        if ((_ref = this.getTableDom()[0]) != null) {
          _ref.addJSONData(data);
        }
      }
      return this.updateGrid();
    }).observes('content', 'content.isLoaded', 'content.@each', 'pagingInfo')
  });

}).call(this);



<span id='Tent-Grid-ExportSupport'>/**
</span>* @class Tent.Grid.ExportSupport
* Adds export functionality to a grid
*/


(function() {

  Tent.Grid.ExportSupport = Ember.Mixin.create({
<span id='Tent-Grid-ExportSupport-property-showExportButton'>    /**
</span>    * @property {Boolean} showExportButton Display a button in the header which allows the table data to
    * be exported a selected format.
    */

    showExportButton: true,
    addNavigationBar: function() {
      return this._super();
    },
    getVisibleColumns: function(custom) {
      var visibleColumns,
        _this = this;
      if (custom == null) {
        custom = false;
      }
      visibleColumns = this.getColModel().filter(function(column) {
        return (column.name !== 'cb') &amp;&amp; (!column.hidden);
      });
      return visibleColumns.map(function(column) {
        var userDefinedTitles;
        if (custom) {
          userDefinedTitles = _this.get('columnInfo.titles');
          return userDefinedTitles[column.index] || column.t;
        } else {
          return column.name.underscore();
        }
      });
    },
    getExportUrl: function(contentType) {
      var collection, customHeaderString, params, visibleColumnString;
      visibleColumnString = this.getVisibleColumns().join(',');
      customHeaderString = this.getVisibleColumns(true).join(',');
      params = {
        del: &quot;,&quot;,
        headers: true,
        quotes: true,
        date: this.generateExportDate(),
        columns: visibleColumnString,
        custom_headers: customHeaderString
      };
      if ((collection = this.get('collection')) != null) {
        return collection.getURL(contentType, params);
      }
    },
    clientDownload: function(file, type) {
      var data, link, popup;
      if (navigator.appName !== 'Microsoft Internet Explorer') {
        data = 'data:text/csv;charset=utf-8,' + escape(file);
        link = document.createElement('a');
        link.setAttribute('href', data);
        link.setAttribute('download', 'data.' + type);
        return link.click();
      } else {
        popup = window.open('', 'csv', '');
        return popup.document.body.innerHTML = '&lt;pre&gt;' + file + '&lt;/pre&gt;';
      }
    },
    exportCSV: function(data, customParams) {
      var arr, del, key, n, obj, orderedData, str, value, _i, _len;
      orderedData = [];
      for (_i = 0, _len = data.length; _i &lt; _len; _i++) {
        obj = data[_i];
        arr = [];
        str = customParams.headers &amp;&amp; customParams.quotes ? &quot;\'&quot; : &quot;&quot;;
        del = customParams.quotes ? &quot;\'&quot; + customParams.del + &quot;\'&quot; : customParams.del;
        for (key in obj) {
          value = obj[key];
          arr.push(value);
          if (customParams.headers) {
            str += key + del;
          }
        }
        orderedData.push(arr);
      }
      if (customParams.headers) {
        n = customParams.quotes ? -2 : -1;
        str = str.slice(0, n) + &quot;\r\n&quot;;
      }
      orderedData.forEach(function(row) {
        if (customParams.quotes) {
          str += &quot;\'&quot;;
        }
        str += row.join(del);
        return str += customParams.quotes ? &quot;\' \r\n&quot; : &quot;\r\n&quot;;
      });
      return str;
    },
    generateExportDate: function() {
      return Tent.Formatting.date.format(new Date(), &quot;dd-M-yy hh-mm tz&quot;);
    },
    getPersonalizedData: function(data, customParams) {
      var columns, customHeaders, index, obj, personalizedData, personalizedObject, precision, value, _i, _j, _len, _ref;
      precision = 2;
      if (data[0]['currency']) {
        precision = Tent.CURRENCIES_ISO_4217[data[0]['currency']].cent;
      }
      personalizedData = [];
      columns = customParams.columns.split(',');
      customHeaders = customParams.custom_headers.split(',');
      for (_i = 0, _len = data.length; _i &lt; _len; _i++) {
        obj = data[_i];
        personalizedObject = {};
        for (index = _j = 0, _ref = columns.length - 1; 0 &lt;= _ref ? _j &lt;= _ref : _j &gt;= _ref; index = 0 &lt;= _ref ? ++_j : --_j) {
          if (typeof (value = obj[Ember.String.camelize(columns[index])]) === &quot;number&quot;) {
            value = value.toFixed(precision);
          }
          personalizedObject[customHeaders[index]] = value;
        }
        personalizedData.pushObject(personalizedObject);
      }
      return personalizedData;
    }
  });

}).call(this);



<span id='Tent-Grid-EditableSupport'>/**
</span>* @class Tent.Grid.EditableSupport
* Provides support for editable fields in a grid
*/


(function() {

  Tent.Grid.EditableSupport = Ember.Mixin.create({
<span id='Tent-Grid-EditableSupport-property-onEditRow'>    /**
</span>    	* @property {Function} onEditRow A callback function which will be called when a row is made editable. 
    	* The context of the function is this JqGrid View, and it will accept the following parameters:
    	* 
    	* -rowId: the id of the selected row
    	* -grid: the jqGrid
    	*
    */

    onEditRow: null,
<span id='Tent-Grid-EditableSupport-property-onRestoreRow'>    /**
</span>    	* @property {Function} onRestoreRow A callback function which will be called when editing of a row is cancelled,
    	* and the original values restored to the cells. 
    	* The context of the function is this JqGrid View, and it will accept the following parameters:
    	* 
    	* -rowId: the id of the selected row
    	* -grid: the jqGrid
    	*
    */

    onRestoreRow: null,
<span id='Tent-Grid-EditableSupport-property-onSaveCell'>    /**
</span>    	* @property {Function} onSaveCell A callback function which will be called when an editable cell is saved. (This 
    	* usually occurs on change or blur) 
    	* The context of the function is this JqGrid View, and it will accept the following parameters:
    	* 
    	* -rowId: the id of the selected row
    	* -grid: the jqGrid
    	* -cellName: the name of the edited cell
    	* -iCell: the position of the edited cell
    	*
    */

    onSaveCell: null,
    showEditableCells: function() {
      var id, table, _i, _len, _ref, _results;
      table = this.getTableDom();
      if (table != null) {
        _ref = table.jqGrid('getDataIDs');
        _results = [];
        for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
          id = _ref[_i];
          _results.push(this.showEditableCell(id, table));
        }
        return _results;
      }
    },
    showEditableCell: function(id, table) {
      if (this.get('selectedIds').contains(id)) {
        return this.editRow(id, table);
      } else {
        return this.restoreRow(id);
      }
    },
    editRow: function(rowId, table) {
      table = table || this.getTableDom();
      return table.jqGrid('editRow', rowId, false, this.onEditFunc());
    },
    restoreRow: function(rowId, table) {
      if (this.isRowCurrentlyEditing(rowId)) {
        table = table || this.getTableDom();
        table.jqGrid('restoreRow', rowId);
        this.saveEditedRow(rowId);
        if (this.get('onRestoreRow') != null) {
          return this.get('onRestoreRow').call(this, rowId, table);
        }
      }
    },
    restoreRows: function(ids) {
      var contentArray, onRestoreRow, row, rowId, savedRows, tableDom, _i, _len, _results;
      tableDom = this.getTableDom();
      savedRows = tableDom[0].p.savedRow.filter(function() {
        return true;
      });
      contentArray = this.get('content').toArray();
      onRestoreRow = this.get('onRestoreRow');
      _results = [];
      for (_i = 0, _len = savedRows.length; _i &lt; _len; _i++) {
        row = savedRows[_i];
        rowId = row.id;
        tableDom.jqGrid('restoreRow', rowId);
        this.cancelEditedRow(rowId, contentArray);
        if (onRestoreRow != null) {
          _results.push(onRestoreRow.call(this, rowId, tableDom));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    cancelEditedRow: function(rowId, contentArray) {
      var col, model, rowData, _i, _len, _ref, _results;
      rowData = this.getTableDom().getRowData(rowId);
      model = this.getItemFromModel(rowId, contentArray);
      _ref = this.getColModel();
      _results = [];
      for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
        col = _ref[_i];
        if (col.editable) {
          _results.push(model.set(col.name, rowData[col.name]));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    isRowCurrentlyEditing: function(rowId) {
      var isEditing, row, savedRow, _i, _len;
      isEditing = false;
      savedRow = this.getTableDom()[0].p.savedRow;
      for (_i = 0, _len = savedRow.length; _i &lt; _len; _i++) {
        row = savedRow[_i];
        if (row.id === rowId) {
          isEditing = true;
        }
      }
      return isEditing;
    },
    onEditFunc: function(rowId) {
      var widget;
      widget = this;
      return function(rowId) {
        if (widget.get('onEditRow') != null) {
          return widget.get('onEditRow').call(widget, rowId, widget.getTableDom());
        }
      };
    },
    saveEditedRow: function(rowId, status, options) {
      var col, modelItem, rowData, _i, _len, _ref, _results;
      rowData = this.getTableDom().getRowData(rowId);
      modelItem = this.getItemFromModel(rowId);
      _ref = this.getColModel();
      _results = [];
      for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
        col = _ref[_i];
        if (col.editable) {
          _results.push(this.saveEditedCell(rowId, col.name, rowData[col.name], null, null, null, modelItem));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    saveEditedCell: function(rowId, cellName, value, iRow, iCell, cell, modelItem) {
      var formatter;
      modelItem = modelItem || this.getItemFromModel(rowId);
      formatter = this.getTableDom().getColProp(cellName).formatter;
      if ($.fn.fmatter[formatter] != null) {
        if (cell != null) {
          return modelItem.set(cellName, $.fn.fmatter[formatter].unformat(null, {}, cell));
        } else {
          return modelItem.set(cellName, $.fn.fmatter[formatter].unformat(value));
        }
      } else {
        return modelItem.set(cellName, value);
      }
    },
    saveEditableCell: function(element) {
      var cellName, cellpos, rowId;
      rowId = $(element).parents('tr:first').attr('id');
      cellpos = $(element).parents('tr').children().index($(element).parents('td'));
      cellName = this.getColModel()[cellpos].name;
      this.saveEditedCell(rowId, cellName, null, null, null, $(element).parent());
      if (this.onSaveCell != null) {
        return this.onSaveCell.call(this, rowId, this.getTableDom(), cellName, cellpos);
      }
    }
  });

}).call(this);



<span id='Tent-Grid-GroupingSupport'>/**
</span>* @class Tent.Grid.GroupingSupport
* Adds grouping support to a grid
*/


(function() {

  Tent.Grid.GroupingSupport = Ember.Mixin.create({
    remoteGrouping: false,
<span id='Tent-Grid-GroupingSupport-property-showGroupTitle'>    /**
</span>     * @property {Boolean} showGroupTitle Show the title of the group in each grouping row along with the group data.
    */

    showGroupTitle: true,
    showingGroups: false,
    newGroupSelected: function(groupType, columnName) {
      if (this.remoteGrouping) {
        return this.doRemoteGrouping(groupType, columnName);
      } else {
        return this.doLocalGrouping(groupType, columnName);
      }
    },
    doLocalGrouping: function(groupType, columnName) {
      var columnDef, columnType, comparator, lastSort, _i, _len, _ref;
      if (groupType === 'none') {
        return this.getTableDom().jqGrid('groupingRemove', true);
      } else {
        columnType = this.getColumnType(columnName);
        lastSort = this.getTableDom()[0].p.sortname;
        _ref = this.get('columns');
        for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
          columnDef = _ref[_i];
          if (columnDef.name === columnName &amp;&amp; (columnDef.sortable != null) &amp;&amp; columnDef.sortable) {
            if ((!(lastSort != null)) || !(lastSort === columnName)) {
              this.getTableDom().sortGrid(columnName);
            }
          }
        }
        comparator = Tent.JqGrid.Grouping.getComparator(columnType, groupType);
        this.getTableDom().groupingGroupBy(columnName, {
          groupText: ['&lt;b&gt;' + this.getColumnTitle(columnName) + ':  {0}&lt;/b&gt;'],
          range: comparator
        });
        return this.gridDataDidChange();
      }
    },
    getColumnType: function(columnName) {
      var col, columnType, _i, _len, _ref;
      columnType = 'string';
      _ref = this.get('columns');
      for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
        col = _ref[_i];
        if (col.name === columnName) {
          columnType = col.type;
        }
      }
      return columnType;
    },
    doRemoteGrouping: function(groupType, columnName) {
      var groupData;
      this.clearAllGrouping();
      if (groupType === 'none') {
        return this.get('collection').goToPage(1);
      } else {
        groupData = {
          columnName: columnName,
          type: groupType,
          columnType: this.getColumnType(columnName)
        };
        this.setShowingGroupsListState(true);
        return this.get('collection').goToGroupPage(1, groupData);
      }
    },
    didSelectGroup: function(itemId, status, e) {
      return this.selectRemoteGroup(itemId);
    },
    selectRemoteGroup: function(id) {
      this.setShowingGroupsListState(false);
      this.showGroupHeader(id);
      this.get('collection').setCurrentGroupId(id);
      return this.get('collection').goToPage(1);
    },
    showGroupHeader: function(id) {
      var aggregateColumns, columnName, columnTitle, columnType, comparator, content, groupType, headerRow, item, selectedGroup, startValue, widget, _i, _len, _ref;
      widget = this;
      columnName = this.get('groupingInfo.columnName');
      columnType = this.get('groupingInfo.columnType');
      groupType = this.get('groupingInfo.type');
      columnTitle = this.getColumnTitle(columnName);
      _ref = this.get('content').toArray();
      for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
        item = _ref[_i];
        if (item.get('id') === parseInt(id, 10)) {
          selectedGroup = item;
        }
      }
      if (selectedGroup != null) {
        if (this.get('showGroupTitle')) {
          content = &quot;&lt;span class='title'&gt;&quot; + this.getColumnTitle(columnName) + &quot;&lt;/span&gt;&quot;;
        }
        content = content + &quot;&lt;span class='range'&gt;&quot;;
        comparator = Tent.JqGrid.Grouping.getComparator(columnType, groupType);
        startValue = selectedGroup[columnName.decamelize()];
        if (startValue != null) {
          content = content + comparator.rowTitle(startValue);
        }
        content = content + &quot;&lt;/span&gt;&quot;;
      }
      aggregateColumns = this.addAggregateData(this.get('columnModel'), selectedGroup);
      headerRow = $('&lt;tr class=&quot;group-header&quot;&gt;&lt;td&gt;&lt;i class=&quot;icon-caret-left&quot;&gt;&lt;/i&gt;' + content + '&lt;/td&gt;' + aggregateColumns + '&lt;/tr&gt;');
      this.$('.ui-jqgrid-hbox .ui-jqgrid-htable').append(headerRow);
      headerRow.click(function() {
        return widget.returnToGroupList();
      });
      return this.columnsDidChange();
    },
    addAggregateData: function(columns, row) {
      var aggregateColumns, hasAggregates;
      hasAggregates = false;
      aggregateColumns = '';
      columns.forEach((function(col, i) {
        var aggregate;
        if (i === 0) {
          return;
        }
        aggregate = row.get(col.name + &quot;_sum&quot;);
        if (aggregate === void 0) {
          aggregate = &quot;&quot;;
        }
        return aggregateColumns += &quot;&lt;td&gt;&quot; + aggregate + &quot;&lt;/td&gt;&quot;;
      }));
      return aggregateColumns;
    },
    hideGroupHeader: function() {
      var headerRow;
      headerRow = this.$('.ui-jqgrid-hbox .group-header');
      headerRow.remove();
      return this.columnsDidChange();
    },
    getColSpan: function() {
      var visibleColumns;
      visibleColumns = this.getTableDom()[0].p.colModel.filter(function(col) {
        return !col.hidden;
      });
      return visibleColumns.length;
    },
    returnToGroupList: function() {
      this.setShowingGroupsListState(true);
      this.hideGroupHeader();
      return this.get('collection').goToGroupPage();
    },
    clearAllGrouping: function() {
      this.get('collection').clearGrouping();
      this.hideGroupHeader();
      return this.setShowingGroupsListState(false);
    },
    setShowingGroupsListState: function(isShowing) {
      this.set('showingGroups', isShowing);
      return this.set('collection.isShowingGroupsList', isShowing);
    },
    isShowingValidGroups: function() {
      return this.get('showingGroups') &amp;&amp; (this.get('groupingInfo.columnName') != null);
    }
  });

}).call(this);



<span id='Tent-Grid-ColumnChooserSupport'>/**
</span>* @class Tent.Grid.ColumnChooserSupport
* Adds a column choooser to a grid
*/


(function() {

  Tent.Grid.ColumnChooserSupport = Ember.Mixin.create({
<span id='Tent-Grid-ColumnChooserSupport-property-showColumnChooser'>    /**
</span>    	* @property {Boolean} showColumnChooser Display a button at the top of the grid which presents
    	* a dialog to show/hide columns. Any columns which have a property **'hideable:false'** will not be shown
    	* in this dialog
    */

    showColumnChooser: true,
    addNavigationBar: function() {
      return this._super();
    },
    showCol: function(column) {
      this.getTableDom().jqGrid(&quot;showCol&quot;, column);
      return this.refreshGrid();
    },
    hideCol: function(column) {
      this.getTableDom().jqGrid(&quot;hideCol&quot;, column);
      return this.refreshGrid();
    },
    refreshGrid: function() {
      this.columnsDidChange();
      this.storeColumnDataToCollection();
      return this.resizeToContainer();
    }
  });

}).call(this);


(function() {

  Tent.Grid.ColumnMenu = Ember.Mixin.create({
    columnsDidChange: function() {
      return this.leftAlignLastDropdown();
    },
    addColumnDropdowns: function() {
      var column, columnDivId, context, groupType, template, _i, _len, _ref;
      if (this.get('columns') != null) {
        _ref = this.get('columns');
        for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
          column = _ref[_i];
          column.groupable = !((column.groupable != null) &amp;&amp; column.groupable === false);
          column.renamable = !((column.renamable != null) &amp;&amp; column.renamable === false);
          column.sortable = !((column.sortable != null) &amp;&amp; column.sortable === false);
          if (column.groupable || column.renamable || column.sortable) {
            template = Handlebars.compile('\
						 	&lt;ul class=&quot;dropdown-menu column-dropdown&quot; data-column=&quot;{{column.name}}&quot; data-last-title=&quot;{{title}}&quot; data-orig-title=&quot;{{title}}&quot;&gt;\
								{{#if column.sortable}}\
									&lt;li class=&quot;sort dropdown-submenu&quot;&gt;\
										&lt;a tabindex=&quot;-1&quot;&gt;{{sort}}&lt;/a&gt;\
									    &lt;ul class=&quot;dropdown-menu&quot;&gt;\
									    	&lt;li&gt;&lt;a tabindex=&quot;-1&quot; class=&quot;ascending&quot;&gt;{{ascending}}&lt;/a&gt;&lt;/li&gt;\
									    	&lt;li&gt;&lt;a tabindex=&quot;-1&quot; class=&quot;descending&quot;&gt;{{descending}}&lt;/a&gt;&lt;/li&gt;\
									    &lt;/ul&gt;\
									&lt;/li&gt;\
								{{/if}}\
								{{#if column.groupable}}\
									&lt;li class=&quot;group dropdown-submenu&quot;&gt;\
										&lt;a tabindex=&quot;-1&quot;&gt;{{group}}&lt;/a&gt;\
									    &lt;ul class=&quot;dropdown-menu&quot;&gt;\
									    	&lt;li data-grouptype=&quot;none&quot;&gt;&lt;a tabindex=&quot;-1&quot;&gt;{{none}}&lt;/a&gt;&lt;/li&gt;\
									    	{{#each groupType}}\
									    		&lt;li data-grouptype=&quot;{{name}}&quot;&gt;&lt;a class=&quot;revert&quot; tabindex=&quot;-1&quot;&gt;{{title}}&lt;/a&gt;&lt;/li&gt;\
									    	{{/each}}\
									    &lt;/ul&gt;\
									&lt;/li&gt;\
								{{/if}}\
								{{#if column.renamable}}\
									&lt;li class=&quot;rename dropdown-submenu&quot;&gt;\
										&lt;a tabindex=&quot;-1&quot;&gt;{{rename}}&lt;/a&gt;\
									    &lt;ul class=&quot;dropdown-menu wide&quot;&gt;\
									    	&lt;li&gt;&lt;input type=&quot;text&quot; value=&quot;{{title}}&quot; class=&quot;input-medium&quot;/&gt;&lt;/li&gt;\
									    	&lt;li&gt;&lt;a tabindex=&quot;-1&quot; class=&quot;revert&quot;&gt;{{revert}}&lt;/a&gt;&lt;/li&gt;\
									    &lt;/ul&gt;\
									&lt;/li&gt;\
								{{/if}}\
							&lt;/ul&gt;');
            if (column.type != null) {
              groupType = Tent.JqGrid.Grouping.ranges.get(column.type)();
            }
            if (!(groupType != null)) {
              groupType = Tent.JqGrid.Grouping.ranges['string'];
            }
            context = {
              column: column,
              title: Tent.I18n.loc(column.title),
              groupType: groupType,
              none: Tent.I18n.loc(&quot;tent.grouping.no_grouping&quot;),
              revert: Tent.I18n.loc(&quot;tent.grouping.revert&quot;),
              sort: Tent.I18n.loc(&quot;tent.sorting.main&quot;),
              ascending: Tent.I18n.loc(&quot;tent.sorting.ascending&quot;),
              descending: Tent.I18n.loc(&quot;tent.sorting.descending&quot;),
              group: Tent.I18n.loc(&quot;tent.grouping._groupBy&quot;),
              rename: Tent.I18n.loc(&quot;tent.rename.main&quot;)
            };
            columnDivId = '#jqgh_' + this.get('elementId') + '_jqgrid_' + column.name;
            this.$(columnDivId).addClass('dropdown');
            $(columnDivId + ' .title').after(template(context));
            $(columnDivId + ' .title').addClass('has-dropdown').attr('data-toggle', 'dropdown').append('&lt;span class=&quot;dropdown-mask&quot;&gt;&lt;i class=&quot;icon-chevron-down&quot;&gt;&lt;/i&gt;&lt;/span&gt;');
          }
        }
        this.leftAlignLastDropdown();
        this.groupByColumnBindings();
        this.renameColumnHeaderBindings();
        return this.sortingBindings();
      }
    },
    toggleColumnDropdown: function(columnField) {
      var columnDivId;
      columnDivId = '#jqgh_' + this.get('elementId') + '_jqgrid_' + columnField;
      return $(columnDivId + ' .title').dropdown('toggle');
    },
    leftAlignLastDropdown: function() {
      var table, tableRight;
      if (this.$('.ui-jqgrid-htable').length &gt; 0) {
        this.$('.column-dropdown .dropdown-submenu').removeClass('pull-left');
        this.$('.ui-th-column: .column-dropdown').removeClass('last');
        table = this.$('.ui-jqgrid-htable');
        tableRight = $(window).width() - (table.offset().left + table.outerWidth());
        return this.$('.ui-th-column:visible').each(function() {
          var columnLeft;
          columnLeft = $(window).width() - $(this).offset().left;
          if ((columnLeft - 250) &lt; tableRight) {
            $('.dropdown-submenu', $(this)).addClass('pull-left');
          }
          if ((columnLeft - 120) &lt; tableRight) {
            return $('.column-dropdown', $(this)).addClass('last');
          }
        });
      }
    },
    sortingBindings: function() {
      var widget;
      widget = this;
      this.$('.dropdown-menu .sort .ascending').click(function(e) {
        var target;
        target = $(e.target);
        return widget.findAscendingButton(target).click();
      });
      return this.$('.dropdown-menu .sort .descending').click(function(e) {
        var target;
        target = $(e.target);
        return widget.findDescendingButton(target).click();
      });
    },
    findAscendingButton: function(target) {
      return target.parents('.ui-th-column:first').find('.ui-icon-asc').eq(0);
    },
    findDescendingButton: function(target) {
      return target.parents('.ui-th-column:first').find('.ui-icon-desc').eq(0);
    },
    groupByColumnBindings: function() {
      var widget;
      widget = this;
      return this.$('.group.dropdown-submenu').click(function(e) {
        var column, groupType, target;
        target = $(e.target);
        groupType = target.attr('data-grouptype') || target.parents('li[data-grouptype]:first').attr('data-grouptype');
        column = target.attr('data-column') || target.parents('ul.column-dropdown:first').attr('data-column');
        return widget.newGroupSelected(groupType, column);
      });
    },
    renameColumnHeaderBindings: function() {
      var widget;
      widget = this;
      this.$('.rename.dropdown-submenu').hover(function(e) {
        return $('input', this).focus();
      }).click(function(e) {
        var target;
        target = $(e.target);
        e.stopPropagation();
        return e.preventDefault();
      });
      this.$('.rename.dropdown-submenu input').bind('keyup', (function(e) {
        var columnField, dropdownMenu, lastTitle, target;
        target = $(e.target);
        dropdownMenu = target.parents('ul.column-dropdown:first');
        columnField = dropdownMenu.attr('data-column');
        if (e.keyCode === 13) {
          return widget.renameColumnHeader(columnField, $(this).val(), dropdownMenu);
        } else if (e.keyCode === 27) {
          lastTitle = dropdownMenu.attr('data-last-title');
          widget.renameGridColumnHeader(columnField, lastTitle);
          $(this).val(lastTitle);
          widget.toggleColumnDropdown(columnField);
          e.preventDefault();
          return e.stopPropagation();
        }
      }));
      return this.$('.rename.dropdown-submenu .revert').click(function(e) {
        var columnField, dropdownMenu, originalTitle, target;
        target = $(e.target);
        dropdownMenu = target.parents('ul.column-dropdown:first');
        columnField = dropdownMenu.attr('data-column');
        originalTitle = dropdownMenu.attr('data-orig-title');
        widget.renameColumnHeader(columnField, originalTitle, dropdownMenu);
        return $('.rename.dropdown-submenu input', dropdownMenu).val(originalTitle);
      });
    },
    renameColumnHeader: function(columnField, value, dropdownMenu) {
      this.toggleColumnDropdown(columnField);
      this.renameGridColumnHeader(columnField, value);
      if (this.get('columnInfo.titles')) {
        this.set('columnInfo.titles.' + columnField, value);
      }
      return dropdownMenu.attr('data-last-title', value);
    },
    renameGridColumnHeader: function(colname, value) {
      var column, _i, _len, _ref;
      if (value === &quot;&quot;) {
        value = &quot; &quot;;
      }
      this.getTableDom().jqGrid('setLabel', colname, value);
      _ref = this.get('columnModel');
      for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
        column = _ref[_i];
        if (column.name === colname) {
          column.title = value;
        }
      }
      return this.columnsDidChange();
    }
  });

}).call(this);



<span id='Tent-Grid-Maximize'>/**
</span>* @class Tent.Grid.Maximize
* Adds maximize/restore support to a grid
*/


(function() {

  Tent.Grid.Maximize = Ember.Mixin.create({
<span id='Tent-Grid-Maximize-property-showMaximizeButton'>    /**
</span>    	* @property {Boolean} showMaximizeButton Display a button at the top of the grid which presents
    	* a dialog to maximize the grid view.
    */

    showMaximizeButton: true,
    resizeGridSteps: true,
    resizeSpeed: 700,
    addNavigationBar: function() {
      return this.renderMaximizeButton();
    },
    renderMaximizeButton: function() {
      var widget;
      widget = this;
      if (this.get('showMaximizeButton')) {
        this.$(&quot;.grid-header&quot;).append('&lt;a class=&quot;maximize&quot;&gt;&lt;span class=&quot;ui-icon ui-icon-arrow-4-diag&quot;&gt;&lt;/span&gt; &lt;/a&gt;');
        return this.$('a.maximize').click(function() {
          return widget.toggleFullScreen(this);
        });
      }
    },
    toggleFullScreen: function(a) {
      var widget;
      widget = this;
      if (this.get('fullScreen')) {
        return this.restoreSize();
      } else {
        return this.maximize();
      }
    },
    maximize: function() {
      var newHeight, newWidth, widget,
        _this = this;
      widget = this;
      this.set('currentTop', this.$().offset().top - $(window).scrollTop());
      this.set('currentLeft', this.$().offset().left);
      this.set('currentWidth', this.$().outerWidth());
      this.set('currentHeight', this.$().outerHeight());
      this.set('currentRight', $(window).width() - (this.$().offset().left + this.$().outerWidth()));
      this.set('currentBottom', $(window).height() - (this.$().offset().top + this.$().outerHeight()));
      newWidth = $(window).width() - 60;
      newHeight = $(window).height() - 120;
      this.$().css('top', this.get('currentTop') + 'px');
      this.$().css('left', this.get('currentLeft') + 'px');
      this.$().css('height', this.get('currentHeight') + 'px');
      this.$().css('width', this.get('currentWidth') + 'px');
      this.$().css('z-index', '2050');
      this.$().css('position', 'fixed');
      this.$().addClass('dialog');
      if (!this.get('resizeGridSteps')) {
        this.hideGrid();
      }
      this.$('.jqgrid-backdrop').show();
      $('.jqgrid-backdrop').animate({
        opacity: '0.6'
      }, 200, function() {
        return _this.$().animate({
          width: newWidth + 'px',
          height: $(window).height() - 60 - _this.get('currentHeight') &gt; 60 ? 'auto' : newHeight + 'px',
          top: '60px',
          left: '30px',
          right: '30px',
          bottom: '60px'
        }, {
          duration: _this.get('resizeSpeed'),
          complete: function() {
            $('span', widget).removeClass('ui-icon-arrow-4-diag');
            $('span', widget).addClass('ui-icon-arrow-1-se');
            _this.set('fullScreen', true);
            _this.resizeToContainer();
            if (!_this.get('resizeGridSteps')) {
              return _this.showGrid();
            }
          },
          step: function() {
            return _this.resizeToContainer();
          }
        });
      });
      this.set('resizeEscapeHandler', this.get('generateResizeEscapeHandler')(this));
      return $('body').bind('keyup click', this.get('resizeEscapeHandler'));
    },
    restoreSize: function() {
      var _this = this;
      $('body').unbind('keyup click', this.get('resizeEscapeHandler'));
      if (!this.get('resizeGridSteps')) {
        this.hideGrid();
      }
      return this.$().animate({
        width: this.get('currentWidth') + 'px',
        height: this.get('currentHeight') + 'px',
        top: this.get('currentTop') + 'px',
        left: this.get('currentLeft') + 'px',
        right: this.get('currentRight') + 'px',
        bottom: this.get('currentBottom') + 'px'
      }, {
        duration: this.get('resizeSpeed'),
        complete: function() {
          _this.$('.maximize &gt; span').removeClass('ui-icon-arrow-1-se');
          _this.$('.maximize &gt; span').addClass('ui-icon-arrow-4-diag');
          _this.set('fullScreen', false);
          _this.$().css('height', '');
          _this.$().css('width', '');
          _this.resizeToContainer();
          _this.$().removeClass('dialog');
          if (!_this.get('resizeGridSteps')) {
            _this.showGrid();
          }
          return _this.removeBackdrop();
        },
        step: function() {
          return _this.resizeToContainer();
        }
      });
    },
    removeBackdrop: function() {
      var _this = this;
      return this.$('.jqgrid-backdrop').animate({
        opacity: '0.0'
      }, 900, function() {
        _this.$('.jqgrid-backdrop').hide();
        return _this.$().css('position', 'static');
      });
    },
    generateResizeEscapeHandler: function(widget) {
      return function(e) {
        if (e.keyCode === 27 || ($(e.target).attr('id') === 'jqgrid-backdrop')) {
          widget.toggleFullScreen();
        }
      };
    }
  });

}).call(this);


(function() {

  Tent.Grid.HorizontalScrollSupport = Ember.Mixin.create({
<span id='Tent-Grid-Maximize-property-horizontalScrolling'>    /**
</span>    	* @property {Boolean} horizontalScrolling Allow the grid content to scroll horizontally.
    	* This property defines whether the grid content will be forced to fit within the area assiged to the grid (false), 
    	* or whether the columns will disregard the grid width. The actual column widths will be the greater of the column 
    	* title width and the column content
    */

    horizontalScrolling: false,
    isHorizontalScrolling: false,
    gridDidRender: function() {
      return this.modifyGridForAutofit();
    },
    toggleActive: function(component) {
      component = component || this.$('.horizontal-scroll-button');
      if (this.get('horizontalScrolling')) {
        return component.removeClass('active');
      } else {
        return component.addClass('active');
      }
    },
    horizontalScrollingDidChange: (function() {
      return this.modifyGridForAutofit();
    }).observes('horizontalScrolling'),
    modifyGridForAutofit: function() {
      if (this.get('horizontalScrolling')) {
        if (!this.get('isHorizontalScrolling')) {
          return this.addHorizontalScroll();
        }
      } else {
        if (this.get('isHorizontalScrolling')) {
          return this.removeHorizontalScroll();
        }
      }
    },
    addHorizontalScroll: function() {
      this.set('isHorizontalScrolling', true);
      this.getTableDom().get(0).p.forceFit = false;
      this.getTableDom().get(0).p.shrinkToFit = false;
      this.moveHeaderAboveViewDiv();
      this.updateGrid();
      return this.adjustHeight();
    },
    removeHorizontalScroll: function() {
      this.set('isHorizontalScrolling', false);
      this.getTableDom().get(0).p.forceFit = true;
      this.getTableDom().get(0).p.shrinkToFit = true;
      this.revertHeaderIntoViewDiv();
      this.updateGrid();
      return this.adjustHeight();
    },
    moveHeaderAboveViewDiv: function() {
      var hdiv, view;
      hdiv = $('.ui-jqgrid-hdiv', this.$());
      view = $('.ui-jqgrid-view', this.$());
      hdiv.detach();
      view.before(hdiv);
      return view.scroll(function(event) {
        return hdiv.css(&quot;margin-left&quot;, &quot;-&quot; + view.scrollLeft() + 'px');
      });
    },
    revertHeaderIntoViewDiv: function() {
      var bdiv, hdiv, view;
      hdiv = $('.ui-jqgrid-hdiv', this.$());
      view = $('.ui-jqgrid-view', this.$());
      bdiv = $('.ui-jqgrid-bdiv', this.$());
      hdiv.detach();
      bdiv.before(hdiv);
      hdiv.css(&quot;margin-left&quot;, &quot;0px&quot;);
      return view.unbind('scroll');
    },
    setHeaderWidths: function() {
      var firstRowOfGrid, jqGridCols,
        _this = this;
      if (this.get('horizontalScrolling')) {
        firstRowOfGrid = this.$('.jqgfirstrow td');
        jqGridCols = this.getTableDom()[0].p.colModel;
        this.$('.ui-jqgrid-htable th').each(function(index, col) {
          var finalWidth;
          finalWidth = _this.calculateColumnWidth(index, col, firstRowOfGrid);
          _this.changeColumnWidth(index, col, finalWidth, firstRowOfGrid, jqGridCols);
          return _this.changeFooterWidth(index, finalWidth);
        });
        if (this.get('footerRow')) {
          return this.getTableDom()[0].grid.sDiv.style.width = &quot;auto&quot;;
        }
      }
    },
    calculateColumnWidth: function(index, col, firstRowOfGrid) {
      var widthBasedOnContent, widthBasedOnHeader;
      widthBasedOnHeader = this.calculateHeaderColumnWidth(index, col);
      widthBasedOnContent = this.calculateWidthBasedOnContent(index, firstRowOfGrid);
      if (widthBasedOnContent &gt; widthBasedOnHeader) {
        return widthBasedOnContent;
      } else {
        return widthBasedOnHeader;
      }
    },
    changeColumnWidth: function(index, col, finalWidth, firstRowOfGrid, jqGridCols) {
      firstRowOfGrid.eq(index).css('width', finalWidth).css('min-width', finalWidth);
      $(col).css('width', finalWidth);
      return jqGridCols[index].width = finalWidth;
    },
    calculateHeaderColumnWidth: function(index, col) {
      var column;
      if (this.get('multiSelect') &amp;&amp; index === 0) {
        return $(col).width();
      } else {
        column = this.get('columnModel')[index - (this.get('multiSelect') ? 1 : 0)];
        if (column != null) {
          return column.title.length * 10;
        } else {
          return 80;
        }
      }
    },
    calculateWidthBasedOnContent: function(index, firstRowOfGrid) {
      var widthBasedOnContent;
      if (this.get('groupingInfo.columnName') != null) {
        return widthBasedOnContent = firstRowOfGrid.eq(index).width();
      } else {
        return widthBasedOnContent = firstRowOfGrid.eq(index).outerWidth();
      }
    },
    changeFooterWidth: function(index, finalWidth) {
      var footers;
      if (this.get('footerRow')) {
        footers = this.getTableDom()[0].grid.footers;
        return footers[index].style.width = finalWidth + 'px';
      }
    }
  });

}).call(this);


(function() {
<span id='Tent-JqGrid'>/**
</span>  * @class Tent.JqGrid
  * @mixins Tent.ValidationSupport
  * @mixins Tent.MandatorySupport
  * @mixins Tent.Grid.CollectionSupport
  * @mixins Tent.Grid.SelectionSupport
  * @mixins Tent.Grid.Adapters
  * @mixins Tent.Grid.ExportSupport
  * @mixins Tent.Grid.EditableSupport
  * @mixins Tent.Grid.GroupingSupport
  * @mixins Tent.Grid.ColumnChooserSupport
  * @mixins Tent.Grid.ColumnMenu
  * @mixins Tent.Grid.Maximize
  * @mixins Tent.Grid.HorizontalScrollSupport
  * 
  *
  * Create a jqGrid view which displays the data provided by its content property
  *
  * ##Usage
  *		{{view Tent.JqGrid
                    label=&quot;Tasks&quot;
                    collectionBinding=&quot;Pad.collection&quot;
                    selectionBinding=&quot;Pad.selectedTasks&quot;
                    multiSelect=true             
                }}
  *
  * - collection: A collection representing an array of records, one for each row of the grid.
  * - selection: An array of selected objects. This will provide the initial selections, as well as 
  * contain the items selected from the grid.
  *
  * The content of the grid will be bound to the collection.
  * The columns for the grid will be bound to collection.columnsDescriptor
  */


  Tent.JqGrid = Ember.View.extend(Tent.ValidationSupport, Tent.MandatorySupport, Tent.Grid.Maximize, Tent.Grid.CollectionSupport, Tent.Grid.SelectionSupport, Tent.Grid.Adapters, Tent.Grid.HorizontalScrollSupport, Tent.Grid.ColumnChooserSupport, Tent.Grid.ExportSupport, Tent.Grid.EditableSupport, Tent.Grid.ColumnMenu, Tent.Grid.GroupingSupport, {
    templateName: 'jqgrid',
    classNames: ['tent-jqgrid'],
    classNameBindings: ['fixedHeader', 'hasErrors:error', 'paged', 'horizontalScrolling'],
<span id='Tent-JqGrid-property-title'>    /**
</span>    	* @property {String} title The title caption to appear above the table
    */

    title: null,
<span id='Tent-JqGrid-property-multiSelect'>    /**
</span>    	* @property {Boolean} multiSelect Boolean indicating that the list is a multi-select list
    */

    multiSelect: false,
<span id='Tent-JqGrid-property-fixedHeader'>    /**
</span>    	* @property {Boolean} fixedHeader Boolean indicating that the header remains in view when the content is scrolled.
    */

    fixedHeader: false,
<span id='Tent-JqGrid-property-filtering'>    /**
</span>    	* @property {Boolean} filtering A boolean to indicate that the grid can be filtered.
    */

    filtering: false,
<span id='Tent-JqGrid-property-grouping'>    /**
</span>    	* @property {Boolean} grouping A boolean to indicate that the grid can be grouped.
    */

    grouping: true,
<span id='Tent-JqGrid-property-groupField'>    /**
</span>    	* @property {String} groupField The name of the field by which to group the grid
    */

    groupField: null,
<span id='Tent-JqGrid-property-clearAction'>    /** 
</span>    	* @property {Boolean} clearAction Set this property to true to deselect all the selected items and restore all the editable fields.
    */

    clearAction: null,
    fullScreen: false,
<span id='Tent-JqGrid-property-footerRow'>    /**
</span>    	 * @property {Boolean} footerRow Displays a row at the foot of the table for summary information
    */

    footerRow: false,
<span id='Tent-JqGrid-property-fixedRowsCount'>    /**
</span>    	 * @property {Integer} fixedRowsCount Displays rows count at the foot of the table for summary information
    */

    fixedRowsCount: 1,
<span id='Tent-JqGrid-property-content'>    /**
</span>    	* @property {Array} content The array of items to display in the grid.
    	* By default this will be retrieved from the collection, if provided
    */

    contentBinding: 'collection',
<span id='Tent-JqGrid-property-columns'>    /**
</span>    	* @property {Array} columns The array of column descriptors used to represent the data. 
    	* By default this will be retrieved from the collection, if provided
    */

<span id='Tent-JqGrid-property-selection'>    /**
</span>    	* @property {Array} selection The array of items selected in the list. This can be used as a setter
    	* and a getter.
    */

    selection: [],
    init: function() {
      return this._super();
    },
    valueForMandatoryValidation: (function() {
      return this.get('selection');
    }).property('selection'),
    focus: function() {
      return this.getTableDom().focus();
    },
    didInsertElement: function() {
      var widget;
      this._super();
      widget = this;
      $.subscribe(&quot;/ui/refresh&quot;, function() {
        widget.resizeToContainer();
        if (widget.$() != null) {
          return widget.columnsDidChange();
        }
      });
      $.subscribe(&quot;/window/resize&quot;, function() {
        return widget.resizeToContainer();
      });
      this.setupDomIDs();
      this.bindHeaderView();
      return this.drawGrid();
    },
    bindHeaderView: function() {
      return this.getHeaderView().set('grid', this);
    },
    getHeaderView: function() {
      return Ember.View.views[this.$('.grid-header').attr('id')];
    },
    drawGrid: function() {
      this.setupColumnTitleProperties();
      this.setupColumnWidthProperties();
      this.setupColumnVisibilityProperties();
      this.buildGrid();
      this.gridDataDidChange();
      this.addNavigationBar();
      this.setupColumnGroupingProperties();
      this.setupColumnOrderingProperties();
      return this.gridDidRender();
    },
    applyStoredPropertiesToGrid: function() {
      if (this.get('collection.personalizable')) {
        this.set('columnModel', {});
        this.setupColumnTitleProperties();
        this.setupColumnWidthProperties();
        this.setupColumnVisibilityProperties();
        this.clearAllGrouping();
        this.getTableDom().GridUnload();
        this.buildGrid();
        this.setupColumnGroupingProperties();
        this.setupColumnOrderingProperties();
        return this.gridDidRender();
      }
    },
    willDestroyElement: function() {
      if (this.get('fullScreen')) {
        this.removeBackdrop();
      }
      return this.getTableDom().GridDestroy();
    },
    setupDomIDs: function() {
      this.set('tableId', this.get('elementId') + '_jqgrid');
      this.$('.grid-table').attr('id', this.get('tableId'));
      return this.$('.gridpager').attr('id', this.get('elementId') + '_pager');
    },
    getTableDom: function() {
      return this.$('#' + this.get('tableId'));
    },
    getTopPagerId: function() {
      return '#' + this.get('tableId') + '_toppager_left';
    },
    getPagerId: function() {
      return '#' + this.get('elementId') + '_pager';
    },
    getColModel: function() {
      return this.getTableDom().getGridParam('colModel');
    },
    buildGrid: function() {
      var widget,
        _this = this;
      widget = this;
      this.getTableDom().jqGrid({
        parentView: widget,
        datatype: function(postdata) {
          return widget.onPageOrSort(postdata);
        },
        height: this.get('height') || 'auto',
        colNames: this.get('colNames'),
        colModel: this.get('columnModel'),
        multiselect: this.get('multiSelect'),
        caption: this.get('title') != null ? Tent.I18n.loc(this.get('title')) : void 0,
        autowidth: this.get('horizontalScrolling') ? false : true,
        sortable: {
          update: function(permutation) {
            return _this.columnsDidChange();
          }
        },
        resizeStop: function(width, index) {
          _this.columnsDidChange(index);
          return _this.storeColumnDataToCollection();
        },
        loadComplete: widget.get('content.isLoaded'),
        loadtext: '&lt;div class=&quot;wait&quot;&gt;&lt;i class=&quot;icon-spinner icon-spin icon-2x&quot;&gt;&lt;/i&gt;&lt;/div&gt;',
        forceFit: true,
        shrinkToFit: this.get('horizontalScrolling') ? false : true,
        viewsortcols: [true, 'vertical', false],
        hidegrid: false,
        viewrecords: true,
        rowNum: this.get('paged') ? this.get('pagingInfo.pageSize') : -1,
        gridview: true,
        toppager: false,
        cloneToTop: false,
        editurl: 'clientArray',
        pager: this.get('paged') ? this.getPagerId() : void 0,
        toolbar: [false, &quot;top&quot;],
        grouping: this.get('grouping'),
        footerrow: this.get('footerRow'),
        userDataOnFooter: true,
        onSelectRow: function(itemId, status, e) {
          return widget.didSelectRow(itemId, status, e);
        },
        onSelectGroup: function(itemId, status, e) {
          return widget.didSelectGroup(itemId, status, e);
        },
        onSelectAll: function(rowIds, status) {
          return widget.didSelectAll(rowIds, status);
        }
      });
      this.setInitialViewRecordsAttribute();
      this.addMarkupToHeaders();
      this.addColumnDropdowns();
      this.resizeToContainer();
      this.columnsDidChange();
      if (this.get('footerRow')) {
        $('tr.footrow').addClass('tent-jqgrid-footrow');
      }
      return this.getTableDom().bind('jqGridRemapColumns', function(e, permutation, updateCells, keepHeader) {
        if (keepHeader) {
          return _this.storeColumnOrderingToCollection(permutation);
        }
      });
    },
    setInitialViewRecordsAttribute: function() {
      /*
      	    * Set initial value of viewrecords to be false so that the text &quot;no records to view&quot; does not
      	    * appear when page is refreshed or is first visited, this was not possible in initial definition
      	    * of jqGrid as jqGrid never shows viewrecords if it is set false in first call to jqGrid
      */
      return this.getTableDom()[0].p.viewrecords = false;
    },
    getItemFromModel: function(id, colName) {
      var model, row, value, _i, _len, _ref;
      if (colName != null) {
        row = this.get('content').toArray().find(function(item) {
          if (Number(id) === Number(item.get('id'))) {
            return item;
          }
        });
        id = row.get(colName);
      }
      _ref = this.get('content').toArray();
      for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
        model = _ref[_i];
        value = colName != null ? model.get(colName) : model.get('id');
        if ((&quot;&quot; + value) === (&quot;&quot; + id)) {
          return model;
        }
      }
    },
    markErrorCell: function(rowId, iCell) {
      return this.getCell(rowId, iCell).addClass('error');
    },
    unmarkErrorCell: function(rowId, iCell) {
      return this.getCell(rowId, iCell).removeClass('error');
    },
    getCell: function(rowId, iCell) {
      return this.getTableDom().find('#' + rowId).children().eq(iCell);
    },
<span id='Tent-JqGrid-method-sendAction'>    /**
</span>    	* @method sendAction send an action to the router. This is called from the 'action' formatter,
    	* which displays cell content as a link
    */

    sendAction: function(action, element, rowId, colName) {
      var view;
      view = this;
      while (!view.get('controller') &amp;&amp; (view.get('parentView') != null)) {
        view = view.get('parentView');
      }
      if (view.get('controller') != null) {
        if (this.get('parentView.controller.namespace.router') != null) {
          return view.get('controller.namespace.router').send(action, this.getItemFromModel(rowId, colName));
        }
      }
    },
    addMarkupToHeaders: function() {
      return this.$('.ui-th-column div').each(function() {
        return $(this).contents().filter(function() {
          return this.nodeType === 3;
        }).replaceWith($('&lt;span class=&quot;title&quot;&gt;' + $(this).text() + '&lt;/span&gt;'));
      });
    },
    addNavigationBar: function() {
      return this._super();
    },
    gridDidRender: function() {
      return this._super();
    },
    columnsDidChange: function(colChangedIndex) {
      this._super();
      this.adjustHeight();
      this.removeLastDragBar();
      return this.setHeaderWidths();
    },
    adjustHeight: function() {
      var bottom, top;
      if (this.get('fixedHeader')) {
        top = this.$('.ui-jqgrid-htable').height();
        bottom = (this.$('.ui-jqgrid-sdiv').height() + this.heightForPager()) || 0;
        if (this.get('horizontalScrolling')) {
          this.$('.ui-jqgrid-bdiv').css('top', 0);
        } else {
          this.$('.ui-jqgrid-bdiv').css('top', top);
        }
        this.$('.ui-jqgrid-view').css('bottom', bottom);
        if (Tent.Browsers.isIE()) {
          this.$('.ui-jqgrid-bdiv').css('height', 'auto');
        }
        if (!this.get('paged')) {
          if (this.get('horizontalScrolling')) {
            this.$('.ui-jqgrid-view').css('height', 'auto');
          } else {
            if (!Tent.Browsers.isIE()) {
              this.$('.ui-jqgrid-view').css('height', '100%');
            }
          }
        }
      } else {
        if (Tent.Browsers.isIE()) {
          this.$('.ui-jqgrid-bdiv').css('height', 'auto');
        }
      }
      return $.publish('/grid/height-changed');
    },
    heightForPager: function() {
      var _ref;
      return (_ref = this.$('.ui-jqgrid-pager')) != null ? _ref.height() : void 0;
    },
    removeLastDragBar: function() {
      this.$('.ui-th-column .ui-jqgrid-resize').show();
      return this.getLastColumn().find('.ui-jqgrid-resize').hide();
    },
    getLastColumn: function() {
      return this.$('.ui-th-column').filter(function() {
        return $(this).css('display') !== 'none';
      }).last();
    },
    resizeToContainer: function() {
      var bdiv, widthWithoutScrollbar;
      if (this.$() != null) {
        bdiv = this.$('.ui-jqgrid-bdiv');
        if (this.get('horizontalScrolling')) {
          this.$('.ui-jqgrid-view, .ui-jqgrid, .ui-jqgrid-pager, .ui-jqgrid-hdiv').css('width', '100%');
          bdiv.css('width', 'auto');
          this.$('.ui-jqgrid-bdiv &gt; div').css('position', 'static');
          return this.$('.ui-jqgrid-btable').css('margin-right', bdiv.get(0).offsetWidth - bdiv.get(0).clientWidth);
        } else {
          this.getTableDom().setGridWidth(this.$().innerWidth(), true);
          widthWithoutScrollbar = bdiv.get(0).clientWidth;
          return this.$('.ui-jqgrid-btable').width(widthWithoutScrollbar + 'px');
        }
      }
    },
    hideGrid: function() {
      this.$(&quot;.gridpager&quot;).hide();
      return this.$(&quot;.grid-table&quot;).hide();
    },
    showGrid: function() {
      this.$(&quot;.gridpager&quot;).show();
      return this.$(&quot;.grid-table&quot;).show();
    },
    showSpinner: (function() {
      if (this.get('content.isLoaded') || !(this.get('content.isLoaded') != null)) {
        return this.getTableDom()[0].endReq();
      } else {
        return this.getTableDom()[0].beginReq();
      }
    }).observes('content.isLoaded'),
    updatePagingForGroups: function(grid, data) {
      grid.p.lastpage = data.total;
      grid.p.page = this.get('collection.currentGroupPage');
      grid.p.reccount = data.rows.length;
      grid.p.records = data.records;
      if (this.get('content.isLoaded')) {
        grid.p.viewrecords = true;
      }
      return grid.updatepager(null, false);
    },
    getColumnTitle: function(columnName) {
      var col, _i, _len, _ref;
      _ref = this.get('columns');
      for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
        col = _ref[_i];
        if (col.name === columnName) {
          return Tent.I18n.loc(col.title);
        }
      }
      return columnName;
    },
    resetGrouping: function() {
      if (this.get('grouping')) {
        return this.getTableDom().groupingSetup();
      }
    },
    selectedIds: (function() {
      var id, item, sel, _i, _len, _ref;
      sel = [];
      if (this.get('selection') != null) {
        _ref = this.get('selection');
        for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
          item = _ref[_i];
          id = &quot;&quot; + item.get('id');
          sel.pushObject(id);
        }
      }
      return sel;
    }).property('selection.@each'),
    updateGrid: function(doValidation) {
      if (this.getTableDom() != null) {
        this.unHighlightAllRows();
        this.highlightRows();
        this.showEditableCells();
        this.setHeaderWidths();
        this.resizeToContainer();
      }
      if (doValidation) {
        this.validate();
      }
      return $.publish(&quot;/grid/rendered&quot;);
    },
    highlightRows: function() {
      var grid, item, table, _i, _len, _ref;
      table = this.getTableDom();
      if (table != null) {
        grid = table.get(0);
        _ref = this.get('selectedIds');
        for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
          item = _ref[_i];
          this.highlightRow(item, table);
        }
        return this.setSelectAllCheckbox(grid);
      }
    },
    isRowSelectedMultiSelect: function(id, grid) {
      return grid.p.selarrrow.contains(id);
    },
    isRowSelectedSingleSelect: function(id, grid) {
      return grid.p.selrow === id;
    },
    unHighlightAllRows: function() {
      var id, selectedIds, table, _i, _len, _ref, _results;
      table = this.getTableDom();
      selectedIds = this.get('selectedIds');
      _ref = table.getDataIDs();
      _results = [];
      for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
        id = _ref[_i];
        if (!selectedIds.contains(id)) {
          if (this.get('multiSelect')) {
            if (this.isRowSelectedMultiSelect(id, table.get(0))) {
              table.jqGrid('setSelection', id, false);
              _results.push(this.restoreRow(id, table));
            } else {
              _results.push(void 0);
            }
          } else {
            if (this.isRowSelectedSingleSelect(id, table.get(0))) {
              table.jqGrid('setSelection', id, false);
              _results.push(this.restoreRow(id, table));
            } else {
              _results.push(void 0);
            }
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    highlightRow: function(id, table) {
      table = table || this.getTableDom();
      if (table != null) {
        if (this.get('multiSelect')) {
          if (!this.isRowSelectedMultiSelect(id, table.get(0))) {
            table.jqGrid('setSelection', id, false);
            return this.editRow(id, table);
          }
        } else {
          if (!this.isRowSelectedSingleSelect(id, table.get(0))) {
            table.jqGrid('setSelection', id, false);
            return this.editRow(id, table);
          }
        }
      }
    },
    clearAllSelections: (function() {
      if (this.get(&quot;clearAction&quot;) &amp;&amp; (this.getTableDom() != null)) {
        this.set('selection', []);
        return this.set(&quot;clearAction&quot;, false);
      }
    }).observes(&quot;clearAction&quot;),
    setSelectAllCheckbox: function(grid) {
      if (grid != null) {
        if (this.allRowsAreSelected(grid)) {
          return grid.setHeadCheckBox(true);
        } else {
          return grid.setHeadCheckBox(false);
        }
      }
    },
    allRowsAreSelected: function(grid) {
      var allSelected, id, selectedIds, _i, _len, _ref;
      selectedIds = this.get('selectedIds');
      allSelected = true;
      _ref = $(grid).jqGrid('getDataIDs');
      for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
        id = _ref[_i];
        if (!selectedIds.contains(id)) {
          allSelected = false;
        }
      }
      return allSelected;
    }
  });

}).call(this);


Ember.TEMPLATES['jqgrid_header']=Ember.Handlebars.compile(&quot;&lt;div class=\&quot;btn-group header-buttons\&quot;&gt;\n\t{{view Tent.Grid.AutofitButton gridBinding=\&quot;view.parentView\&quot;}}\n\n  \t{{#if view.parentView.showExportButton}}\n    \t{{view view.exportView}}\n  \t{{/if}}\n\n  \t{{#if view.parentView.showColumnChooser}}\n\t\t{{view Tent.Grid.ColumnChooserButton gridBinding=\&quot;view.parentView\&quot;}}  \n\t{{/if}}\n&lt;/div&gt;\n\n{{#if view.parentView.collection}}\n\t{{#if view.parentView.filtering}}\n\t\t{{view Tent.CollectionFilter collectionBinding=\&quot;view.parentView.collection\&quot;}}\n\t{{/if}}\n{{/if}}\t&quot;);

Ember.TEMPLATES['jqgrid_export']=Ember.Handlebars.compile(&quot;&lt;a class=\&quot;\&quot; data-toggle=\&quot;dropdown\&quot; href=\&quot;#\&quot;&gt;\n  &lt;i class=\&quot;icon-share\&quot;&gt;&lt;/i&gt;Export\n&lt;/a&gt;\n&lt;ul class=\&quot;dropdown-menu\&quot;&gt;\n  &lt;li&gt;&lt;a {{action exportData \&quot;view.xls\&quot; target=\&quot;view\&quot;}} href=\&quot;#\&quot; class=\&quot;export-xls\&quot;&gt;{{loc tent.jqGrid.export.xls}}&lt;/a&gt;&lt;/li&gt;\n  &lt;li&gt;&lt;a {{action exportData \&quot;view.csv\&quot; target=\&quot;view\&quot;}} href=\&quot;#\&quot; class=\&quot;export-csv\&quot;&gt;{{loc tent.jqGrid.export.csv}}&lt;/a&gt;&lt;/li&gt;\n  &lt;!-- &lt;li&gt;&lt;a class=\&quot;export-xml\&quot;&gt;#{Tent.I18n.loc(\&quot;tent.jqGrid.export.xml\&quot;)}&lt;/a&gt;&lt;/li&gt; --&gt;\n  &lt;li class=\&quot;divider\&quot;&gt;&lt;/li&gt;\n  &lt;li class=\&quot;dropdown-submenu-left\&quot;&gt;\n    &lt;a href=\&quot;#\&quot;&gt;Delimiter&lt;/a&gt;\n    &lt;ul class=\&quot;dropdown-menu custom-export\&quot;&gt;\n      &lt;li&gt;\n        &lt;form class=\&quot;form-horizontal well\&quot; id=\&quot;customExportForm\&quot;&gt;\n          &lt;div class=\&quot;control-group\&quot;&gt;\n            &lt;label class=\&quot;control-label\&quot;&gt;Delimiter&lt;/label&gt;\n            &lt;div class=\&quot;controls\&quot;&gt;\n                &lt;select name=\&quot;delimiter\&quot; class=\&quot;input-small\&quot; id=\&quot;delimiter\&quot;&gt;\n                &lt;option value=\&quot;\&quot;&gt;{{loc tent.pleaseSelect}}&lt;/option&gt;\n                &lt;option value=\&quot;,\&quot; selected&gt;{{loc tent.jqGrid.export.comma}}&lt;/option&gt;\n                &lt;option value=\&quot;|\&quot;&gt;{{loc tent.jqGrid.export.pipe}}&lt;/option&gt;\n                &lt;option value=\&quot;;\&quot;&gt;{{loc tent.jqGrid.export.semicolon}}&lt;/option&gt;\n                &lt;option value=\&quot;:\&quot;&gt;{{loc tent.jqGrid.export.colon}}&lt;/option&gt;\n              &lt;/select&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div class=\&quot;control-group\&quot;&gt;\n            &lt;label class=\&quot;control-label\&quot;&gt;{{loc tent.jqGrid.export._or}}&lt;/label&gt;\n          &lt;/div&gt;\n          &lt;div class=\&quot;control-group\&quot;&gt;\n            &lt;label class=\&quot;control-label\&quot;&gt;{{loc tent.jqGrid.export.enterDelimiter}}&lt;/label&gt;\n            &lt;div class=\&quot;controls\&quot;&gt;\n              &lt;input type=\&quot;text\&quot; name=\&quot;customDelimiter\&quot; id=\&quot;customDelimiter\&quot;  maxlength=\&quot;1\&quot; class=\&quot;input-small\&quot;&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div class=\&quot;control-group\&quot;&gt;\n            &lt;label class=\&quot;control-label\&quot;&gt;{{loc tent.jqGrid.export.headers}}&lt;/label&gt;\n            &lt;div class=\&quot;controls\&quot;&gt;\n              &lt;label class=\&quot;radio inline\&quot;&gt;\n                &lt;input type=\&quot;radio\&quot; name=\&quot;columnHeaders\&quot; value=\&quot;true\&quot; checked&gt;{{loc tent.on}}\n              &lt;/label&gt;\n              &lt;label class=\&quot;radio inline\&quot;&gt;\n                &lt;input type=\&quot;radio\&quot; name=\&quot;columnHeaders\&quot; value=\&quot;false\&quot;&gt;{{loc tent.off}}\n              &lt;/label&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div class=\&quot;control-group\&quot;&gt;\n            &lt;label class=\&quot;control-label\&quot;&gt;{{loc tent.jqGrid.export.inclQuotes}}&lt;/label&gt;\n            &lt;div class=\&quot;controls\&quot;&gt;\n              &lt;label class=\&quot;radio inline\&quot;&gt;\n                &lt;input type=\&quot;radio\&quot; name=\&quot;includeQuotes\&quot; value=\&quot;true\&quot; checked&gt;{{loc tent.on}}\n              &lt;/label&gt;\n              &lt;label class=\&quot;radio inline\&quot;&gt;\n                &lt;input type=\&quot;radio\&quot; name=\&quot;includeQuotes\&quot; value=\&quot;false\&quot;&gt;{{loc tent.off}}\n              &lt;/label&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;div class=\&quot;control-group\&quot;&gt;\n            &lt;div class=\&quot;controls\&quot;&gt;\n              &lt;button type=\&quot;button\&quot; class=\&quot;btn\&quot;&gt;{{loc tent.jqGrid.export.export}}&lt;/button&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n\n        &lt;/form&gt;\n      &lt;/li&gt;\n    &lt;/ul&gt;\n  &lt;/li&gt;\n  &lt;li class=\&quot;divider\&quot;&gt;&lt;/li&gt;\n  &lt;li&gt;&lt;a {{action exportData \&quot;view.json\&quot; target=\&quot;view\&quot;}} href=\&quot;#\&quot; class=\&quot;export-json\&quot;&gt;\n    {{loc tent.jqGrid.export.json}}&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&quot;);

(function() {
Tent.JqGridHeaderView = Ember.View.extend({
    classNames: ['grid-header', 'ui-jqgrid-titlebar', 'ui-widget-header', 'ui-helper-clearfix'],
    templateName: 'jqgrid_header',
    exportView: Ember.View.extend({
      classNames: ['btn-group', 'export', 'jqgrid-title-button'],
      templateName: 'jqgrid_export',
      csv: 'csv',
      json: 'json',
      xls: 'xls',
      exportData: function(e) {
        var contentType, customHeaderString, customParams, grid, jsonUrlPart, personalizedData, ret, tableDom, url, visibleColumnString;
        contentType = e.context;
        grid = this.get('parentView.parentView');
        tableDom = grid.getTableDom();
        url = grid.getExportUrl(contentType);
        visibleColumnString = grid.getVisibleColumns().join(',');
        customHeaderString = grid.getVisibleColumns(true).join(',');
        customParams = {
          del: ',',
          columns: visibleColumnString,
          custom_headers: customHeaderString,
          headers: true
        };
        personalizedData = grid.getPersonalizedData(tableDom.getRowData(), customParams);
        if (contentType === 'json') {
          if (url != null) {
            jsonUrlPart = url.split('/').pop().split('?')[0];
            this.$('.export-json').attr('download', jsonUrlPart);
          }
          ret = '{ &quot;exportDate&quot;: &quot;' + grid.generateExportDate() + '&quot;,\n' + $.fn.xmlJsonClass.toJson(personalizedData, &quot;data&quot;, &quot;    &quot;, true) + '}';
          return grid.clientDownload(ret, contentType);
        }
        if (url != null) {
          return document.location.href = url;
        } else {
          ret = 'exportDate \n' + grid.generateExportDate() + '\n' + grid.exportCSV(personalizedData, customParams);
          return grid.clientDownload(ret, contentType);
        }
      },
      didInsertElement: function() {
        var grid, tableDom,
          _this = this;
        grid = this.get('parentView.parentView');
        tableDom = grid.getTableDom();
        this.$('#customExportForm').click(function(e) {
          return e.stopPropagation();
        });
        this.$('#customExportForm').find('button').click(function() {
          var arry, columnHeaders, customHeaderString, customParams, delimiter, extension, includeQuotes, personalizedData, ret, url, visibleColumnString;
          arry = _this.$('#customExportForm').serializeArray();
          extension = 'csv';
          delimiter = ',';
          columnHeaders = true;
          includeQuotes = true;
          $.each(arry, function(i, fd) {
            if (fd.name === 'delimiter' &amp;&amp; fd.value !== ',') {
              extension = 'txt';
              delimiter = fd.value;
            }
            if (fd.name === 'customDelimiter') {
              if (fd.value.length &gt; 0) {
                delimiter = fd.value;
              }
            }
            if (fd.name === 'columnHeaders') {
              columnHeaders = fd.value === &quot;true&quot; ? true : false;
            }
            if (fd.name === 'includeQuotes') {
              return includeQuotes = fd.value === &quot;true&quot; ? true : false;
            }
          });
          visibleColumnString = grid.getVisibleColumns().join(',');
          customHeaderString = grid.getVisibleColumns(true).join(',');
          customParams = {
            del: delimiter,
            headers: columnHeaders,
            quotes: includeQuotes,
            date: grid.generateExportDate(),
            columns: visibleColumnString,
            custom_headers: customHeaderString
          };
          url = grid.get('collection').getURL(extension, customParams);
          if (!url) {
            personalizedData = grid.getPersonalizedData(tableDom.getRowData(), customParams);
            ret = 'exportDate \n' + grid.generateExportDate() + '\n' + grid.exportCSV(personalizedData, customParams);
            return grid.clientDownload(ret, extension);
          } else {
            return document.location.href = grid.get('collection').getURL(extension, customParams);
          }
        });
        this.$('#delimiter').change(function() {
          if ($('#delimiter').val().length &gt; 0) {
            return $('#customDelimiter').val('');
          } else {
            if ($('#customDelimiter').val().length === 0) {
              return $('#delimiter').val(',');
            }
          }
        });
        return this.$('#customDelimiter').blur(function() {
          if ($('#customDelimiter').val().length &gt; 0) {
            return $('#delimiter').val('');
          } else {
            return $('#delimiter').val(',');
          }
        });
      }
    })
  });

}).call(this);



<span id='jqgrid-formatter-amount'>/**
</span>* @class jqgrid.formatter.amount Allows jsGrid cell content to be formatted as an amount
* This formatter should be added to a column descriptor as follows:
*       {id: &quot;some_id&quot;, ..., formatter: &quot;amount&quot;, formatoptions:{negative:true}}
*
* When 'negative' is set to true, then negative values will be displayed in different style to
* non-negative amounts (usually colored red).
*/


(function() {

  jQuery.extend($.fn.fmatter, {
    amount: function(cellvalue, options, cell) {
      var formattedVal;
      if ((!cellvalue) &amp;&amp; (cellvalue !== 0) &amp;&amp; (cell != null)) {
        cellvalue = $('input', cell).attr('value') || 0;
      }
      formattedVal = Tent.Formatting.amount.format(cellvalue);
      if ((options != null) &amp;&amp; (options.colModel.formatoptions != null) &amp;&amp; options.colModel.formatoptions.negative &amp;&amp; cellvalue &lt; 0) {
        return '&lt;span class=&quot;negative&quot;&gt;' + formattedVal + '&lt;/span&gt;';
      } else {
        return formattedVal;
      }
    }
  });

  jQuery.extend($.fn.fmatter.amount, {
    unformat: function(cellvalue, options, cell) {
      if ((!cellvalue) &amp;&amp; (cellvalue !== 0) &amp;&amp; (cell != null)) {
        cellvalue = $(&quot;input&quot;, cell).attr(&quot;value&quot;);
      }
      return Tent.Formatting.amount.unformat(cellvalue) || &quot;&quot;;
    }
  });

  jQuery.extend($.fn.fmatter.amount, {
    formatCell: function(cellvalue, options, cell) {
      var input;
      if (cell != null) {
        input = $('input', cell);
        cellvalue = $(&quot;input&quot;, cell).attr(&quot;value&quot;);
      }
      return input.val(Tent.Formatting.amount.format(cellvalue) || &quot;&quot;);
    }
  });

<span id='jqgrid-formatter-number'>  /**
</span>  * @class jqgrid.formatter.number Allows jsGrid cell content to be formatted as a number
  * This formatter should be added to a column descriptor as follows:
  *       {id: &quot;some_id&quot;, ..., formatter: &quot;number&quot;, formatoptions:{negative:true}}
  *
  * When 'negative' is set to true, then negative values will be displayed in different style to
  * non-negative numbers (usually colored red).
  */


  jQuery.extend($.fn.fmatter, {
    number: function(cellvalue, options, cell) {
      var formattedVal;
      if ((!cellvalue) &amp;&amp; (cellvalue !== 0) &amp;&amp; (cell != null)) {
        cellvalue = $('input', cell).attr('value') || 0;
      }
      formattedVal = Tent.Formatting.number.format(cellvalue);
      if ((options != null) &amp;&amp; (options.colModel.formatoptions != null) &amp;&amp; options.colModel.formatoptions.negative &amp;&amp; cellvalue &lt; 0) {
        return '&lt;span class=&quot;negative&quot;&gt;' + formattedVal + '&lt;/span&gt;';
      } else {
        return formattedVal;
      }
    }
  });

  jQuery.extend($.fn.fmatter.number, {
    unformat: function(cellvalue, options, cell) {
      if ((!cellvalue) &amp;&amp; (cellvalue !== 0) &amp;&amp; (cell != null)) {
        cellvalue = $('input', cell).attr('value');
      }
      return Tent.Formatting.number.unformat(cellvalue) || &quot;&quot;;
    }
  });

<span id='jqgrid-formatter-percent'>  /**
</span>  * @class jqgrid.formatter.percent Allows jsGrid cell content to be formatted as a percentage value
  * This formatter should be added to a column descriptor as follows:
  *       {id: &quot;some_id&quot;, ..., formatter: &quot;percent&quot;}
  */


  jQuery.extend($.fn.fmatter, {
    percent: function(cellvalue, opts, cell) {
      if ((!cellvalue) &amp;&amp; (cellvalue !== 0) &amp;&amp; (cell != null)) {
        cellvalue = $('input', cell).attr('value') || 0;
      }
      return Tent.Formatting.percent.format(cellvalue);
    }
  });

  jQuery.extend($.fn.fmatter.percent, {
    unformat: function(cellvalue, options, cell) {
      if ((!cellvalue) &amp;&amp; (cellvalue !== 0) &amp;&amp; (cell != null)) {
        cellvalue = $('input', cell).attr('value');
      }
      return Tent.Formatting.percent.unformat(cellvalue) || &quot;&quot;;
    }
  });

  jQuery.extend($.fn.fmatter.percent, {
    formatCell: function(cellvalue, options, cell) {
      var input;
      if (cell != null) {
        input = $('input', cell);
        cellvalue = input.attr('value');
        return input.val(Tent.Formatting.percent.format(cellvalue) || &quot;&quot;);
      }
    }
  });

<span id='jqgrid-formatter-date'>  /**
</span>  * @class jqgrid.formatter.date Allows jsGrid cell content to be formatted as date values
  * This formatter should be added to a column descriptor as follows (dateFormat is optional):
  *       {id: &quot;some_id&quot;, ..., formatter: &quot;date&quot;, formatoptions:{dateFormat: &quot;dd-M-yy&quot;}}
  */


  jQuery.extend($.fn.fmatter, {
    date: function(cellvalue, options, rowdata) {
      if (options.colModel.formatoptions) {
        return Tent.Formatting.date.format(cellvalue, options.colModel.formatoptions.dateFormat);
      } else {
        return Tent.Formatting.date.format(cellvalue);
      }
    }
  });

  jQuery.extend($.fn.fmatter.date, {
    unformat: function(cellvalue, options) {
      return Tent.Formatting.date.unformat(cellvalue);
    }
  });

<span id='jqgrid-formatter-action'>  /**
</span>  * @class jqgrid.formatter.action Allows jsGrid cell content to be treated as a link.
  * This formatter should be added to a column descriptor as follows (redirectColumn is optional):
  *       {id: &quot;some_id&quot;, ..., formatter: &quot;action&quot;, .formatoptions({action: 'showNewRoute', redirectColumn: 'columnName'})
  * If no column name is supplied, it will redirect to 'newRoute' with context as data of the clicked row. The clicked row is 
  * searched on the basis of field 'id' in the data hash by comparing it against the clicked row Id.
  * If a column name is passed with in the format options, instead of rowId, value of the given column on the clicked row is compared
  * against the column value in the grid data.
  * This speacial redirectColumn option is required, for complicated data such that, data with single id needs to be shown
  * in different rows, with certain different column values, in that case, the 'id' for all the rows would be different
  * to meet ember data needs but the actual id for that data should be stored in some other column, so that 
  * appropriate processing and redirection can be done.
  */


  jQuery.extend($.fn.fmatter, {
    action: function(cellvalue, options, rowdata) {
      if (cellvalue) {
        if (options.colModel.formatoptions.redirectColumn != null) {
          return '&lt;a onclick=&quot;Ember.View.views[$(this).parents(\'.tent-jqgrid\').attr(\'id\')].sendAction(\'' + options.colModel.formatoptions.action + '\', this, \'' + options.rowId + '\',\'' + options.colModel.formatoptions.redirectColumn + '\')&quot;&gt;' + cellvalue + '&lt;/a&gt;';
        } else {
          return '&lt;a onclick=&quot;Ember.View.views[$(this).parents(\'.tent-jqgrid\').attr(\'id\')].sendAction(\'' + options.colModel.formatoptions.action + '\', this, \'' + options.rowId + '\')&quot;&gt;' + cellvalue + '&lt;/a&gt;';
        }
      }
    }
  });

<span id='jqgrid-formatter-checkboxEdit'>  /**
</span>  * @class jqgrid.formatter.checkboxEdit Allows jsGrid boolean cell content to be displayed as a checkbox
  * This formatter should be added to a column descriptor as follows:
  *       {id: &quot;some_id&quot;, ..., formatter: &quot;checkboxEdit&quot;}
  */


  jQuery.extend($.fn.fmatter, {
    checkboxEdit: function(cval, opts) {
      var bchk, op;
      op = $.extend({}, opts.checkbox);
      if (opts.colModel !== void 0 &amp;&amp; !$.fmatter.isUndefined(opts.colModel.formatoptions)) {
        op = $.extend({}, op, opts.colModel.formatoptions);
      }
      if ($.fmatter.isEmpty(cval) || $.fmatter.isUndefined(cval)) {
        cval = $.fn.fmatter.defaultFormat(cval, op);
      }
      cval = cval + &quot;&quot;;
      cval = cval.toLowerCase();
      bchk = cval.search(/(false|0|no|off)/i) &lt; 0 ? &quot; checked='checked' &quot; : &quot;&quot;;
      return '&lt;input type=&quot;checkbox&quot; ' + bchk + ' value=&quot;' + cval + '&quot; offval=&quot;no&quot; data-formatter=&quot;checkboxEdit&quot; onchange=&quot;Ember.View.views[$(this).parents(\'.tent-jqgrid\').attr(\'id\')].saveEditableCell(this)&quot;/&gt;';
    }
  });

  jQuery.extend($.fn.fmatter.checkboxEdit, {
    unformat: function(cellvalue, options, cell) {
      return $('input', cell).is(':checked');
    }
  });

<span id='jqgrid-formatter-selectEdit'>  /**
</span>  * @class jqgrid.formatter.selectEdit Allows jsGrid cell content to be selected from a select box dropdown
  * This formatter should be added to a column descriptor as follows:
  *       {id: &quot;some_id&quot;, ..., formatter: &quot;selectEdit&quot;, editoptions:{value: {1:'One',2:'Two',3:'Three'}}}
  */


  jQuery.extend($.fn.fmatter, {
    selectEdit: function(cval, opts) {
      var el, options, selected, text, val;
      options = opts.colModel.editoptions.value;
      if (options != null) {
        el = '&lt;select data-formatter=&quot;selectEdit&quot; onchange=&quot;Ember.View.views[$(this).parents(\'.tent-jqgrid\').attr(\'id\')].saveEditableCell(this)&quot; &gt;';
        for (val in options) {
          text = options[val];
          selected = val === cval ? 'selected=&quot;selected&quot;' : &quot;&quot;;
          el += (&quot;&lt;option value=\&quot;&quot; + val + &quot;\&quot; &quot; + selected + &quot;&gt;&quot;) + text;
        }
        el += '&lt;/select&gt;';
      }
      return el;
    }
  });

  jQuery.extend($.fn.fmatter.selectEdit, {
    unformat: function(cellvalue, options, cell) {
      return $('select', cell).val();
    }
  });

  Tent.JqGrid.Validators = Ember.Object.create({
    amount: function(value, colname) {
      var unformatted;
      unformatted = Tent.Formatting.amount.unformat(value);
      if (unformatted === 0 &amp;&amp; value !== 0) {
        return [false, Tent.Formatting.number.errorText()];
      } else {
        return [true];
      }
    }
  });

  Tent.JqGrid.editTypes = {
    'amount': 'text',
    'select': 'select',
    'checkbox': 'checkbox'
  };

  Tent.JqGrid.editOptions = {
    'amount': {
      dataInit: function(elem) {
        $(elem).css('text-align', 'right');
        return $(elem).keypress(function(event) {
          var charCode;
          charCode = (event.which ? event.which : event.keyCode);
          if (charCode !== 46 &amp;&amp; charCode &gt; 31 &amp;&amp; (charCode &lt; 48 || charCode &gt; 57)) {
            return false;
          } else {
            return true;
          }
        });
      },
      dataEvents: [
        {
          type: 'keyup',
          fn: function(e) {
            return Ember.View.views[$(this).parents('.tent-jqgrid').attr('id')].saveEditableCell(this);
          }
        }, {
          type: 'blur',
          fn: function(e) {
            return $(this).val(Tent.Formatting.amount.format($(this).val()));
          }
        }
      ]
    },
    'checkbox': {
      value: &quot;True:False&quot;,
      disabled: false
    }
  };

  Tent.JqGrid.editRules = {
    'amountEdit': {
      custom: true,
      custom_func: Tent.JqGrid.Validators.amount
    }
  };

}).call(this);



<span id='Tent-JqGrid-Grouping'>/**
</span>* @class Tent.JqGrid.Grouping
* Provides configuration options for grouping by column values and comparators for defining
* grouping ranges.
*
*/


(function() {

  Tent.JqGrid.Grouping = Ember.Object.extend();

<span id='Tent-JqGrid-Grouping-method-getComparator'>  /**
</span>  * @method getComparator returns a comparator to use for a combination of datatype and grouping type
  * @param {String} dataType the type of the column which is defining the grouping e.g. 'date'
  * @param {String} groupType the type of grouping to perform e.g. 'month'
  */


  Tent.JqGrid.Grouping.getComparator = function(dataType, groupType) {
    var comparator, type, _i, _len, _ref;
    comparator = this.ranges.get('default')().comparator;
    if (!(this.ranges.get(dataType) != null)) {
      dataType = &quot;string&quot;;
    }
    _ref = this.ranges.get(dataType)();
    for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
      type = _ref[_i];
      if (type.name === groupType) {
        if (type.comparator != null) {
          comparator = type.comparator;
        }
      }
    }
    return comparator;
  };

<span id='Tent-JqGrid-Grouping-comparator'>  /**
</span>  * @class Tent.JqGrid.Grouping.comparator
  * A base class for providing custom comparison functions for determining if values lie in a particular range.
  */


  Tent.JqGrid.Grouping.comparator = Ember.Object.extend({
<span id='Tent-JqGrid-Grouping-comparator-method-compare'>    /**
</span>    	* @method compare Test whether a value lies in the same range as another.
    	* @param {Object} firstValue The value defining the range to use in the test
    	* @param {Object} testValue The value to test
    	* @param {Boolean} The result of the test
    */

    compare: function(firstValue, testValue) {
      return firstValue === testValue;
    },
<span id='Tent-JqGrid-Grouping-comparator-method-rowTitle'>    /**
</span>    	* @method rowTitle Returns the text to display as the first interpolation of the group row text
    	* @param {Object} value the value which is used to determine the range
    */

    rowTitle: function(value, formatter) {
      if (value != null) {
        if (formatter != null) {
          return formatter(value);
        } else {
          return value;
        }
      } else {
        return '';
      }
    }
  });

  Tent.JqGrid.Grouping.helper = Ember.Object.create({
    numeric: {
      calculateName: function(value) {
        var _ref;
        return &quot;&quot; + (((_ref = Tent.Formatting.number.serializer) != null ? _ref.serialize(value) : void 0) || value);
      },
      rowTitle: function(value, formatter) {
        if (!(formatter != null)) {
          formatter = Tent.Formatting.number.format;
        }
        if (typeof value === &quot;string&quot;) {
          value = Tent.Formatting.number.unformat(value);
        }
        this.calculateRange(value);
        return formatter(this.get('lower')) + ' - ' + formatter(this.get('upper'));
      },
      compare: function(last, value) {
        this.calculateRange(last);
        return (this.get('lower') &lt;= value &amp;&amp; value &lt;= this.get('upper'));
      },
      calculateRange: function(range) {
        return function(value) {
          var lower, upper;
          if (value &gt;= 0) {
            lower = value - (value % range);
            upper = lower + (range - 1);
          } else {
            if (value % range === 0) {
              lower = value;
              upper = value + (range - 1);
            } else {
              upper = -1 + value - (value % range);
              lower = upper - (range - 1);
            }
          }
          this.set('lower', lower);
          return this.set('upper', upper);
        };
      }
    },
    amount: {
      rowTitle: function(value, formatter) {
        if (value != null) {
          if (formatter != null) {
            return formatter(value);
          } else {
            return Tent.Formatting.amount.format(value);
          }
        } else {
          return '';
        }
      },
      rangeRowTitle: function(value, formatter) {
        if (!(formatter != null)) {
          formatter = Tent.Formatting.amount.format;
        }
        if (typeof value === &quot;string&quot;) {
          value = Tent.Formatting.amount.unformat(value);
        }
        this.calculateRange(value);
        return formatter(this.get('lower')) + ' - ' + formatter(this.get('upper'));
      }
    }
  });

<span id='Tent-JqGrid-Grouping-comparator-property-Tent.JqGrid.Grouping.ranges'>  /**
</span>  * @property {Object} Tent.JqGrid.Grouping.ranges A collection of range definitions which provide titles, comparators etc for particular types
  */


  Tent.JqGrid.Grouping.ranges = Ember.Object.create({
    &quot;default&quot;: function() {
      return {
        name: 'exact',
        title: Tent.I18n.loc('tent.grouping.range.exact'),
        comparator: Tent.JqGrid.Grouping.comparator.create()
      };
    },
<span id='Tent-JqGrid-Grouping-ranges-date'>    /**
</span>    		* @class Tent.JqGrid.Grouping.ranges.date
    */

    date: function() {
      return [
        {
<span id='Tent-JqGrid-Grouping-ranges-date-property-exact'>          /**
</span>          					* @property {Object} exact group dates which are the same
          */

          name: 'exact',
          title: Tent.I18n.loc('tent.grouping.range.exact'),
          comparator: Tent.JqGrid.Grouping.comparator.create({
            compare: function(last, value) {
              return last.compareTo(value) === 0;
            }
          })
        }, {
<span id='Tent-JqGrid-Grouping-ranges-date-property-week'>          /**
</span>          					* @property {Object} week group dates which occur in the same week
          */

          name: 'week',
          title: Tent.I18n.loc('tent.grouping.range.week'),
          comparator: Tent.JqGrid.Grouping.comparator.create({
            compare: function(last, value) {
              if ((last.getFullYear() === value.getFullYear()) &amp;&amp; (last.getWeekOfYear() === value.getWeekOfYear())) {
                return true;
              }
              if (last.compareTo(value) === -1) {
                if ((last.getFullYear() + 1 === value.getFullYear()) &amp;&amp; (last.getWeekOfYear() === value.getWeekOfYear()) &amp;&amp; (last.getMonth() === 11) &amp;&amp; (value.getMonth() === 0)) {
                  return true;
                }
              }
              if (last.compareTo(value) === 1) {
                if ((last.getFullYear() - 1 === value.getFullYear()) &amp;&amp; (last.getWeekOfYear() === value.getWeekOfYear()) &amp;&amp; (last.getMonth() === 0) &amp;&amp; (value.getMonth() === 11)) {
                  return true;
                }
              }
            },
            rowTitle: function(value, formatter) {
              var week, yesterday;
              if (!(formatter != null)) {
                formatter = Tent.Formatting.date.format;
              }
              if (typeof value === &quot;string&quot;) {
                value = Tent.Formatting.date.unformat(value);
              }
              week = value.getWeekOfYear();
              yesterday = value.clone();
              while (week === yesterday.getWeekOfYear()) {
                yesterday.add(-1).day();
              }
              return &quot;&quot; + (Tent.I18n.loc('tent.grouping.range.weekStarting')) + &quot; &quot; + (formatter(yesterday.add(1).day()));
            }
          })
        }, {
<span id='Tent-JqGrid-Grouping-ranges-date-property-month'>          /**
</span>          					* @property {Object} month group dates which occur in the same month
          */

          name: 'month',
          title: Tent.I18n.loc('tent.grouping.range.month'),
          comparator: Tent.JqGrid.Grouping.comparator.create({
            compare: function(last, value) {
              return (last.getFullYear() === value.getFullYear()) &amp;&amp; (last.getMonth() === value.getMonth());
            },
            rowTitle: function(value) {
              if (typeof value === &quot;string&quot;) {
                value = Tent.Formatting.date.unformat(value);
              }
              return Tent.Formatting.date.format(value, 'MM') + ' ' + value.getFullYear();
            }
          })
        }, {
<span id='Tent-JqGrid-Grouping-ranges-date-property-quarter'>          /**
</span>          					* @property {Object} quarter group dates which occur in the same quarter
          */

          name: 'quarter',
          title: Tent.I18n.loc('tent.grouping.range.quarter'),
          comparator: Tent.JqGrid.Grouping.comparator.create({
            compare: function(last, value) {
              var quarter, _ref;
              quarter = Math.floor(last.getMonth() / 3) + 1;
              return (last.getFullYear() === value.getFullYear()) &amp;&amp; (((quarter - 1) * 3) &lt;= (_ref = value.getMonth()) &amp;&amp; _ref &lt;= ((quarter - 1) * 3) + 2);
            },
            rowTitle: function(value) {
              var quarter;
              if (typeof value === &quot;string&quot;) {
                value = Tent.Formatting.date.unformat(value);
              }
              quarter = Math.floor(value.getMonth() / 3) + 1;
              return 'Quarter ' + quarter + ', ' + value.getFullYear();
            }
          })
        }, {
<span id='Tent-JqGrid-Grouping-ranges-date-property-year'>          /**
</span>          					* @property {Object} year group dates which occur in the same year
          */

          name: 'year',
          title: Tent.I18n.loc('tent.grouping.range.year'),
          comparator: Tent.JqGrid.Grouping.comparator.create({
            compare: function(last, value) {
              return last.getFullYear() === value.getFullYear();
            },
            rowTitle: function(value) {
              if (typeof value === &quot;string&quot;) {
                value = Tent.Formatting.date.unformat(value);
              }
              return 'Year = ' + value.getFullYear();
            }
          })
        }
      ];
    },
<span id='Tent-JqGrid-Grouping-ranges-string'>    /**
</span>    		* @class Tent.JqGrid.Grouping.ranges.string
    */

    string: function() {
      return [
        {
<span id='Tent-JqGrid-Grouping-ranges-string-property-exact'>          /**
</span>          					* @property {Object} exact group string which are the same
          */

          name: 'exact',
          title: Tent.I18n.loc('tent.grouping.range.exact'),
          comparator: Tent.JqGrid.Grouping.comparator.create()
        }
      ];
    },
<span id='Tent-JqGrid-Grouping-ranges-number'>    /**
</span>    		* @class Tent.JqGrid.Grouping.ranges.number
    */

    number: function() {
      return [
        {
<span id='Tent-JqGrid-Grouping-ranges-number-property-exact'>          /**
</span>          					* @property {Object} exact group numbers which are the same
          */

          name: 'exact',
          title: Tent.I18n.loc('tent.grouping.range.exact'),
          comparator: Tent.JqGrid.Grouping.comparator.create()
        }, {
<span id='Tent-JqGrid-Grouping-ranges-number-property-10s'>          /**
</span>          					* @property {Object} 10s group numbers in ranges of ten
          */

          name: Tent.JqGrid.Grouping.helper.numeric.calculateName(10),
          title: Tent.I18n.loc('tent.grouping.range.tens'),
          comparator: Tent.JqGrid.Grouping.comparator.create({
            lower: null,
            upper: null,
            compare: Tent.JqGrid.Grouping.helper.numeric.compare,
            rowTitle: Tent.JqGrid.Grouping.helper.numeric.rowTitle,
            calculateRange: Tent.JqGrid.Grouping.helper.numeric.calculateRange(10)
          })
        }, {
<span id='Tent-JqGrid-Grouping-ranges-number-property-100s'>          /**
</span>          					* @property {Object} 100s group numbers in ranges of hundreds
          */

          name: Tent.JqGrid.Grouping.helper.numeric.calculateName(100),
          title: Tent.I18n.loc('tent.grouping.range.hundreds'),
          comparator: Tent.JqGrid.Grouping.comparator.create({
            lower: null,
            upper: null,
            compare: Tent.JqGrid.Grouping.helper.numeric.compare,
            rowTitle: Tent.JqGrid.Grouping.helper.numeric.rowTitle,
            calculateRange: Tent.JqGrid.Grouping.helper.numeric.calculateRange(100)
          })
        }, {
<span id='Tent-JqGrid-Grouping-ranges-number-property-100s'>          /**
</span>          					* @property {Object} 100s group numbers in ranges of thousands
          */

          name: Tent.JqGrid.Grouping.helper.numeric.calculateName(1000),
          title: Tent.I18n.loc('tent.grouping.range.thousands'),
          comparator: Tent.JqGrid.Grouping.comparator.create({
            lower: null,
            upper: null,
            compare: Tent.JqGrid.Grouping.helper.numeric.compare,
            rowTitle: Tent.JqGrid.Grouping.helper.numeric.rowTitle,
            calculateRange: Tent.JqGrid.Grouping.helper.numeric.calculateRange(1000)
          })
        }
      ];
    },
<span id='Tent-JqGrid-Grouping-ranges-amount'>    /**
</span>    		* @class Tent.JqGrid.Grouping.ranges.amount
    */

    amount: function() {
      return [
        {
<span id='Tent-JqGrid-Grouping-ranges-amount-property-exact'>          /**
</span>          					* @property {Object} exact group amounts which are the same
          */

          name: 'exact',
          title: Tent.I18n.loc('tent.grouping.range.exact'),
          comparator: Tent.JqGrid.Grouping.comparator.create({
            rowTitle: Tent.JqGrid.Grouping.helper.amount.rowTitle
          })
        }, {
<span id='Tent-JqGrid-Grouping-ranges-amount-property-10s'>          /**
</span>          					* @property {Object} 10s group amounts in ranges of ten
          */

          name: Tent.JqGrid.Grouping.helper.numeric.calculateName(10),
          title: Tent.I18n.loc('tent.grouping.range.tens'),
          comparator: Tent.JqGrid.Grouping.comparator.create({
            lower: null,
            upper: null,
            compare: Tent.JqGrid.Grouping.helper.numeric.compare,
            rowTitle: Tent.JqGrid.Grouping.helper.amount.rangeRowTitle,
            calculateRange: Tent.JqGrid.Grouping.helper.numeric.calculateRange(10)
          })
        }, {
<span id='Tent-JqGrid-Grouping-ranges-amount-property-100s'>          /**
</span>          					* @property {Object} 100s group amounts in ranges of hundreds
          */

          name: Tent.JqGrid.Grouping.helper.numeric.calculateName(100),
          title: Tent.I18n.loc('tent.grouping.range.hundreds'),
          comparator: Tent.JqGrid.Grouping.comparator.create({
            lower: null,
            upper: null,
            compare: Tent.JqGrid.Grouping.helper.numeric.compare,
            rowTitle: Tent.JqGrid.Grouping.helper.amount.rangeRowTitle,
            calculateRange: Tent.JqGrid.Grouping.helper.numeric.calculateRange(100)
          })
        }, {
<span id='Tent-JqGrid-Grouping-ranges-amount-property-100s'>          /**
</span>          					* @property {Object} 100s group amounts in ranges of thousands
          */

          name: Tent.JqGrid.Grouping.helper.numeric.calculateName(1000),
          title: Tent.I18n.loc('tent.grouping.range.thousands'),
          comparator: Tent.JqGrid.Grouping.comparator.create({
            lower: null,
            upper: null,
            compare: Tent.JqGrid.Grouping.helper.numeric.compare,
            rowTitle: Tent.JqGrid.Grouping.helper.amount.rangeRowTitle,
            calculateRange: Tent.JqGrid.Grouping.helper.numeric.calculateRange(1000)
          })
        }
      ];
    },
<span id='Tent-JqGrid-Grouping-ranges-boolean'>    /**
</span>    		* @class Tent.JqGrid.Grouping.ranges.boolean
    */

    boolean: function() {
      return [
        {
<span id='Tent-JqGrid-Grouping-ranges-boolean-property-exact'>          /**
</span>          					* @property {Object} exact group boleans which have the same value
          */

          name: 'exact',
          title: Tent.I18n.loc('tent.grouping.range.exact'),
          comparator: Tent.JqGrid.Grouping.comparator.create()
        }
      ];
    }
  });

<span id='Tent-JqGrid-Grouping-ranges-utcdate'>  /**
</span>  * @class Tent.JqGrid.Grouping.ranges.utcdate
  */


  Tent.JqGrid.Grouping.ranges.utcdate = Tent.JqGrid.Grouping.ranges.date;

}).call(this);


Ember.TEMPLATES['grid/autofit_button']=Ember.Handlebars.compile(&quot;&lt;a {{bindAttr title=\&quot;view.title\&quot;}} {{bindAttr class=\&quot;:horizontal-scroll-button :jqgrid-title-button view.active:active\&quot;}}&gt;\n\t&lt;i class=\&quot;icon-resize-horizontal\&quot;&gt;&lt;/i&gt;\n&lt;/a&gt;&quot;);

(function() {
Tent.Grid.AutofitButton = Ember.View.extend({
    classNames: ['tent-autofit-button'],
    templateName: 'grid/autofit_button',
    title: Tent.I18n.loc(&quot;tent.jqGrid.horizontalScroll&quot;),
    grid: null,
    active: (function() {
      return !this.get('grid.horizontalScrolling');
    }).property('grid.horizontalScrolling'),
    click: function() {
      return this.get('grid').set('horizontalScrolling', !this.get('grid').get('horizontalScrolling'));
    }
  });

}).call(this);


Ember.TEMPLATES['grid/column_chooser_button']=Ember.Handlebars.compile(&quot;&lt;div class=\&quot;btn-group column-chooser\&quot;&gt;\n\t&lt;a class=\&quot;open-dropdown\&quot;&gt;\n\t\t&lt;i class=\&quot;icon-columns\&quot;&gt;&lt;/i&gt;{{loc tent.jqGrid.hideShowCaption}}\n\t&lt;/a&gt;\n\t&lt;div class=\&quot;dropdown-menu columns pull-right\&quot;&gt;\n\t\t&lt;div class=\&quot;window\&quot;&gt;&lt;/div&gt;\n\t\t&lt;ul&gt;\n\t\t\t{{#each view.model}}\n\t\t\t\t&lt;li&gt;&lt;label&gt;&lt;input type=\&quot;checkbox\&quot; {{bindAttr data-column=\&quot;name\&quot;}} {{bindAttr checked=\&quot;checked\&quot;}}/&gt;&lt;span class=\&quot;title\&quot;&gt;{{loc title}}&lt;/span&gt;&lt;/label&gt;&lt;/li&gt;\n\t\t\t{{/each}}\n\t\t&lt;/ul&gt;\n\t&lt;/div&gt;\n&lt;/div&gt;&quot;);


<span id='Tent-JqGrid-Grouping-ranges-utcdate-property-'>/**
</span>* @mixin Tent.ToggleVisibility 
* Mixes in the ability to show/hide a subcomponent by calling {@link #toggleVisibility}.
* The subcomponent will also be hidden by clicking outside of its area, or pressing the 'escape'
*/


(function() {

  Tent.ToggleVisibility = Ember.Mixin.create({
<span id='Tent-JqGrid-Grouping-ranges-utcdate-method-bindToggleVisibility'>    /**
</span>    	* @method bindToggleVisibility Attach an event handle to an element to allow it to toggle the visibility of another element.
    	* @param {Object} source The source jQuery object which triggers the toggle
    	* @param {Object} dest The jQuery object to show and hide
    */

    bindToggleVisibility: function(source, dest) {
      var widget;
      widget = this;
      return source.click(function(e) {
        return widget.toggleVisibility(dest, source);
      });
    },
    toggleVisibility: function(component, source) {
      if (component.css('display') === 'none') {
        return this.showComponent(component, source);
      } else {
        return this.hideComponent(component);
      }
    },
<span id='Tent-JqGrid-Grouping-ranges-utcdate-method-hideComponent'>    /**
</span>    	* @method hideComponent Hides a toggleable component
    	* @param {Object} component The jQuery object to hide
    */

    hideComponent: function(component) {
      component.css('display', 'none');
      $('body').get(0).removeEventListener('click', this.get('hideHandler'), true);
      return $('body').get(0).removeEventListener('keyup', this.get('hideHandler'), true);
    },
<span id='Tent-JqGrid-Grouping-ranges-utcdate-method-showComponent'>    /**
</span>    	* @method showComponent Shows a toggleable component
    	* @param {Object} component The jQuery object to show
    */

    showComponent: function(component, source) {
      component.css('display', 'block');
      this.set('hideHandler', this.get('generateHideHandler')(this, component, source));
      $('body').get(0).addEventListener('click', this.get('hideHandler'), true);
      return $('body').get(0).addEventListener('keyup', this.get('hideHandler'), true);
    },
    generateHideHandler: function(widget, component, source) {
      return function(e) {
        if (e.keyCode === 27 || (($(e.target).closest(component).length === 0) &amp;&amp; (e.target !== source.get(0)))) {
          widget.hideComponent(component);
          e.stopPropagation();
        }
      };
    }
  });

}).call(this);


(function() {
Tent.Grid.ColumnChooserButton = Ember.View.extend(Tent.ToggleVisibility, {
    classNames: ['tent-column-chooser-button'],
    templateName: 'grid/column_chooser_button',
    grid: null,
    model: (function() {
      var annotatedModel;
      annotatedModel = this.get('grid.columnModel').map(function(item) {
        item.checked = !item.hidden;
        return item;
      });
      return annotatedModel.filter(function(item) {
        return item.hideable !== false;
      });
    }).property('grid.columnModel', 'grid.columnModel.@each'),
    didInsertElement: function() {
      var grid;
      grid = this.get('grid');
      this.bindToggleVisibility(this.$(&quot;.column-chooser .open-dropdown&quot;), this.$(&quot;.column-chooser .dropdown-menu&quot;));
      return this.$('.column-chooser').on('click', 'input', function(e) {
        var column;
        column = $(this).attr('data-column');
        if ($(this).is(':checked')) {
          return grid.showCol(column);
        } else {
          return grid.hideCol(column);
        }
      });
    }
  });

}).call(this);


Ember.TEMPLATES['panel']=Ember.Handlebars.compile(&quot;{{#if view.hasChildViews}}\n\t&lt;div class=\&quot;section accordion-group\&quot;&gt;\n\t\t{{yield}}\n\t&lt;/div&gt;\n{{else}}\n\t{{#if view.collapsible}}\n\t\t&lt;div class=\&quot;section accordion-group\&quot;&gt;\n\t\t   \t&lt;div class=\&quot;panel-header clearfix\&quot;&gt;\n\t\t    \t&lt;h3&gt;{{loc view.name}}&lt;/h3&gt;\n\t\t    \t&lt;a class=\&quot;pull-right\&quot; data-toggle=\&quot;collapse\&quot; {{bindAttr href=\&quot;view.href\&quot;}}&gt;\n\t\t\t      &lt;span class=\&quot;caret\&quot; &gt;&lt;/span&gt;\n\t\t\t    &lt;/a&gt;\n\t\t    &lt;/div&gt;\n\t\t    &lt;div {{bindAttr class=\&quot;view.collapsedClass\&quot;}}&gt;\n\t\t      &lt;div class=\&quot;panel-content\&quot;&gt;\n\t\t        {{yield}}\n\t\t      &lt;/div&gt;\n\t\t    &lt;/div&gt;\n\t\t&lt;/div&gt;\n\t \n\t{{else}}\n\t\t{{#if view.name}}&lt;h3&gt;{{loc view.name}}&lt;/h3&gt;{{/if}}{{yield}}\n\t{{/if}}\n{{/if}}&quot;);


<span id='Tent-Panel'>/**
</span>* @class Tent.Panel
* A container for content which can specify a span and a title. 
* A panel can also be collapsible, in {@link #collapsible} is set to true, 
* and in that case, the initial collapsed state can be specified by {@link #collapsed}.
*
* Usage 
* 		{{#view Tent.Panel span=&quot;10&quot; title=&quot;&quot;}}
*			...
*		  {{/view}}
*/


(function() {
Tent.Panel = Ember.View.extend(Tent.SpanSupport, {
    layoutName: 'panel',
    classNames: ['tent-panel'],
    classNameBindings: ['spanClass', 'collapsible', 'collapsed'],
    nameBinding: 'title',
<span id='Tent-Panel-property-span'>    /**
</span>    * @property {Number} span The horizontal span which should be allocated to this widget
    */

<span id='Tent-Panel-property-title'>    /**
</span>    * @property {String} title The title to display at the top of the panel.
    */

    title: &quot;&quot;,
<span id='Tent-Panel-property-collapsible'>    /**
</span>    * @property collapsible Boolean to indicate that the panel is collapsible
    */

    collapsible: false,
<span id='Tent-Panel-property-collapsed'>    /**
</span>    * @property collapsed Boolean to indicate that the panel is collapsed initially
    */

    collapsed: false,
    hideHeaderWhenExpanded: false,
    collapsedClass: (function() {
      return &quot;collapse &quot; + (!this.get('collapsed') ? &quot;in&quot; : &quot;&quot;);
    }).property('collapsed'),
    href: (function() {
      return &quot;#&quot; + this.get('elementId') + &quot; .collapse&quot;;
    }).property(&quot;elementId&quot;),
    didInsertElement: function() {
      var _this = this;
      if (this.get('collapsible')) {
        this.$('.collapse').on('hide', function() {
          return _this.set('collapsed', true);
        });
        return this.$('.collapse').on('show', function() {
          return _this.set('collapsed', false);
        });
      }
    },
    show: function() {
      this.$('.collapse').collapse('show');
      return this.set('collapsed', false);
    },
    hide: function() {
      this.$('.collapse').collapse('hide');
      return this.set('collapsed', true);
    }
  });

<span id='Tent-PanelHead'>  /**
</span>  * @class Tent.PanelHead
  * Used in the case where a custom header is required for a panel
  */


  Tent.PanelHead = Ember.View.extend({
    classNames: ['accordion-heading'],
    didInsertElement: function() {
      if (this.$('.panel-link').length &gt; 0) {
        return this.set('hasLink', true);
      }
    },
    hideHeaderContent: (function() {
      return this.get('parentView.hideHeaderWhenExpanded') &amp;&amp; !this.get('parentView.collapsed');
    }).property('parentView.collapsed'),
    layout: Ember.Handlebars.compile('&lt;div class=&quot;panel-header clearfix&quot;&gt;\
        &lt;span class=&quot;content&quot;&gt;{{#unless view.hideHeaderContent}}{{yield}}{{/unless}}&lt;/span&gt;\
        {{#unless view.hasLink}}\
        &lt;a class=&quot;pull-right&quot; data-toggle=&quot;collapse&quot; {{bindAttr href=&quot;view.parentView.href&quot;}}&gt;\
          &lt;span class=&quot;caret&quot; &gt;&lt;/span&gt;\
        &lt;/a&gt;\
        {{/unless}}\
      &lt;/div&gt;')
  });

  Tent.PanelBody = Ember.View.extend({
    layout: Ember.Handlebars.compile('&lt;div {{bindAttr class=&quot;view.parentView.collapsedClass&quot;}}&gt;\
        &lt;div class=&quot;panel-content&quot;&gt;\
          {{yield}}\
        &lt;/div&gt;\
      &lt;/div&gt;')
  });

<span id='Tent-PanelSlider'>  /**
</span>  * @class Tent.PanelSlider
  *
  * Used where the content is expected to slide down (rather than be revealed down)
  * Effectively, the bottom row of the content becomes the header content when the 
  * panel is collapsed
  *
  * Usage: 
  *           {{#view Tent.Panel span=&quot;10&quot; collapsible=true collapsed=false hasChildViews=true }}
                {{#view Tent.PanelSlider minHeight=40}}
                 
                  ... content here ...
                {{/view}}
              {{/view}}
  *
  */


  Tent.PanelSlider = Ember.View.extend({
    layout: Ember.Handlebars.compile('&lt;div class=&quot;panel-slider panel-header clearfix&quot;&gt;\
        &lt;span class=&quot;content&quot;&gt;&lt;span&gt;{{yield}}&lt;/span&gt;&lt;/span&gt;\
        &lt;a class=&quot;pull-right&quot;&gt;\
          &lt;span class=&quot;caret&quot; &gt;&lt;/span&gt;\
        &lt;/a&gt;\
      &lt;/div&gt;'),
    minHeight: 30,
    didInsertElement: function() {
      var content,
        _this = this;
      content = this.$('.content');
      this.set('height', this.$('.content').outerHeight());
      this.$('.content').css('min-height', '30px').css('position', 'absolute').css('bottom', '0px');
      this.$('a').click(function() {
        if (_this.get('parentView.collapsed')) {
          _this.$('.panel-slider').animate({
            height: _this.get('height') + 'px'
          });
          return _this.set('parentView.collapsed', false);
        } else {
          _this.$('.panel-slider').animate({
            height: _this.get('minHeight') + 'px'
          });
          return _this.set('parentView.collapsed', true);
        }
      });
      if (!this.get('parentView.collapsed')) {
        return this.$('.panel-slider').css('height', this.get('height') + 'px');
      }
    }
  });

<span id='Tent-PanelLink'>  /**
</span>  * @class Tent.PanelLink
  * Generates a link for use within the body of a header. This link will expand and 
  * contract the group
  */


  Tent.PanelLink = Ember.View.extend({
    tagName: 'span',
    classNames: ['panel-link'],
    classNameBindings: ['hidden'],
    collapsedDidChange: (function() {
      return this.calculateVisibility();
    }).observes('parentView.parentView.collapsed'),
    didInsertElement: function() {
      this.set('hidden', this.get('parentView.parentView.collapsed'));
      return this.calculateVisibility();
    },
    calculateVisibility: function() {
      var hidden;
      hidden = false;
      if (this.get('whenCollapsed') != null) {
        if (this.get('whenCollapsed') !== this.get('parentView.parentView.collapsed')) {
          hidden = true;
        }
      }
      return this.set('hidden', hidden);
    },
    layout: Ember.Handlebars.compile('&lt;a class=&quot;accordion-toggle&quot; data-toggle=&quot;collapse&quot; \
    {{bindAttr href=&quot;view.parentView.parentView.href&quot;}}&gt;\
    {{#if view.title}}{{loc view.title}}{{/if}}{{yield}}\
  &lt;/a&gt;'),
<span id='Tent-PanelLink-property-title'>    /**
</span>    * @property {String} title A title to display which acts as the link text to expand the group
    */

    title: &quot;&quot;
  });

  Tent.Form = Tent.Panel.extend({
    tagName: 'form',
    staticClasses: '',
    classNameBindings: ['spanClass', 'staticClasses', 'formClass'],
    classNames: ['tent-form'],
    formStyle: 'horizontal',
    formClass: (function() {
      return 'form-' + this.get('formStyle');
    }).property('formStyle')
  });

  Tent.Fieldset = Tent.Panel.extend({
    layout: Ember.Handlebars.compile('{{#if view.legendName}}&lt;legend&gt;{{loc view.legendName}}&lt;/legend&gt;{{/if}}{{yield}}'),
    tagName: 'fieldset'
  });

}).call(this);


(function() {

  Tent.CollapsibleSupport = Ember.Mixin.create({
    classNameBindings: ['collapsible'],
<span id='Tent-PanelLink-property-collapsible'>    /**
</span>    	* @property {Boolean} collapsible A boolean which determines whether the header is collapsible.
    	* If set to true, then a {@link #title} should be provided so that there is a meaningful header 
    	* area when collapsed.
    */

    collapsible: false,
<span id='Tent-PanelLink-property-collapsed'>    /**
</span>    	 * @property {Boolean} collapsed Defines whether the collapsible is collapsed initially.
    */

    collapsed: false,
<span id='Tent-PanelLink-property-useTransition'>    /**
</span>    	 * @property {Boolean} useTransition This property determines whether a CSS transition is used for sliding.
    */

    useTransition: true,
<span id='Tent-PanelLink-property-horizontalSlide'>    /**
</span>    	 * @property {Boolean} horizontalSlide This property determines whether a javascript transition is used for horizontal sliding.
    */

    horizontalSlide: false,
    slideDirection: &quot;left&quot;,
    onTransitionStep: function() {
      return $.publish(&quot;/ui/horizontalSlide&quot;, {
        source: this.$()
      });
    },
    onExpandEnd: function() {
      this.set('collapsed', false);
      this.$('').removeClass('collapsed');
      return $.publish(&quot;/ui/refresh&quot;, ['resize']);
    },
    onCollapseEnd: function() {
      this.set('collapsed', true);
      this.$('').addClass('collapsed');
      return $.publish(&quot;/ui/refresh&quot;, ['resize']);
    },
    didInsertElement: function() {
      var widget;
      this._super();
      if (this.get('collapsible')) {
        if (this.isUsingCSSTransition()) {
          widget = this;
          return this.$('').bind('webkitTransitionEnd oTransitionEnd transitionend msTransitionEnd', function() {
            widget.set('collapsed', widget.$('').hasClass('collapsed'));
            return $.publish(&quot;/ui/refresh&quot;, ['resize']);
          });
        }
      }
    },
    click: function(e) {
      var target;
      target = this.getClickArea(e);
      if (target.length &amp;&amp; this.get('collapsible')) {
        return this.toggle();
      }
    },
    toggle: function() {
      var collapsible;
      if (this.get('horizontalSlide')) {
        collapsible = this;
        if (this.get('collapsed')) {
          return this.expand();
        } else {
          return this.collapse();
        }
      } else {
        this.$('').toggleClass('collapsed');
        if (!this.isUsingCSSTransition()) {
          return this.triggerListenersImmediately();
        }
      }
    },
    expand: function() {
      var collapsible, dir;
      if (this.get('horizontalSlide')) {
        collapsible = this;
        dir = {};
        this.$('.drag-bar').css({
          'visibility': 'hidden'
        });
        dir[&quot;&quot; + collapsible.get(&quot;slideDirection&quot;)] = &quot;0px&quot;;
        return this.$().animate(dir, {
          duration: 400,
          step: function() {
            return collapsible.onTransitionStep();
          },
          complete: function() {
            return collapsible.onExpandEnd();
          }
        });
      } else {
        this.$('').removeClass('collapsed');
        if (!this.isUsingCSSTransition()) {
          return this.triggerListenersImmediately();
        }
      }
    },
    collapse: function() {
      var collapsible, dir;
      if (this.get('horizontalSlide')) {
        collapsible = this;
        collapsible.set('width', collapsible.$().width());
        this.$('.drag-bar').css({
          'visibility': 'hidden'
        });
        dir = {};
        dir[&quot;&quot; + collapsible.get(&quot;slideDirection&quot;)] = &quot;-&quot; + (collapsible.get('width')) + &quot;px&quot;;
        return this.$().animate(dir, {
          duration: 400,
          step: function() {
            return collapsible.onTransitionStep();
          },
          complete: function() {
            return collapsible.onCollapseEnd();
          }
        });
      } else {
        this.$('').addClass('collapsed');
        if (!this.isUsingCSSTransition()) {
          return this.triggerListenersImmediately();
        }
      }
    },
    triggerListenersImmediately: function() {
      this.set('collapsed', this.$('').hasClass('collapsed'));
      return $.publish(&quot;/ui/refresh&quot;, ['resize']);
    },
    isUsingCSSTransition: function() {
      return this.get('useTransition') &amp;&amp; Modernizr.csstransitions;
    },
    getClickArea: function(e) {
      if ($(e.target).hasClass('clickarea')) {
        return $(e.target);
      } else {
        return $(e.target).parentsUntil(this.$(), '.clickarea').eq(0);
      }
    }
  });

}).call(this);


(function() {

  Tent.HideableSupport = Ember.Mixin.create({
    classNameBindings: ['hideable'],
<span id='Tent-PanelLink-property-hideable'>    /**
</span>    	* @property {Boolean} hideable A boolean which determines whether the header is hideable.
    */

    hideable: false,
<span id='Tent-PanelLink-property-hidden'>    /**
</span>    	* @property {Boolean} hidden A boolean which determines whether the header is initially hidden
    */

    hidden: false,
    didInsertElement: function() {
      this._super();
      if (this.get('hideable')) {
        if (this.get('hidden')) {
          return this.hide(true);
        }
      }
    },
<span id='Tent-PanelLink-method-hide'>    /**
</span>    	* @method hide
    	* @param {Boolean} force execute the function even if the component is already hidden
    */

    hide: function(force) {
      if (force == null) {
        force = false;
      }
      if (this.get('hideable') &amp;&amp; (force || !this.get('hidden'))) {
        this.$('').addClass('hidden');
        this.set('hidden', true);
        return $.publish(&quot;/ui/refresh&quot;, ['resize']);
      }
    },
<span id='Tent-PanelLink-method-show'>    /**
</span>    	* @method show
    	* @param {Boolean} force execute the function even if the component is already shown
    */

    show: function(force) {
      if (force == null) {
        force = false;
      }
      if (this.get('hideable') &amp;&amp; (force || this.get('hidden'))) {
        this.$('').removeClass('hidden');
        this.set('hidden', true);
        this.set('hidden', false);
        return $.publish(&quot;/ui/refresh&quot;, ['resize']);
      }
    }
  });

}).call(this);


(function() {
<span id='Tent-Section'>/**
</span>  * @class Tent.Section
  *
  * ## Usage
  *
  *		{{#view Tent.Section span=&quot;5&quot; vspan=&quot;12&quot; title=&quot;_menu&quot;}}
  *		{{/view}}
  *
  * A Section typically will contain three subsections {@link Tent.Header}, {@link Tent.Content} and
  * {@link Tent.Footer}.
  * 
  * If you provide a {@link #title}, then a {@link Tent.Header} will be generated automatically, so you
  * should **not** provide your own {@link Tent.Header} in addition to this.
  *
  */


  Tent.Section = Ember.View.extend(Tent.SpanSupport, {
    tagName: 'section',
    classNameBindings: ['spanClass', 'vspanClass', 'hClass'],
    classNames: ['tent-section'],
<span id='Tent-Section-property-title'>    /**
</span>    	* @property {String} title The title to display in the header. If title is provided, a header section will
    	* be generated automatically.
    */

    title: null,
<span id='Tent-Section-property-hLevel'>    /**
</span>    	* @property {String} hLevel The header size to use if a title property is provided. e.g. '1', '2' etc
    */

    hLevel: '2',
    hClass: (function() {
      return &quot;hlevel&quot; + this.get('hLevel');
    }).property('hLevel'),
    formattedTitle: (function() {
      switch (this.get('hLevel')) {
        case &quot;1&quot;:
          return '{{#if view.title}}{{#view Tent.Header}}&lt;h1&gt;{{loc view.parentView.title}}&lt;/h1&gt;{{/view}}{{/if}}{{yield}}';
        case &quot;2&quot;:
          return '{{#if view.title}}{{#view Tent.Header}}&lt;h2&gt;{{loc view.parentView.title}}&lt;/h2&gt;{{/view}}{{/if}}{{yield}}';
        case &quot;3&quot;:
          return '{{#if view.title}}{{#view Tent.Header}}&lt;h3&gt;{{loc view.parentView.title}}&lt;/h3&gt;{{/view}}{{/if}}{{yield}}';
        case &quot;4&quot;:
          return '{{#if view.title}}{{#view Tent.Header}}&lt;h4&gt;{{loc view.parentView.title}}&lt;/h4&gt;{{/view}}{{/if}}{{yield}}';
        case &quot;5&quot;:
          return '{{#if view.title}}{{#view Tent.Header}}&lt;h5&gt;{{loc view.parentView.title}}&lt;/h5&gt;{{/view}}{{/if}}{{yield}}';
        default:
          return '{{#if view.title}}{{#view Tent.Header}}&lt;h2&gt;{{loc view.parentView.title}}&lt;/h2&gt;{{/view}}{{/if}}{{yield}}';
      }
    }).property('title'),
    layout: (function() {
      return Ember.Handlebars.compile(this.get('formattedTitle'));
    }).property('formattedTitle')
  });

<span id='Tent-Header'>  /**
</span>  * @class Tent.Header
  *
  * ## Usage
  *
  *		{{#view Tent.Header span=&quot;5&quot; class=&quot;program-header&quot;}}
  *		{{/view}}
  *
  * A Header panel will typically be used within a {@link Tent.Section}. 
  *
  * The Header may consist of a single header area, populated with a title or other nested content, or it 
  * can contain a header area (displaying a title) with a further section beneath. This arrangement is usually
  * used to provide an expanding/contracting header. If expand/contract is not required, it is standard to use a simple
  * header and put the main body in the {@link Tent.Content} widget
  */


  Tent.Header = Ember.View.extend(Tent.SpanSupport, Tent.CollapsibleSupport, Tent.HideableSupport, {
    tagName: 'header',
    classNameBindings: ['spanClass', 'useTransition:use-transition'],
<span id='Tent-Header-property-title'>    /**
</span>    	* @property {String} title The title to be displayed in the header.
    	* You may provide a title explicitly using the title property. You may also nest content
    	* in the Header view and that will appear below the title header.
    	* If nested content is provided, but no title provided, the nested content will appear in the header section
    */

    title: null,
    formattedTitle: (function() {
      switch (this.get('hLevel')) {
        case &quot;1&quot;:
          return '&lt;h1&gt;{{loc view.title}}&lt;/h1&gt;';
        case &quot;2&quot;:
          return '&lt;h2&gt;{{loc view.title}}&lt;/h2&gt;';
        case &quot;3&quot;:
          return '&lt;h3&gt;{{loc view.title}}&lt;/h3&gt;';
        case &quot;4&quot;:
          return '&lt;h4&gt;{{loc view.title}}&lt;/h4&gt;';
        case &quot;5&quot;:
          return '&lt;h5&gt;{{loc view.title}}&lt;/h5&gt;';
        default:
          return '&lt;h2&gt;{{loc view.title}}&lt;/h2&gt;';
      }
    }).property('title'),
    layout: (function() {
      if (this.get('collapsible')) {
        if (this.get('title')) {
          return Ember.Handlebars.compile('&lt;div class=&quot;header&quot;&gt;' + this.get('formattedTitle') + '&lt;b class=&quot;caret clickarea&quot;/&gt;&lt;/div&gt;{{yield}}');
        } else {
          return Ember.Handlebars.compile('&lt;div class=&quot;header&quot;&gt;You must provide a title for a collapsed header&lt;/div&gt;');
        }
      } else {
        if (this.get('title')) {
          return Ember.Handlebars.compile('&lt;div class=&quot;header&quot;&gt;' + this.get('formattedTitle') + '&lt;/div&gt;{{yield}}');
        } else {
          return Ember.Handlebars.compile('&lt;div class=&quot;header&quot;&gt;{{yield}}&lt;/div&gt;');
        }
      }
    }).property('formattedTitle')
  });

<span id='Tent-Content'>  /**
</span>  * @class Tent.Content
  *
  * ## Usage
  *
  *		{{#view Tent.Content span=&quot;5&quot;}}
  *		{{/view}}
  * A Content panel will typically be used within a {@link Tent.Section}. The panel height will change to
  * fill the available space within the Section
  */


  Tent.Content = Ember.View.extend(Tent.SpanSupport, {
    classNameBindings: ['spanClass'],
    classNames: ['content'],
    layout: Ember.Handlebars.compile('{{yield}}'),
<span id='Tent-Content-property-sizeToHeaderContent'>    /**
</span>    	 * @property {Boolean} sizeToHeaderContent Rather than using the headers css height property, the content
    	 * should shift down to accomodate the height of the headers content.
    */

    sizeToHeaderContent: false,
    didInsertElement: function() {
      this.set('section', this.$().parent('section'));
      this.set('header', this.get('section').children('header'));
      this.set('headerView', Ember.View.views[this.get('header').attr('id')]);
      return this.resize();
    },
    resize: function() {
      var footerOffset, h, headerOffset;
      this.set('footer', this.get('section').children('footer'));
      if (this.get('sizeToHeaderContent')) {
        h = $('.header', this.get('header'));
        headerOffset = h.length &gt; 0 ? h.outerHeight(true) : 0;
      } else {
        headerOffset = this.get('header').length &gt; 0 ? this.get('header').outerHeight(true) : 0;
      }
      this.$().css('top', headerOffset + &quot;px&quot;);
      footerOffset = this.get('footer').length &gt; 0 ? this.get('footer').outerHeight(true) : 0;
      return this.$().css('bottom', footerOffset + &quot;px&quot;);
    },
    headerDidCollapse: (function() {
      return this.resize();
    }).observes('headerView.collapsed', 'headerView.hidden')
  });

<span id='Tent-Footer'>  /**
</span>  * @class Tent.Footer
  *
  * ## Usage
  *
  *		{{#view Tent.Footer span=&quot;5&quot;}}
  *		{{/view}}
  *
  * A Footer panel will typically be used within a {@link Tent.Section}. 
  *
  */


  Tent.Footer = Ember.View.extend(Tent.SpanSupport, {
    tagName: 'footer',
    classNameBindings: ['spanClass'],
    layout: Ember.Handlebars.compile('{{yield}}'),
    didInsertElement: function() {
      var content, section;
      section = this.$().parent('section');
      content = section.children('.content');
      if (content.length &gt; 0) {
        return Ember.View.views[content.attr('id')].resize();
      }
    }
  });

}).call(this);


(function() {
<span id='Tent-HSection'>/**
</span>  * @class Tent.HSection
  *
  * ## Usage
  *
  *		{{#view Tent.HSection vspan=&quot;12&quot;}}
  *		{{/view}}
  *
  * A HSection typically will contain three subsections {@link Tent.Left}, {@link Tent.Center} and
  * {@link Tent.Right}.
  * 
  * The main benefit to a HSection is that the Left and Right panels can be expanded and contracted, with
  * the center panel adapting to fill the available space.
  *
  */


  Tent.HSection = Ember.View.extend(Tent.SpanSupport, {
    tagName: 'section',
    classNameBindings: ['spanClass', 'vspanClass', 'hClass'],
    classNames: ['tent-hsection'],
    layout: Ember.Handlebars.compile(&quot;{{yield}}&quot;),
    didInsertElement: function() {
      var $left, $right;
      $left = this.$().children('.left-panel:first');
      if ($left != null) {
        this.set('left-panel', Ember.View.views[$left.attr('id')]);
      }
      $right = this.$().children('.right-panel:first');
      if ($right != null) {
        this.set('right-panel', Ember.View.views[$right.attr('id')]);
      }
      return this.listenForEvents();
    },
    willDestroyElement: function() {
      $.unsubscribe('ui/h-collapse-left');
      return $.unsubscribe('ui/h-collapse-right');
    },
    expandAll: function() {
      this.get('left-panel').expand();
      return this.get('right-panel').expand();
    },
    collapseAll: function() {
      this.get('left-panel').collapse();
      return this.get('right-panel').collapse();
    },
    listenForEvents: function() {
      var _this = this;
      $.subscribe('ui/h-collapse-left', function(e, params) {
        var _ref, _ref1, _ref2;
        if (((_ref = params.source) != null ? (_ref1 = _ref.closest('.tent-hsection')) != null ? _ref1.get(0) : void 0 : void 0) === ((_ref2 = _this.$('')) != null ? _ref2.get(0) : void 0)) {
          return _this.get('left-panel').collapse();
        }
      });
      return $.subscribe('ui/h-expand-left', function(e, params) {
        var _ref, _ref1, _ref2;
        if (((_ref = params.source) != null ? (_ref1 = _ref.closest('.tent-hsection')) != null ? _ref1.get(0) : void 0 : void 0) === ((_ref2 = _this.$('')) != null ? _ref2.get(0) : void 0)) {
          return _this.get('left-panel').expand();
        }
      });
    }
  });

<span id='Tent-Left'>  /**
</span>  * @class Tent.Left
  *
  * ## Usage
  *
  *		{{#view Tent.Left span=&quot;5&quot; class=&quot;&quot;}}
  *		{{/view}}
  *
  * This container should be used as part of a {@link Tent.HSection}
  * Left will appear on the left-hand side of a Tent.HSection and is collapsible.
  *
  */


  Tent.Left = Ember.View.extend(Tent.SpanSupport, Tent.CollapsibleSupport, {
    tagName: 'section',
    classNameBindings: ['spanClass', 'useTransition'],
    classNames: ['left-panel'],
    collapsible: true,
    horizontalSlide: true,
    slideDirection: &quot;left&quot;,
    useTransition: false,
    layout: Ember.Handlebars.compile('&lt;div class=&quot;drag-bar clickarea&quot;&gt;&lt;i class=&quot;icon-caret-left&quot;&gt;&lt;/i&gt;&lt;/div&gt;&lt;div class=&quot;panel-content&quot;&gt;{{yield}}&lt;/div&gt;'),
    didInsertElement: function() {
      var _this = this;
      return $.subscribe('/window/resize', function() {
        _this.repositionDragBar();
        return _this.keepAlignedWithLeft();
      });
    },
    willDestroyElement: function() {
      return $.unsubscribe('/window/resize');
    },
    onExpandEnd: function() {
      this._super();
      return this.repositionDragBar();
    },
    onCollapseEnd: function() {
      this._super();
      return this.repositionDragBar();
    },
    repositionDragBar: function() {
      var shift;
      shift = this.get('collapsed') ? 0 : 20;
      return this.$('.drag-bar').css({
        'left': this.$().width() - shift,
        'visibility': 'visible'
      });
    },
    sourceIsInMySection: function(data) {
      var _ref, _ref1;
      return (data != null) &amp;&amp; (((_ref = data.source) != null ? _ref.parent('section').get(0) : void 0) === ((_ref1 = this.$()) != null ? _ref1.parent('section').get(0) : void 0));
    },
    keepAlignedWithLeft: function(data) {
      if (this.$() != null) {
        if (this.get('collapsed') &amp;&amp; !this.sourceIsInMySection(data)) {
          return this.$().css('left', &quot;-&quot; + this.$().width() + 'px');
        }
      }
    }
  });

<span id='Tent-Center'>  /**	
</span>  * @class Tent.Center
  *
  * ## Usage
  *
  *		{{#view Tent.Center}}
  *		{{/view}}
  *
  * This container should be used as part of a {@link Tent.HSection}
  * Center will appear in the center of a Tent.HSection and will expand to fill the space available.
  */


  Tent.Center = Ember.View.extend(Tent.SpanSupport, {
    classNameBindings: ['spanClass', 'leftCollapsed', 'rightCollapsed'],
    classNames: ['center-panel'],
    layout: Ember.Handlebars.compile('{{yield}}'),
    leftView: null,
    didInsertElement: function() {
      var left, right, section,
        _this = this;
      this.resize();
      section = this.$().parent('section');
      left = section.children('.left-panel');
      right = section.children('.right-panel');
      this.set('leftView', Ember.View.views[left.attr('id')]);
      this.set('rightView', Ember.View.views[right.attr('id')]);
      $.subscribe(&quot;/ui/horizontalSlide&quot;, function(a, data) {
        return _this.resize(data);
      });
      $.subscribe(&quot;/ui/refresh&quot;, function(a, data) {
        return _this.resize();
      });
      return $.subscribe(&quot;/window/resize&quot;, function() {
        return _this.resize();
      });
    },
    resize: function(data) {
      var left, leftOffset, right, rightOffset, section;
      if (this.$() != null) {
        section = this.$().parent('section');
        left = section.children('.left-panel');
        leftOffset = left.length &gt; 0 ? left.outerWidth(true) + left.offset().left - section.offset().left : 0;
        if (this.$().css('left') !== leftOffset + &quot;px&quot;) {
          this.$().css('left', leftOffset + &quot;px&quot;);
        }
        right = section.children('.right-panel');
        rightOffset = right.length &gt; 0 ? right.outerWidth(true) - ((right.offset().left + right.outerWidth()) - (section.offset().left + section.width())) : 0;
        if (this.$().css('right') !== rightOffset + &quot;px&quot;) {
          return this.$().css('right', rightOffset + &quot;px&quot;);
        }
      }
    },
    siblingDidChange: (function() {
      this.set('leftCollapsed', this.get('leftView.collapsed'));
      this.set('rightCollapsed', this.get('rightView.collapsed'));
      return this.resize();
    }).observes('leftView.collapsed', 'rightView.collapsed'),
    willDestroyElement: function() {
      $.unsubscribe(&quot;/ui/refresh&quot;);
      return $.unsubscribe(&quot;/window/resize&quot;);
    }
  });

<span id='Tent-Right'>  /**
</span>  * @class Tent.Right
  *
  * ## Usage
  *
  *		{{#view Tent.Right span=&quot;5&quot;}}
  *		{{/view}}
  *
  * This container should be used as part of a {@link Tent.HSection}
  * Right will appear on the right-hand side of a Tent.HSection and is collapsible.
  */


  Tent.Right = Ember.View.extend(Tent.SpanSupport, Tent.CollapsibleSupport, {
    tagName: 'section',
    classNameBindings: ['spanClass', 'useTransition'],
    classNames: ['right-panel'],
    collapsible: true,
    collapsed: false,
    horizontalSlide: true,
    slideDirection: &quot;right&quot;,
    useTransition: false,
    layout: Ember.Handlebars.compile('&lt;div class=&quot;drag-bar clickarea&quot;&gt;&lt;i class=&quot;icon-caret-right&quot;&gt;&lt;/i&gt;&lt;/div&gt;&lt;div class=&quot;panel-content&quot;&gt;{{yield}}&lt;/div&gt;'),
    didInsertElement: function() {
      var _this = this;
      $.subscribe(&quot;/ui/horizontalSlide&quot;, function(a, data) {
        return _this.keepAlignedWithRight(data);
      });
      return $.subscribe(&quot;/window/resize&quot;, function(a, data) {
        return _this.keepAlignedWithRight(data);
      });
    },
    willDestroyElement: function() {
      $.unsubscribe('/window/resize');
      return $.unsubscribe('/ui/horizontalSlide');
    },
    keepAlignedWithRight: function(data) {
      if (this.$() != null) {
        if (this.get('collapsed') &amp;&amp; !this.sourceIsInMySection(data)) {
          return this.$().css('right', &quot;-&quot; + this.$().width() + 'px');
        }
      }
    },
    sourceIsInMySection: function(data) {
      var _ref, _ref1;
      return (data != null) &amp;&amp; (((_ref = data.source) != null ? _ref.parent('section').get(0) : void 0) === ((_ref1 = this.$()) != null ? _ref1.parent('section').get(0) : void 0));
    },
    onExpandEnd: function() {
      this._super();
      return this.$('.drag-bar').css({
        'left': 0,
        'visibility': 'visible'
      });
    },
    onCollapseEnd: function() {
      this._super();
      return this.$('.drag-bar').css({
        'left': 0 - 20,
        'visibility': 'visible'
      });
    }
  });

}).call(this);


Ember.TEMPLATES['checkbox']=Ember.Handlebars.compile(&quot;&lt;div class=\&quot;controls\&quot;&gt;\n    &lt;label class=\&quot;checkbox\&quot;&gt;\n    \t{{loc view.label}}\n    \t{{view Ember.Checkbox checkedBinding=\&quot;view.checked\&quot; disabledBinding = \&quot;view.disabled\&quot; valueBinding= \&quot;view.value\&quot;}}\n    &lt;/label&gt;\n\n    {{#if view.hasWarnings}}\n      &lt;ul class=\&quot;help-inline warning\&quot; {{bindAttr id=\&quot;view.warningId\&quot;}}&gt;{{#each warning in view.validationWarnings}}&lt;li&gt;{{loc warning}}&lt;/li&gt;{{/each}}&lt;/ul&gt;\n    {{/if}} \n&lt;/div&gt; &quot;);

(function() {
Tent.Checkbox = Ember.View.extend(Tent.FieldSupport, {
    templateName: 'checkbox',
    classNames: ['tent-checkbox', 'control-group'],
    change: function() {
      this._super(arguments);
      return this.set('isValid', this.validate());
    },
    formattedValue: (function() {
      return this.get('checked');
    }).property('checked')
  });

}).call(this);


Ember.TEMPLATES['select']=Ember.Handlebars.compile(&quot;&lt;label class=\&quot;control-label\&quot; {{bindAttr for=\&quot;view.forId\&quot;}}&gt;{{loc view.label}}\n    &lt;span class='tent-required'&gt;&lt;/span&gt;\n&lt;/label&gt;\n\n&lt;div class=\&quot;controls\&quot;&gt;\n  &lt;div class=\&quot;input-prepend\&quot;&gt;\n    {{#if view.isLoading}}\n      &lt;div class=\&quot;wait\&quot;&gt;&lt;i class=\&quot;icon-spinner icon-spin\&quot;&gt;&lt;/i&gt;&lt;/div&gt;\n    {{/if}}\n    {{#if view.isTextDisplay}}\n      &lt;span class=\&quot;text-display\&quot;&gt;{{loc view.currentSelectedLabel}}&lt;/span&gt;\n    {{else}}\n      {{#if view.isRadioGroup}}\n        &lt;div class=\&quot;radio-group\&quot;&gt;\n          {{view Tent.SelectElement \n                 contentBinding=\&quot;view.list\&quot; \n                 class=\&quot;tent-radio-group\&quot;\n                 optionLabelPathBinding=\&quot;view.optionLabelPath\&quot; \n                 optionValuePathBinding =\&quot;view.optionValuePath\&quot; \n                 selectionBinding=\&quot;view.selection\&quot;\n                 valueBinding = \&quot;view.value\&quot;\n                 tagName = \&quot;div\&quot;\n                 templateName = \&quot;radio_group\&quot;\n          }} \n        &lt;/div&gt;\n      {{else}}\n        {{view Tent.SelectElement \n               contentBinding=\&quot;view.list\&quot; \n               classBinding=\&quot;view.inputSizeClass\&quot; \n               optionLabelPathBinding=\&quot;view.optionLabelPath\&quot; \n               optionValuePathBinding =\&quot;view.optionValuePath\&quot; \n               selectionBinding=\&quot;view.selection\&quot;\n               multipleBinding=\&quot;view.multiple\&quot;\n               promptBinding = \&quot;view._prompt\&quot; \n               valueBinding = \&quot;view.value\&quot;}} \n      {{/if}}\n      {{#if view.hasHelpBlock}}\n        &lt;span class=\&quot;help-block\&quot; {{bindAttr id=\&quot;view.helpId\&quot;}}&gt;{{loc view.helpBlock}}&lt;/span&gt;\n      {{/if}}\n    {{/if}}\n  \t{{#if view.tooltip}}\n      &lt;a href=\&quot;#\&quot; rel=\&quot;tooltip\&quot; data-placement=\&quot;right\&quot; {{bindAttr data-original-title=\&quot;view.tooltipT\&quot;}}&gt;&lt;/a&gt;\n    {{/if}}\n  \t{{#if view.hasErrors}}\n      \t&lt;span class=\&quot;help-inline\&quot; {{bindAttr id=\&quot;view.errorId\&quot;}}&gt;{{#each error in view.validationErrors}}{{error}}{{/each}}&lt;/span&gt;\n    {{/if}}\n    {{#if view.hasWarnings}}\n      &lt;ul class=\&quot;help-inline\&quot; {{bindAttr id=\&quot;view.warningId\&quot;}}&gt;{{#each warning in view.validationWarnings}}&lt;li&gt;{{loc warning}}&lt;/li&gt;{{/each}}&lt;/ul&gt;\n    {{/if}}  \n  &lt;/div&gt;\n&lt;/div&gt;&quot;);

Ember.TEMPLATES['radio_group']=Ember.Handlebars.compile(&quot;{{#if view.prompt}}{{loc view.prompt}}{{/if}}\n{{#each view.content}}\n\t&lt;label&gt;{{view Tent.RadioOption contentBinding=\&quot;this\&quot;}}&lt;/label&gt;\n{{/each}}&quot;);


<span id='Tent-Select'>/**
</span>* @class Tent.Select
* @mixins Tent.FieldSupport
* @mixins Tent.TooltipSupport
*
* Usage
*        {{view Tent.Select 
            listBinding=&quot;&quot; 
            selectionBinding=&quot;&quot; 
            label=&quot;&quot; 
            optionLabelPath=&quot;&quot; 
            optionValuePath=&quot;&quot; 
            multiple=true 
          }}
*/


(function() {
Tent.Select = Ember.View.extend(Tent.FieldSupport, Tent.TooltipSupport, {
    templateName: 'select',
    classNames: ['tent-select', 'control-group'],
    contentBinding: 'selection',
<span id='Tent-Select-property-list'>    /**
</span>    * @property {Array} list An array of objects to be presented as the dropdown options. Each item of
    * the array should be a hash of two values, representing the text to display, and the value of that option
    */

    list: null,
<span id='Tent-Select-property-selection'>    /**
</span>    * @property {Object} selection A property to which the selected item(s) from the field is bound
    */

    selection: null,
<span id='Tent-Select-property-optionLabelPath'>    /**
</span>    * @property {String} optionLabelPath The name of the property of the list which is to 
    * be used as the label for the option
    */

    optionLabelPath: null,
<span id='Tent-Select-property-optionValuePath'>    /**
</span>    * @property {String} optionValuePath The name of the property of the list which is to 
    * be used as the value for the option
    */

    optionValuePath: null,
<span id='Tent-Select-property-multiple'>    /**
</span>    * @property {Boolean} [multiple=false] A boolean property indicating whether multiple values may be selected.
    */

    multiple: false,
<span id='Tent-Select-property-showPrompt'>    /**
</span>    * @property {Boolean} [showPrompt=true] A boolean property to indicate whether a prompt should be displayed in
    * the select dropdown. 
    * If no 'prompt' property is set, the prompt will default to a message similar to 'Please Select ...'
    */

    showPrompt: true,
<span id='Tent-Select-property-preselectSingleElement'>    /**
</span>    * @property {Boolean} [preselectSingleElement=false] A boolean property to indicate whether a prompt 
    * should be displayed in the select dropdown if the list has only one option available. If set to true, the only option 
    * in the list will be preselected. If false, the prompt will be displayed.
    *
    */

    preselectSingleElement: false,
<span id='Tent-Select-property-isLoading'>    /**
</span>     * @property {Boolean} isLoading A boolean to indicate that the content for the control has not yet loaded.
     * This will usually be represented in the UI by a spinning icon.
    */

    isLoading: false,
    init: function() {
      this._super();
      if (this.get('list.length') === 1 &amp;&amp; this.get('preselectSingleElement')) {
        return this.set('showPrompt', false);
      }
    },
    didInsertElement: function() {
      this._super(arguments);
      return this.set('inputIdentifier', this.$('select').attr('id'));
    },
    valueForMandatoryValidation: (function() {
      if (this.get('multiple')) {
        return this.get('selection');
      } else {
        return this.get('value');
      }
    }).property('value', 'selection'),
    formattedValue: (function() {
      return this.get('currentSelectedLabel');
    }).property('currentSelectedLabel'),
    selectionDidChange: (function() {
      return this.set('content', this.get('selection'));
    }).observes('selected'),
    listObserver: (function() {
      var _this = this;
      if (this.get('preselectSingleElement')) {
        if (this.get(&quot;list.length&quot;) === 1) {
          this.set(&quot;showPrompt&quot;, false);
          return this.set(&quot;selection&quot;, this.get(&quot;list&quot;).toArray()[0]);
        } else {
          this.set(&quot;selection&quot;, null);
          return Ember.run(function() {
            return _this.set(&quot;showPrompt&quot;, true);
          });
        }
      }
    }).observes(&quot;list&quot;, &quot;list@each&quot;),
    currentSelectedLabel: (function() {
      var content, item, labels, _i, _len;
      content = this.get('selection');
      if (content != null) {
        if (content instanceof Array) {
          labels = [];
          for (_i = 0, _len = content.length; _i &lt; _len; _i++) {
            item = content[_i];
            labels.push(Tent.I18n.loc(this.getLabelForContent({
              content: item
            })));
          }
          return labels.join();
        } else {
          return Tent.I18n.loc(this.getLabelForContent(this));
        }
      }
    }).property('selection'),
    getLabelForContent: function(item) {
      return Ember.get(item, this.get('optionLabelPath'));
    },
    _prompt: (function() {
      var prompt;
      if (!this.get('multiple') &amp;&amp; this.get('showPrompt')) {
        if (prompt = Tent.I18n.loc(this.get('prompt'))) {
          return prompt;
        } else {
          return Tent.I18n.loc('tent.pleaseSelect');
        }
      }
    }).property('prompt', 'showPrompt'),
    change: function() {
      this._super(arguments);
      return this.set('isValid', this.validate());
    }
  });

  Tent.SelectElement = Ember.Select.extend(Tent.AriaSupport, Tent.Html5Support, Tent.DisabledSupport, {
    defaultTemplate: Ember.Handlebars.compile('{{#if view.prompt}}&lt;option value&gt;{{view.prompt}}&lt;/option&gt;{{/if}}{{#each view.content}}{{view Tent.SelectOption contentBinding=&quot;this&quot;}}{{/each}}')
  });

  Tent.SelectOption = Ember.SelectOption.extend({
    labelPathDidChange: Ember.observer(function() {
      var labelPath;
      labelPath = Ember.get(this, 'parentView.optionLabelPath');
      if (!labelPath) {
        return;
      }
      return Ember.defineProperty(this, 'label', Ember.computed(function() {
        if (Ember.get(this, labelPath) !== &quot;&quot;) {
          return Tent.I18n.loc(Ember.get(this, labelPath));
        }
      }).property(labelPath).cacheable());
    }, 'parentView.optionLabelPath')
  });

}).call(this);


(function() {

  Tent.RadioOption = Ember.SelectOption.extend({
    tagName: &quot;div&quot;,
    classNames: ['tent-radio-option'],
    attributeBindings: ['type', 'value', 'checked', 'name'],
    type: &quot;radio&quot;,
    layout: Ember.Handlebars.compile('&lt;input type=&quot;radio&quot; class=&quot;tent-radio-option&quot;\
  	{{bindAttr value=&quot;view.value&quot;}}\
  	{{bindAttr name=&quot;view.name&quot;}}\
  	{{bindAttr checked=&quot;view.checked&quot;}}/&gt;\
  	{{loc view.label}}'),
    name: (function() {
      return this.get('parentView.elementId');
    }).property(),
    label: (function() {
      return Tent.I18n.loc(this.get('content').get(this.get('parentView.optionLabelPath')));
    }).property(),
    radioId: (function() {
      return this.get('elementId');
    }).property(),
    change: function() {
      return this.get('parentView').set('selection', this.get('content'));
    },
    didInsertElement: function() {
      this._super();
      this.set('inputIdentifier', this.$('input[type=&quot;radio&quot;]').attr('id'));
      if (this.get('parentView.selection') === this.get('content')) {
        return this.set('checked', true);
      }
    },
    selectionDidChange: (function() {
      if (this.get('parentView.selection') === this.get('content')) {
        return this.set('checked', true);
      } else {
        return this.set('checked', false);
      }
    }).observes('parentView.selection'),
    labelPathDidChange: Ember.observer(function() {
      var labelPath;
      labelPath = Ember.get(this, 'parentView.optionLabelPath');
      if (!labelPath) {
        return;
      }
      return Ember.defineProperty(this, 'label', Ember.computed(function() {
        return Tent.I18n.loc(Ember.get(this, labelPath));
      }).property(labelPath).cacheable());
    }, 'parentView.optionLabelPath')
  });

}).call(this);


Ember.TEMPLATES['checkbox_group']=Ember.Handlebars.compile(&quot;&lt;label class=\&quot;control-label\&quot;&gt;{{loc view.label}}&lt;/label&gt;\n\n&lt;div class=\&quot;controls\&quot;&gt;\n  {{#each check in view._list}}\n    {{view Ember.Checkbox checkedBinding=\&quot;view.list.selected\&quot; disabledBinding = \&quot;view.disabled\&quot; }} {{check}}\n  {{/each}}\n&lt;/div&gt;\n\n&quot;);

(function() {
Tent.CheckboxGroup = Ember.View.extend({
    templateName: 'checkbox_group',
    classNames: ['tent-checkbox-group', 'control-group'],
    init: function() {
      this._super();
      return this.set('_list', Tent.SelectableArrayProxy.create({
        content: this.get('list')
      }) || []);
    },
    checkedDidChange: (function() {
      return this.set('selection', this.get('list.selected'));
    }).observes('list.selected')
  });

}).call(this);



<span id='Tent-EmailField'>/**
</span>* @class Tent.EmailField
* @extends Tent.TextField
* A text field which allows an email address to be entered. An error message will be displayed if the user enters
* a badly-formed email.
*  
* Usage
*       {{view Tent.EmailField 
			label=&quot;&quot; 
			valueBinding=&quot;&quot; 
         }}
*/


(function() {
Tent.EmailTextField = Tent.TextField.extend({
    validate: function() {
      var didOtherValidationPass, isValidEmail, pattern, value;
      didOtherValidationPass = this._super();
      value = this.get('formattedValue');
      pattern = /^(([A-Za-z0-9]+_+)|([A-Za-z0-9]+\-+)|([A-Za-z0-9]+\.+)|([A-Za-z0-9]+\++))*[A-Za-z0-9]+@((\w+\-+)|(\w+\.))*\w{1,63}\.[a-zA-Z]{2,6}$/i;
      isValidEmail = this.isValueEmpty(value) || pattern.test(value);
      if (!isValidEmail) {
        this.addValidationError(Tent.messages.EMAIL_FORMAT_ERROR);
      }
      if (didOtherValidationPass &amp;&amp; isValidEmail) {
        this.validateWarnings();
      }
      return didOtherValidationPass &amp;&amp; isValidEmail;
    },
    validateWarnings: function() {
      return this._super();
    },
    isValueEmpty: function(value) {
      return !((value != null) &amp;&amp; value !== '');
    }
  });

}).call(this);


(function() {

  Tent.AlertMessage = Ember.View.extend({
    tagName: 'div',
    classNames: ['alert'],
    title: null,
    template: Ember.Handlebars.compile('&lt;a href=&quot;#&quot; class=&quot;close&quot; close=&quot;close&quot;&gt;x&lt;/a&gt;{{#if view.title}}&lt;span class=&quot;title&quot;&gt;{{loc view.title}}&lt;/span&gt;{{/if}}{{loc view.text}}'),
    init: function() {
      var classNames, type;
      this._super();
      type = this.get('type');
      classNames = this.get('classNames');
      if (type) {
        return classNames.push('alert-' + type);
      }
    },
    click: function(event) {
      var target, targetClose;
      target = event.target;
      targetClose = target.getAttribute('close');
      if (targetClose === 'close') {
        this.destroy();
        return false;
      }
    }
  });

}).call(this);


Ember.TEMPLATES['modal_pane']=Ember.Handlebars.compile(&quot;\n\t{{#if view.label}}\n\t\t{{#unless view.customButton}}\n\t\t{{view Tent.Button class=\&quot;launch\&quot; labelBinding=\&quot;view.label\&quot; aria-haspopup=\&quot;true\&quot; action=\&quot;launch\&quot; targetBinding=\&quot;view\&quot; typeBinding=\&quot;view.type\&quot;}}\n\t\t{{/unless}}\n\t{{/if}}\n\t&lt;div class=\&quot;modal-backdrop fade in\&quot;&gt;&lt;/div&gt;\n\t&lt;div class=\&quot;modal hide fade\&quot; tabindex=\&quot;-1\&quot; role=\&quot;dialog\&quot; aria-hidden=\&quot;true\&quot; {{bindAttr data-backdrop=\&quot;view.backdrop\&quot;}}&gt;\n\t\t&lt;div class=\&quot;modal-header\&quot;&gt;\n\t\t\t{{view Tent.Button buttonClass=\&quot;close-dialog close\&quot; label=\&quot;&amp;times;\&quot; actionBinding=\&quot;view.closeAction\&quot; targetBinding=\&quot;view.closeTarget\&quot; type=\&quot;link\&quot;}}\n\n\t\t  \t{{view Tent.ModalHeader}}\n\t\t&lt;/div&gt;\n\t\t{{#if view.customContent}}\n\t\t\t{{yield}}\n\t\t{{else}}\n\t\t\t&lt;div class=\&quot;modal-body\&quot;&gt;\n\t\t\t\t{{view Tent.MessagePanel type=\&quot;secondary\&quot; isActive=false collapsible=true collapsed=true}}\n\t\t\t\t{{#if view.text}}\n\t\t\t  \t\t&lt;p&gt;{{loc view.text}}&lt;/p&gt;\n\t\t\t  \t{{/if}}\n\t\t\t  \t{{yield}}\n\t\t\t&lt;/div&gt;\n\t\t\n\t\t\t&lt;div class=\&quot;modal-footer\&quot;&gt;\n\t\t\t\t&lt;div class=\&quot;btn-toolbar\&quot;&gt;\n\t\t\t\t  {{#if view.secondaryLabel}}\n\t\t\t\t  \t{{view Tent.Button buttonClass=\&quot;close-dialog pull-left cancel\&quot; labelBinding=\&quot;view.secondaryLabel\&quot; actionBinding=\&quot;view.secondaryAction\&quot; targetBinding=\&quot;view.secondaryTarget\&quot; typeBinding=\&quot;view.secondaryType\&quot; iconClassBinding=\&quot;view.secondaryIcon\&quot;}}\n\t\t\t\t  {{/if}}\n\t\t\t\t  {{#if view.primaryLabel}}\n\t\t\t\t  \t{{view Tent.Button buttonClassBinding=\&quot;view.primaryButtonClass\&quot; labelBinding=\&quot;view.primaryLabel\&quot; actionBinding=\&quot;view.primaryAction\&quot; targetBinding=\&quot;view.primaryTarget\&quot; typeBinding=\&quot;view.primaryType\&quot; iconClassBinding=\&quot;view.primaryIcon\&quot; validate=\&quot;true\&quot; warnBinding=\&quot;view.warn\&quot;}}\n\t\t\t\t  {{/if}}\n\t\t\t\t&lt;/div&gt;\n\t\t\t&lt;/div&gt;\n\t\t{{/if}}\n\t&lt;/div&gt;\n&quot;);

Ember.TEMPLATES['modal_body']=Ember.Handlebars.compile(&quot;&lt;div class=\&quot;modal-body\&quot;&gt;\n\t{{view Tent.MessagePanel type=\&quot;secondary\&quot; isActive=false collapsible=true collapsed=true}}\n\t{{#if view.text}}\n  \t\t&lt;p&gt;{{loc view.text}}&lt;/p&gt;\n  \t{{/if}}\n  \t{{yield}}\n&lt;/div&gt;&quot;);

Ember.TEMPLATES['modal_footer']=Ember.Handlebars.compile(&quot;&lt;div class=\&quot;modal-footer\&quot;&gt;\n\t&lt;div class=\&quot;btn-toolbar\&quot;&gt;\n\t\t{{yield}}\n\t&lt;/div&gt;\n&lt;/div&gt;&quot;);


<span id='Tent-ModalPane'>/**
</span>* @class Tent.ModalPane
* Display a model popup panel.
* 
* A button will be displayed to allow the popup to be launched. You provide a {@link #label}
* and optionally a {@link #type} for the button. If no label is provided, the button will not be displayed 
* and the popup will be displayed automatically.
* You may alternatively associate a separate element to launch the popup when clicked, by specifying a {@link #customButton}
* value, which should be the id of the element.
*
* Text to go into the header of the popup is provided using the {@link #header} property.
*
* The body of the popup may be provided either by the {@link #text} property, or by nesting 
* content within the view (using {{#view}} rather than {{view}}).
*
* Labels for the button in the popup are provided by the {@link #primaryLabel} and {@link #secondaryLabel} properties.
*
* The primary button action is configured using the {@link #primaryAction} and {@link #primaryTarget} property pair.
* Similarly use {@link #secondaryAction} and {@link #secondaryTarget} for the secondary button.
* The close button (located at the top right), is bound to the secondary action, unless a {@link #closeAction} is provided.
*
* The dialog can be closed when clicking the primary button by adding 'primaryButtonClass=&quot;close-dialog&quot;'
*
* When the dialog is closed by clicking outside the dialog, the secondary action will be called.
*
* ## Usage
*
*       {{#view Tent.ModalPane   
                text=&quot;_modalText&quot; 
                buttonClass=&quot;&quot;
                type=&quot;primary&quot;
                header=&quot;_modalHeader&quot; 
                primaryLabel=&quot;_ok&quot; 
                secondaryLabel=&quot;_cancel&quot;
                primaryAction=&quot;modalSubmit&quot;
                primaryTargetBinding=&quot;Pad&quot;
                secondaryAction=&quot;modalCancel&quot;
                secondaryTargetBinding=&quot;Pad&quot;
                closeAction=&quot;clearUp&quot;
                closeTargetBinding=&quot;controller&quot;
                primaryIcon=&quot;&quot;
                secondaryIcon=&quot;icon-remove icon-white&quot;
            }}
              &lt;h5&gt;Some more content&lt;/h5&gt;
        {{/view}}
*
* &lt;h4&gt; Validation &lt;/h4&gt;
* The primary button will by default have validation set to true. This means that widgets within the modal dialog
* will be validated on submission, and any errors that occur will be displayed in an error panel within the modal.
* The primary button will be disabled until all of the validation errors have been corrected. 
*
* ## Alternate Usage
*
* If you need more complex footer content, you can provide it with a dedicated {@link Tent.ModalFooter} view.
* In this instance, you also need to provide a {@link Tent.ModalBody} for the body content.
*
*
* Usage is like:

    {{#view Tent.ModalPane 
          label=&quot;Using Custom Footer&quot; 
          header=&quot;_modalHeader&quot; 
          customContent=true
    }}
      {{#view Tent.ModalBody}}
        body content goes here ...
      {{/view}}
      {{#view Tent.ModalFooter}}
        {{view Tent.Button buttonClass=&quot;close-dialog pull-left cancel&quot; label=&quot;cancel&quot; type=&quot;secondary&quot;}}
        {{view Tent.Button buttonClass=&quot;&quot; label=&quot;go&quot; type=&quot;primary&quot; validate=true}}
        ... other buttons ...
      {{/view}}
    {{/view}}

 - In order to use the ModalBody and ModalFooter views, you must set {@link #customContent} to true.
 - Any button that will close the dialog should have a css class of 'close-dialog'
 - The cancel button should be identified with a css class of 'cancel'. In the event that the Modal is 
 closed by this button, or the 'x' close button, or by clicking outside of the modal, then the action 
 associated with the cancel button will be executed.
*
*/


(function() {
Tent.ModalPane = Ember.View.extend({
    layoutName: 'modal_pane',
    classNames: ['tent-widget', 'control-group', 'tent-modal', 'tent-form'],
<span id='Tent-ModalPane-property-label'>    /**
</span>    * @property {String} label The label for the launch button
    */

    label: null,
<span id='Tent-ModalPane-property-header'>    /**
</span>    * @property {String} header The text to display in the header section of the modal dialog
    */

    header: null,
<span id='Tent-ModalPane-property-text'>    /**
</span>    * @property {String} text The text to display in the body section.
    * The dialog will also display any nested content in the body section, so in that case the 
    * text property would be optional
    */

    text: null,
<span id='Tent-ModalPane-property-type'>    /**
</span>    * @property {String} type The type of button used to launch the dialog. May be
    * one of {@link Tent.Button#type}
    */

    type: &quot;primary&quot;,
<span id='Tent-ModalPane-property-primaryLabel'>    /**
</span>    * @property {String} primaryLabel The label for the primary button
    */

    primaryLabel: null,
<span id='Tent-ModalPane-property-secondaryLabel'>    /**
</span>    * @property {String} secondaryLabel The label for the secondary button
    */

    secondaryLabel: null,
<span id='Tent-ModalPane-property-primaryAction'>    /**
</span>    * @property {String} primaryAction The method to execute when the primary button is clicked
    */

    primaryAction: null,
<span id='Tent-ModalPane-property-primaryTarget'>    /**
</span>    * @property {String} primaryTarget The target providing the action to call when the primary button is clicked
    */

    primaryTarget: null,
<span id='Tent-ModalPane-property-secondaryAction'>    /**
</span>    * @property {String} secondaryAction The method to execute when the secondary button is clicked
    */

    secondaryAction: &quot;hide&quot;,
<span id='Tent-ModalPane-property-secondaryTarget'>    /**
</span>    * @property {String} secondaryTarget The target providing the action to call when the primary button is clicked
    */

    secondaryTarget: &quot;parentView&quot;,
<span id='Tent-ModalPane-property-primaryIcon'>    /**
</span>    * @property {String} primaryIcon An icon to display in the primary button
    */

    primaryIcon: null,
<span id='Tent-ModalPane-property-secondaryIcon'>    /**
</span>    * @property {String} secondaryIcon An icon to display in the secondary button
    */

    secondaryIcon: null,
<span id='Tent-ModalPane-property-secondaryType'>    /**
</span>    * @property {String} secondaryType The type of button to display for the secondary button. May be
    * one of {@link Tent.Button#type}
    *
    */

    secondaryType: 'secondary',
<span id='Tent-ModalPane-property-primaryType'>    /**
</span>    * @property {String} primaryType The type of button to display for the primary button. May be
    * one of {@link Tent.Button#type}
    *
    */

    primaryType: 'primary',
<span id='Tent-ModalPane-property-closeAction'>    /**
</span>    * @property {String} closeAction The method to execute when the close button is clicked.
    * This will default to the {@link #secondaryAction}
    */

    closeAction: null,
<span id='Tent-ModalPane-property-closeTarget'>    /**
</span>    * @property {String} closeTarget The target providing the action to call when the close button is clicked
    * This will default to the {@link #secondaryTarget}
    */

    closeTarget: null,
<span id='Tent-ModalPane-property-customButton'>    /**
</span>    * @property {String} customButton will allow us to link the launch of modal pane with the html element whose id we provide.
    * This will default to null
    */

    customButton: null,
<span id='Tent-ModalPane-property-customContent'>    /**
</span>    * @property {Boolean} customContent A boolean indicating that the ModalPane should not provide
    * its own body or footer. A Tent.ModalBody and Tent.ModalFooter may be provided in the nested content.
    */

    customContent: false,
<span id='Tent-ModalPane-property-autoLaunch'>    /**
</span>    * @property {Boolean} autoLaunch A boolean to indicate whether the modal panel will be displayed on entering the 
    * screen, regardless of any other property settings.
    */

    autoLaunch: null,
<span id='Tent-ModalPane-property-validate'>    /**
</span>    * @property {Boolean} validate Determines whether the primary button executes validations on 
    * the form widgets.
    */

    validate: true,
<span id='Tent-ModalPane-property-warn'>    /**
</span>    * @property {Boolean} warn A boolean to indicate that warning messages will be handled by the 
    * primary button. If warning messages of a certain severity exist, a popup will be displayed to 
    * allow the user to chose to ignore the warnings.
    */

    warn: false,
    hidden: true,
<span id='Tent-ModalPane-property-clickOutsideToClose'>    /**
</span>    * @property {Boolean} clickOutsideToClose A boolean indicating that the ModalPane should hide when
    * click outside of modal pane..
    */

    clickOutsideToClose: true,
    init: function() {
      this._super(arguments);
      if (!(this.get('closeAction') != null)) {
        this.set('closeAction', this.get('secondaryAction'));
      }
      if (!(this.get('closeTarget') != null)) {
        return this.set('closeTarget', this.get('secondaryTarget'));
      }
    },
    didInsertElement: function() {
      var modalId, widget,
        _this = this;
      if (this.get('autoLaunch')) {
        this.launch();
      } else {
        if ((!this.cancelAutoLaunch()) &amp;&amp; !((this.get('label') != null) || (this.get('customButton') != null))) {
          this.launch();
        }
      }
      if (this.get('customButton') != null) {
        widget = this;
        $(&quot;#&quot; + this.get(&quot;customButton&quot;)).click(function() {
          return widget.launch();
        });
      }
      this.$(&quot;.modal:first&quot;).on(&quot;shown&quot;, function(e) {
        return $.publish(&quot;/ui/refresh&quot;, ['resize']);
      });
      this.$(&quot;.modal:first&quot;).on(&quot;hidden&quot;, function(e) {
        if (!_this.get('hidden') &amp;&amp; _this.targetIsMessagePanel(e.target)) {
          _this.triggerCancelAction(e);
          return _this.hide();
        }
      });
      modalId = this.get('elementId');
      return this.$('.close-dialog').filter(function() {
        return $(this).parents('.tent-modal:first').attr('id') === modalId;
      }).click(function(event) {
        if (!$(event.target).attr('disabled')) {
          return _this.hide();
        }
      });
    },
    cancelAutoLaunch: function() {
      return (this.get('autoLaunch') != null) &amp;&amp; this.get('autoLaunch') === false;
    },
    primaryButtonClass: (function() {
      if (this.get('closeOnSubmit')) {
        return '.close-dialog';
      }
    }).property('closeOnSubmit'),
    targetIsMessagePanel: function(source) {
      return this.$('.modal').get(0) === source;
    },
    enableMessagePanel: function() {
      var panel, primaryPanel;
      primaryPanel = this.getPrimaryMessagePanelView();
      panel = this.getMessagePanelView();
      if (primaryPanel != null) {
        primaryPanel.setActive(false);
      }
      if (panel != null) {
        return panel.setActive(true);
      }
    },
    disableMessagePanel: function() {
      var panel, primaryPanel;
      primaryPanel = this.getPrimaryMessagePanelView();
      panel = this.getMessagePanelView();
      if (panel != null) {
        panel.clearAll();
      }
      if (primaryPanel != null) {
        primaryPanel.setActive(true);
      }
      if (panel != null) {
        return panel.setActive(false);
      }
    },
    getPrimaryMessagePanelView: function() {
      return Ember.View.views[$('.tent-message-panel.primary').attr('id')];
    },
    getMessagePanelView: function() {
      return Ember.View.views[this.$('.tent-message-panel:first').attr('id')];
    },
    triggerCancelAction: function(e) {
      var buttonView, id, modal, selectedCancel;
      modal = this;
      selectedCancel = null;
      this.$('.cancel').each(function() {
        if ($(this).parents('.tent-modal:first').attr('id') === modal.get('elementId')) {
          return selectedCancel = $(this);
        }
      });
      if ((selectedCancel != null) &amp;&amp; selectedCancel.length &gt; 0) {
        id = selectedCancel.parent('.tent-button').attr('id');
        buttonView = Ember.View.views[id];
        return buttonView.triggerAction();
      }
    },
    willDestroyElement: function() {
      return this.hide();
    },
    launch: function() {
      this.set('hidden', false);
      this.$('.modal:first').modal(this.get('options'));
      this.fadeParentModal();
      return this.enableMessagePanel();
    },
    hide: function() {
      this.set('hidden', true);
      this.restoreParentModal();
      this.$('.modal:first').modal('hide');
      return this.disableMessagePanel();
    },
    fadeParentModal: function() {
      var parentBackdrop;
      parentBackdrop = this.$().parents('.tent-modal:first').find('.modal-backdrop:first');
      parentBackdrop.hide().attr('data-hidden', true);
      if (parentBackdrop.length &gt; 0) {
        return this.$('.modal-backdrop:first').fadeIn(0).attr('data-hidden', false);
      } else {
        return this.$('.modal-backdrop:first').fadeIn(200).attr('data-hidden', false);
      }
    },
    restoreParentModal: function() {
      var parentBackdrop;
      parentBackdrop = this.$().parents('.tent-modal:first').find('.modal-backdrop:first');
      parentBackdrop.show().attr('data-hidden', false);
      if (parentBackdrop.length &gt; 0) {
        return this.$('.modal-backdrop:first').fadeOut(0).attr('data-hidden', true);
      } else {
        return this.$('.modal-backdrop:first').fadeOut(200).attr('data-hidden', true);
      }
    },
    backdrop: (function() {
      if (!this.get('clickOutsideToClose')) {
        return 'static';
      } else {
        return 'true';
      }
    }).property('clickOutsideToClose')
  });

  Tent.ModalHeader = Ember.View.extend({
    tagName: 'h3',
    defaultTemplate: Ember.Handlebars.compile('{{loc view.parentView.header}}')
  });

<span id='Tent-ModalBody'>  /**
</span>  * @class Tent.ModalBody
  * Add a body panel to a modal dialog.
  *
  * This view should be used only within a Tent.ModalPane which has its {@link Tent.ModalPane#customContent} property set to true
  */


  Tent.ModalBody = Ember.View.extend({
    layoutName: 'modal_body'
  });

<span id='Tent-ModalFooter'>  /**
</span>  * @class Tent.ModalFooter
  * Add a footer panel to a modal dialog.
  *
  * This view should be used only within a Tent.ModalPane which has its {@link Tent.ModalPane#customContent} property set to true
  */


  Tent.ModalFooter = Ember.View.extend({
    layoutName: 'modal_footer'
  });

}).call(this);



<span id='Tent-ProgressBar'>/**
</span>* @class Tent.ProgressBar
* 
* Usage
* 		{{view Tent.ProgressBar isStriped=true progress=&quot;50&quot; isAnimated=true}}
*/


(function() {

  Tent.ProgressBar = Ember.View.extend({
    classNames: ['tent-progress-bar', 'progress'],
    classNameBindings: ['isStriped:progress-striped', 'isAnimated:active'],
    template: Ember.Handlebars.compile('&lt;div class=&quot;bar&quot; {{bindAttr style=&quot;view.style&quot;}}&gt;&lt;/div&gt;'),
<span id='Tent-ProgressBar-property-isAnimated'>    /**
</span>    * @property {Boolean} isAnimated Boolean to indicate if the bar should be rendered with a progress animation.
    */

    isAnimated: false,
<span id='Tent-ProgressBar-property-isStriped'>    /**
</span>    * @property {Boolean} isStriped Boolean to indicate if the bar should be rendered with stripes
    */

    isStriped: false,
<span id='Tent-ProgressBar-property-progress'>    /**
</span>    * @property {Number} progress The progress to be displayed, as a percentage between 0 and 100
    */

    progress: 0,
    style: Ember.computed(function() {
      return &quot;width:&quot; + this.get('progress') + &quot;%;&quot;;
    }).property('progress')
  });

}).call(this);


Ember.TEMPLATES['button']=Ember.Handlebars.compile(&quot;&lt;div \t{{bindAttr class=\&quot;view.classes view.buttonClass\&quot;}}\n\t\t{{action triggerAction target=\&quot;view\&quot;}}\n\t\t{{bindAttr data-toggle=\&quot;view.dataToggle\&quot;}}\n    {{bindAttr disabled=\&quot;view.isDisabled\&quot;}}\n    {{bindAttr title=\&quot;view.localizedTitle\&quot;}}\n\t\trole=\&quot;button\&quot;\n\t\t&gt;\n  &lt;i {{bindAttr class=\&quot;view.iconClass\&quot;}}&gt;&lt;/i&gt; {{view.localizedLabel}}\n  {{#if view.hasOptions}}\n  \t &lt;span class=\&quot;caret\&quot;&gt;&lt;/span&gt;\n  {{/if}}\n&lt;/div&gt;\n{{#if view.hasOptions}}\n\t{{collection contentBinding=\&quot;view._options\&quot; tagName=\&quot;ul\&quot; classNames=\&quot;dropdown-menu\&quot; itemViewClass=\&quot;Tent.ButtonOptions\&quot;}}\n{{/if}}\n\n{{#if view.warn}}\n\n\t{{#view Tent.ModalPane \n          autoLaunch=false\n          header=\&quot;tent.warning.header\&quot; \n          primaryLabel=\&quot;tent.button.proceed\&quot; \n          secondaryLabel=\&quot;tent.button.dontProceed\&quot;\n          primaryType=\&quot;warning\&quot;\n          primaryIcon=\&quot;icon-ok icon-white\&quot;\n          secondaryIcon=\&quot;icon-remove\&quot;\n          primaryAction=\&quot;ignoreWarnings\&quot;\n          primaryTargetBinding=\&quot;view\&quot;\n    }}\n    \t{{loc tent.warning.warningsOnPage}}\n    \t \n  \t\t{{#each view.parentView.messagePanel.warning}}\n  \t\t\t\t&lt;div class=\&quot;alert\&quot;&gt;\n  \t\t\t\t\t&lt;strong&gt;{{loc label}}:&lt;/strong&gt;  {{messages}}\n  \t\t\t\t&lt;/div&gt;\n  \t\t{{/each}}\n\t\t\t \n    {{/view}}\n{{/if}}&quot;);


<span id='Tent-Button'>/**
</span>* @class Tent.Button
*
* ##Usage
* 
*       {{view Tent.Button label=&quot;_buttonClickMe&quot; type=&quot;primary&quot; action=&quot;clickEvent&quot; target=&quot;Pad&quot;}}
*/


(function() {
Tent.Button = Ember.View.extend(Ember.TargetActionSupport, {
    classNames: ['tent-button'],
    classNameBindings: ['hasOptions:tent-button-group button-group'],
    templateName: 'button',
<span id='Tent-Button-property-label'>    /**
</span>    * @property {String} label The label for the button
    */

    label: 'Button',
<span id='Tent-Button-property-title'>    /**
</span>    * @property {String} title The title for the button (HTML title which shows on element hover)
    */

    title: null,
    messagePanel: null,
    localizedLabel: (function() {
      return Tent.I18n.loc(this.get('label'));
    }).property('label'),
    localizedTitle: (function() {
      return Tent.I18n.loc(this.get('title'));
    }).property('title'),
<span id='Tent-Button-property-type'>    /**
</span>    * @property {String} type The type of button.
    * Valid types are:
    *
    * - **primary**: Provides extra visual weight and identifies the primary action in a set of buttons
    * - **info**: Used as an alternative to the default styles
    * - **success**: Indicates a successful or positive action
    * - **warning**: Indicates caution should be taken with this action
    * - **danger**: Indicates a dangerous or potentially negative action
    * - **inverse**: Alternate dark gray button, not tied to a semantic action or use
    * - **link**: Deemphasize a button by making it look like a link while maintaining button behavior
    *
    */

    type: 'primary',
    isDisabled: false,
<span id='Tent-Button-property-disabled'>    /**
</span>    * @property disabled {Boolean} A boolean to indicate that the button is disabled
    */

    disabled: null,
<span id='Tent-Button-property-enabled'>    /**
</span>    * @property enabled {Boolean} A boolean to indicate that the button is enabled
    * This is used as a convenience property for avoiding having to use negative handlebars bindings
    */

    enabled: null,
<span id='Tent-Button-property-action'>    /**
</span>    * @property {String} action The action to be invoked on the target when the button is clicked
    */

    action: null,
<span id='Tent-Button-property-target'>    /**  
</span>    * @property {Object} target The target which hosts the action function.
    */

    target: null,
<span id='Tent-Button-property-validate'>    /**
</span>    * @property {Boolean} validate If validate is set to true, all fields on the current form
    * need to be valid before the action will be executed. The Button will execute a form validation
    * if it has not happened already.
    */

    validate: false,
<span id='Tent-Button-property-warn'>    /**
</span>    * @property {Boolean} warn If warn is set to true, a dialog will be presented if there are any 
    * warnings pending on the page. The user will be asked to either procede, ignoring the warnings, or to 
    * cancel the button action and fix the warnings. {@link #validate} must also be set to true to 
    * enable this property.
    */

    warn: false,
<span id='Tent-Button-property-iconClass'>    /**
</span>    * @property {String} iconClass The css class to assign an icon to the button e.g. 'icon-remove icon-white'
    */

    iconClass: null,
    optionLabelPath: 'label',
    optionTargetPath: 'target',
    optionActionPath: 'action',
    init: function() {
      this._super();
      this.set('_options', Ember.ArrayProxy.create({
        content: this.get('optionList')
      }) || []);
      if (this.get('disabled') != null) {
        this.set('isDisabled', this.get('disabled'));
      }
      if (this.get('enabled') != null) {
        return this.set('isDisabled', !this.get('enabled'));
      }
    },
    targetObject: (function() {
      var target, value;
      target = this.get('target');
      if (Ember.typeOf(target) === &quot;string&quot;) {
        value = Em.get(this, target);
        if (value === undefined) {
          value = Em.get(window, target);
        }
        target = value;
      }
      return target || this.get('context.target') || this.get('content') || this.get('context');
    }).property('target', 'content', 'context'),
    triggerAction: function(dontValidate) {
      if (!this.get('isDisabled') &amp;&amp; this.get('validate') &amp;&amp; !dontValidate === false) {
        this.doValidation();
      }
      if (!this.get('isDisabled')) {
        if (!this.get('hasOptions')) {
          if (this.get('warn') === true &amp;&amp; this.get('doWarningsExist')) {
            return this.showWarningPanel();
          } else {
            return this._super();
          }
        } else {
          return this.$().toggleClass('open');
        }
      } else {
        return false;
      }
    },
    classes: (function() {
      var classes, type;
      classes = ((type = this.get(&quot;type&quot;)) !== null &amp;&amp; this.BUTTON_CLASSES.indexOf(type.toLowerCase()) !== -1 ? &quot;btn btn-&quot; + type.toLowerCase() : &quot;btn&quot;);
      if (this.get(&quot;hasOptions&quot;)) {
        classes = classes.concat(&quot; dropdown-toggle&quot;);
      }
      if (this.get(&quot;isDisabled&quot;)) {
        classes = classes.concat(&quot; disabled&quot;);
      }
      return classes;
    }).property('type', 'hasOptions', 'isDisabled'),
    hasOptions: (function() {
      var options;
      options = this.get(&quot;optionList&quot;);
      return options !== undefined &amp;&amp; options.get('length') !== 0;
    }).property('_options'),
    BUTTON_CLASSES: ['primary', 'secondary', 'info', 'success', 'warning', 'danger', 'inverse', 'link'],
    optionList: (function() {
      var content, options;
      options = (options = this.get('options'));
      if (options === undefined &amp;&amp; (content = this.get('content')) !== undefined) {
        options = content.get('options');
      }
      return options;
    }).property('options', 'content').volatile(),
    doValidation: function() {
      var form;
      this.setupMessageBind();
      form = this.findParentForm();
      if (form != null) {
        return this.validateChildViews(form);
      }
    },
    validateChildViews: function(parentView) {
      var view, _i, _len, _ref, _results;
      _ref = parentView.get('childViews');
      _results = [];
      for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
        view = _ref[_i];
        if (typeof view.validate === 'function') {
          view.validate();
        }
        if (view.get('childViews') != null) {
          _results.push(this.validateChildViews(view));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    findParentForm: function() {
      var $form;
      $form = this.$().parents('.tent-form:first');
      if ($form.length &gt; 0) {
        return Ember.View.views[$form.attr('id')];
      }
    },
    setupMessageBind: function() {
      var mp;
      mp = this.getMessagePanel();
      if (mp != null) {
        return this.set('messagePanel', mp);
      }
    },
    getMessagePanel: function() {
      var mp, view;
      mp = $('.tent-message-panel.active');
      if (mp.length &gt; 0) {
        return view = Ember.View.views[mp.attr('id')];
      }
    },
    disableButtonIfErrorsExist: (function() {
      var mp;
      mp = this.get('messagePanel');
      if (mp != null) {
        return this.set('isDisabled', mp.get('hasErrors'));
      }
    }).observes('messagePanel', 'messagePanel.hasErrors'),
    disabledDidChange: (function() {
      return this.set('isDisabled', this.get('disabled'));
    }).observes('disabled'),
    enabledDidChange: (function() {
      return this.set('isDisabled', !this.get('enabled'));
    }).observes('enabled'),
    isDisabledDidChange: (function() {
      var d;
      return d = this.get('isDisabled');
    }).observes('isDisabled'),
    doWarningsExist: (function() {
      return this.get('messagePanel.hasSevereWarnings');
    }).property('messagePanel', 'messagePanel.hasSevereWarnings'),
    ignoreWarnings: function() {
      this.get('messagePanel').clearWarnings();
      this.hideWarningPanel();
      return this.triggerAction(false);
    },
    showWarningPanel: function() {
      var modal;
      modal = Ember.View.views[this.$('.tent-modal').attr('id')];
      return modal.launch();
    },
    hideWarningPanel: function() {
      var modal;
      modal = Ember.View.views[this.$('.tent-modal').attr('id')];
      return modal.hide();
    }
  });

  Tent.ButtonOptions = Ember.View.extend(Ember.TargetActionSupport, {
    template: Ember.Handlebars.compile('&lt;a href=&quot;#&quot;&gt;{{#if view.content.iconClass}}&lt;i {{bindAttr class=&quot;view.content.iconClass&quot;}}&gt;&lt;/i&gt;{{/if}} {{loc view.label}}&lt;/a&gt;'),
    optionLabelBinding: 'parentView.parentView.optionLabelPath',
    optionTargetBinding: 'parentView.parentView.optionTargetPath',
    optionActionBinding: 'parentView.parentView.optionActionPath',
    click: function() {
      var button;
      button = this.get('parentView.parentView');
      button.$().toggleClass('open');
      return this.triggerAction();
    },
    label: (function() {
      var content;
      content = this.get('content');
      return content.get(this.get('optionLabel')) || content.get(this.get('optionAction')).camelToWords();
    }).property('content'),
    target: (function() {
      var content;
      content = this.get('content');
      return content.get(this.get('optionTarget')) || this.get(&quot;parentView.parentView.context.target&quot;) || this.get(&quot;parentView.parentView.content&quot;) || this.get(&quot;parentView.parentView.context&quot;);
    }).property('content'),
    action: (function() {
      var content;
      content = this.get('content');
      return content.get(this.get('optionAction'));
    }).property('content')
  });

}).call(this);


Ember.TEMPLATES['accordion_group']=Ember.Handlebars.compile(&quot;{{#if view.title}}\n\t&lt;div class=\&quot;accordion-heading\&quot;&gt;\n\t\t&lt;a class=\&quot;accordion-toggle\&quot; data-toggle=\&quot;collapse\&quot; \n\t\t\t{{bindAttr data-parent=\&quot;view.dataParent\&quot;}}\n\t\t\t{{bindAttr href=\&quot;view.href\&quot;}}&gt;\n\t\t\t{{loc view.title}}\n\t\t&lt;/a&gt;\n\t&lt;/div&gt;\n\t&lt;div class=\&quot;accordion-body collapse\&quot; {{bindAttr id=\&quot;view.id\&quot;}}&gt;\n\t\t&lt;div class=\&quot;accordion-inner\&quot;&gt;{{yield}}&lt;/div&gt;\n\t&lt;/div&gt;\n{{else}}\n\t{{yield}}\n{{/if}}\n &quot;);

Ember.TEMPLATES['accordion_heading']=Ember.Handlebars.compile(&quot;{{#if view.title}}\n\t&lt;span&gt;\n\t\t&lt;a class=\&quot;accordion-toggle\&quot; data-toggle=\&quot;collapse\&quot; \n\t\t\t{{bindAttr data-parent=\&quot;view.dataParent\&quot;}}\n\t\t\t{{bindAttr href=\&quot;view.href\&quot;}}&gt;\n\t\t\t{{loc view.title}}\n\t\t&lt;/a&gt;\n\t&lt;/span&gt;\n\t&lt;span&gt;\n\t\t{{yield}}\n\t&lt;/span&gt;\n{{else}}\n\t&lt;span class=\&quot;accordion-toggle accordion-head-content\&quot;&gt;{{yield}}&lt;/span&gt;\n{{/if}}\n\t &quot;);


<span id='Tent-Accordion'>/**
</span>* @class Tent.Accordion
* 
* ##Usage 1
* 
* This format can be used when simple text links can be used in the headers
*   	{{#view Tent.Accordion}}
*	      {{#view Tent.AccordionGroup title=&quot;Title1&quot;}}
*	        {{view Tent.Button label=&quot;Button with options only&quot; type=&quot;info&quot; optionsBinding=&quot;Pad.btnOptions&quot;}}
*	      {{/view}}
*	      {{#view Tent.AccordionGroup title=&quot;Title2&quot;}}
*	          {{view Tent.TextField valueBinding=&quot;Pad.appName&quot; label=&quot;Killer Input&quot;}}
*	          {{view Tent.Checkbox label=&quot;Self Destruct now&quot; checkedBinding=&quot;Pad.privacyPolicy&quot;}}
*	      {{/view}}
*	      {{#view Tent.AccordionGroup title=&quot;Title3&quot;}}
*	          Anim pariatur cliche reprehenderit, enim eiusmod high life accusamus terry richardson ad squid.
*	      {{/view}}
*	      {{#view Tent.AccordionGroup title=&quot;Title4&quot;}}
*	          Anim pariatur cliche reprehenderit, enim eiusmod high life accusamus terry richardson ad squid.
*	      {{/view}}
*	    {{/view}}
*
* Where more complex content needs to go in the headers, this format may be used:
        {{#view Tent.Accordion}}
          {{#view Tent.AccordionGroup }}
            {{#view Tent.AccordionHeading title=&quot;Title1&quot;}}
              &lt;b&gt;Some header content&lt;/b&gt;  
            {{/view}}
            {{#view Tent.AccordionBody}}
              body content
            {{/view}}
          {{/view}}
           ...
        {{/view}}

* Or where the title needs to be located other than in the default position:
        {{#view Tent.Accordion}}
          {{#view Tent.AccordionGroup }}
            {{#view Tent.AccordionHeading}}
              &lt;b&gt;more content&lt;/b&gt;  &lt;span class=&quot;pull-right&quot;&gt;{{view Tent.AccordionTitle title=&quot;x&quot;}}&lt;/span&gt;
            {{/view}}
            {{#view Tent.AccordionBody}}
              body content
            {{/view}}
          {{/view}}
           ...
        {{/view}}
*/


(function() {
Tent.Accordion = Ember.View.extend({
    classNames: ['accordion']
  });

<span id='Tent-AccordionGroup'>  /**
</span>  * @class Tent.AccordionGroup
  * 
  * ##Usage
  * 		{{#view Tent.AccordionGroup title=&quot;_Title1&quot;}}
  *	        ...
  *	  	  {{/view}}
  *
  */


  Tent.AccordionGroup = Ember.View.extend({
    classNames: ['accordion-group'],
    layoutName: 'accordion_group',
    dataParent: (function() {
      return &quot;#&quot; + this.get(&quot;parentView.elementId&quot;);
    }).property(&quot;elementId&quot;),
    href: (function() {
      return &quot;#&quot; + this.get('elementId') + &quot; .accordion-body&quot;;
    }).property(&quot;elementId&quot;)
  });

<span id='Tent-AccordionHeading'>  /**
</span>  * @class Tent.AccordionHeading
  * Used in the case where a custom header is required for an accordion group
  */


  Tent.AccordionHeading = Ember.View.extend({
<span id='Tent-AccordionHeading-property-title'>    /**
</span>    	* @property {String} title A title to display which acts as the link text to expand the group
    	* A title may alternatively be provided by a {@link Tent.AccordionTitle} within the body of the heading
    */

    title: null,
    classNames: ['accordion-heading'],
    layoutName: 'accordion_heading',
    dataParent: (function() {
      return &quot;#&quot; + this.get(&quot;parentView.parentView.elementId&quot;);
    }).property(&quot;elementId&quot;),
    href: (function() {
      return &quot;#&quot; + this.get('parentView.elementId') + &quot; .accordion-body&quot;;
    }).property(&quot;elementId&quot;)
  });

<span id='Tent-AccordionTitle'>  /**
</span>  * @class Tent.AccordionTitle
  * Generates a title link for use within the body of a header. This link will expand and 
  * contract the group
  */


  Tent.AccordionTitle = Ember.View.extend({
    tagName: 'span',
    layout: Ember.Handlebars.compile('&lt;a class=&quot;accordion-toggle&quot; data-toggle=&quot;collapse&quot; \
		{{bindAttr data-parent=&quot;view.dataParent&quot;}}\
		{{bindAttr href=&quot;view.href&quot;}}&gt;\
		{{loc view.title}}\
	&lt;/a&gt;'),
<span id='Tent-AccordionTitle-property-title'>    /**
</span>    	* @property {String} title A title to display which acts as the link text to expand the group
    */

    title: null,
    dataParent: (function() {
      return &quot;#&quot; + this.get(&quot;parentView.parentView.parentView.elementId&quot;);
    }).property(&quot;elementId&quot;),
    href: (function() {
      return &quot;#&quot; + this.get('parentView.parentView.elementId') + &quot; .accordion-body&quot;;
    }).property(&quot;elementId&quot;)
  });

<span id='Tent-AccordionBody'>  /**
</span>  * @class Tent.AccordionBody
  * Contains the body part of an accordion group. This is used only when a {@link Tent.AccordionHeading} is required.
  */


  Tent.AccordionBody = Ember.View.extend({
    classNames: ['accordion-body', 'collapse'],
    layout: Ember.Handlebars.compile('&lt;div class=&quot;accordion-inner&quot;&gt;{{yield}}&lt;/div&gt;')
  });

}).call(this);


Ember.TEMPLATES['tabs']=Ember.Handlebars.compile(&quot;&lt;ul {{bindAttr id=\&quot;id\&quot;}} class=\&quot;nav nav-tabs\&quot;&gt;&lt;/ul&gt;\n&lt;div class=\&quot;tab-content\&quot;&gt;\n\t{{yield}}\n&lt;/div&gt;&quot;);

(function() {
<span id='Tent-Tabs'>/**
</span>  * @class Tent.Tabs
  * Display a group of {@link Tent.TabPane}s
  *
  * Usage 
  *        {{#view Tent.Tabs active=&quot;settings&quot;}}
                {{#view Tent.TabPane id=&quot;profile&quot; title=&quot;_profile&quot;}}
                    Lorem ipsum dolor sit amet, consectetur adipisicing elit.
                {{/view}}
                {{#view Tent.TabPane id=&quot;messages&quot; title=&quot;_messages&quot;}}
                    Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium,
                {{/view}}
                {{#view Tent.TabPane id=&quot;settings&quot; title=&quot;_settings&quot;}}
                    At vero eos et accusamus et iusto odio dignissimos ducimus
                {{/view}}
            {{/view}}
  */


  Tent.Tabs = Ember.View.extend({
    layoutName: 'tabs',
    fixedHeader: false,
    classNames: ['tent-tabs'],
    classNameBindings: ['fixedHeader'],
<span id='Tent-Tabs-property-active'>    /**
</span>    * @property {String} active The id of the tabpane which should be initially displayed
    */

    active: null,
    didInsertElement: function() {
      var _this;
      _this = this;
      return _this.$().on(&quot;shown&quot;, 'a[data-toggle=&quot;tab&quot;]', function(e) {
        _this.set('active', $(this).attr('href').replace('#', ''));
        return $.publish(&quot;/ui/refresh&quot;, ['tab-shown']);
      });
    }
  });

<span id='Tent-TabPane'>  /**
</span>  * @class Tent.TabPane
  * An individual tab pane to be displayed as part of a {@link Tent.Tabs}
  *
  * Usage 
  *       {{#view Tent.TabPane id=&quot;profile&quot; title=&quot;_profile&quot;}}
              Lorem ipsum dolor sit amet, consectetur adipisicing elit.
          {{/view}}
  */


  Tent.TabPane = Ember.View.extend({
    classNames: [&quot;tab-pane&quot;],
    layout: Ember.Handlebars.compile('{{yield}}'),
<span id='Tent-TabPane-property-id'>    /**
</span>    * @property {String} id The id of the pane. This should be unique for the page
    */

    id: null,
<span id='Tent-TabPane-property-title'>    /**
</span>    * @property {String} title The title for the pane. This title will be translated and displayed in a tab by the containing {@link Tent.Tabs}.
    */

    title: null,
<span id='Tent-TabPane-method-didInsertElement'>    /**
</span>    * The title will be updated from the bindings, but there is a race condition between the
    * Instantiation of the view and change of title, now there are two cases
    * 1) if the value is changed before this view is instantiated the observer
    * will not fire because the value is set and will not change, in that case
    * we would need to call the observer explicitely in the didInsertElement for
    * this view to render that tab element.
    * 2) if the value is set after this view is instantiated the observer will
    * automatically fire and will render the required tab element, and once
    * the value of the title is set, the observer won't do anything
    */

    didInsertElement: function() {
      this.updateTitle();
      return this.resize();
    },
    updateTitle: (function() {
      var href, title;
      if (!Ember.empty(this.get(&quot;title&quot;))) {
        title = Tent.I18n.loc(this.get(&quot;title&quot;));
        href = &quot;#&quot; + this.get(&quot;elementId&quot;);
        if (!this.exists(href)) {
          this.get(&quot;parentView&quot;).$(&quot;ul:first&quot;).append(&quot;&lt;li&gt;&lt;a href=\&quot;&quot; + href + &quot;\&quot; data-toggle=\&quot;tab\&quot;&gt;&quot; + title + &quot;&lt;/a&gt;&lt;/li&gt;&quot;);
          if (this.get(&quot;parentView.active&quot;) === this.get(&quot;elementId&quot;)) {
            return this.getTabWithHref(this.get(&quot;parentView.active&quot;)).tab(&quot;show&quot;);
          }
        }
      }
    }).observes(&quot;title&quot;),
<span id='Tent-TabPane-method-exists'>    /**
</span>    * This method checks whether there already exists an element with same href as the href of this 
    * view instance, if there is it will update the element's title and return true, so that it is not 
    * appended on the tabs
    */

    exists: function(href) {
      var list, list_item, _i, _len;
      list = this.get(&quot;parentView&quot;).$(&quot;ul:first&quot;)[0].children;
      for (_i = 0, _len = list.length; _i &lt; _len; _i++) {
        list_item = list[_i];
        if (list_item.children[0].getAttribute(&quot;href&quot;) === href) {
          $(list_item.children[0]).html(this.get('title'));
          return true;
        }
      }
      return false;
    },
    getTabWithHref: function(href) {
      return this.get(&quot;parentView&quot;).$(&quot;a[href=#&quot; + href + &quot;]&quot;);
    },
    resize: function() {
      var parentView, topOffset;
      parentView = this.get('parentView');
      if (parentView.get('fixedHeader')) {
        topOffset = parentView.$('.nav-tabs').height();
        return parentView.$('.tab-content').css('top', topOffset + 'px');
      }
    }
  });

}).call(this);


(function() {

  Tent.JQWidget = Em.Mixin.create({
    init: function() {
      this.set('options', this._gatherOptions());
      return this._super();
    },
    didInsertElement: function() {
      this._super();
      return this._gatherEvents(this.get('options'));
    },
    willDestroyElement: function() {
      var observers, prop, ui, _i, _len;
      this._super();
      ui = this.get('ui');
      if (ui) {
        observers = this._observers;
        for (_i = 0, _len = observers.length; _i &lt; _len; _i++) {
          prop = observers[_i];
          this.removeObserver(prop, observers[prop]);
        }
        return ui._destroy();
      }
    },
    _gatherOptions: function() {
      var options, optionsCallback, uiOptions;
      uiOptions = this.get('uiOptions');
      options = {};
      optionsCallback = function(key) {
        var observer;
        options[key] = this.get(key) || this.get('defaultOptions')[key];
        observer = function() {
          var value;
          return value = this.get(key);
        };
        this.addObserver(key, observer);
        this._observers = this._observers || {};
        return this._observers[key] = observer;
      };
      uiOptions.forEach(optionsCallback, this);
      return options;
    },
    _gatherEvents: function(options) {
      var self, uiEvents;
      uiEvents = this.get('uiEvents') || [];
      self = this;
      return uiEvents.forEach(function(event) {
        var callback;
        callback = self[event];
        if (callback) {
          return options[event] = function(event, ui) {
            return callback.call(self, event, ui);
          };
        }
      });
    }
  });

}).call(this);



<span id='Tent-DateField'>/**
</span>* @class Tent.DateField
* @extends Tent.TextField
* Usage
*       {{view Tent.DateField label=&quot;&quot; 
			valueBinding=&quot;&quot; 
			showOtherMonths=true  
			dateFormat=&quot;&quot;
         }}
*/


(function() {
Tent.DateField = Tent.TextField.extend(Tent.JQWidget, {
    uiType: 'datepicker',
    uiOptions: ['dateFormat', 'changeMonth', 'changeYear', 'minDate', 'maxDate', 'showButtonPanel', 'showOtherMonths', 'selectOtherMonths', 'showWeek', 'firstDay', 'numberOfMonths', 'showOn', 'buttonImage', 'buttonImageOnly', 'showAnim', 'disabled'],
    classNames: ['tent-date-field'],
    placeholder: (function() {
      return this.get('options').dateFormat;
    }).property('options.dateFormat'),
    valueForMandatoryValidation: (function() {
      return this.get('formattedValue');
    }).property('formattedValue'),
    defaultOptions: {
      dateFormat: Tent.Formatting.date.getFormat(),
      changeMonth: true,
      changeYear: true,
      showOn: &quot;button&quot;,
      buttonImage: &quot;stylesheet/images/calendar.gif&quot;,
      buttonImageOnly: true
    },
    init: function() {
      return this._super();
    },
    didInsertElement: function() {
      this._super(arguments);
      return this.$('input').datepicker(this.get('options'));
    },
    optionDidChange: (function() {
      if (this.get('disabled') || this.get('isReadOnly') || this.get('readOnly')) {
        return this.$('input').datepicker('disable');
      } else {
        return this.$('input').datepicker('enable');
      }
    }).observes('disabled', 'readOnly', 'isReadOnly'),
    validate: function() {
      var isValid, isValidDate;
      isValid = this._super();
      isValidDate = true;
      try {
        isValidDate = (this.get(&quot;formattedValue&quot;) === &quot;&quot;) || $.datepicker.parseDate(this.get('options').dateFormat, this.get(&quot;formattedValue&quot;));
      } catch (e) {
        isValidDate = false;
      }
      if (!isValidDate) {
        this.addValidationError(Tent.messages.DATE_FORMAT_ERROR);
      }
      if (isValid &amp;&amp; isValidDate) {
        this.validateWarnings();
      }
      return isValid &amp;&amp; isValidDate;
    },
    validateWarnings: function() {
      return this._super();
    },
    format: function(value) {
      return Tent.Formatting.date.format(value, this.get('dateFormat'));
    },
    unFormat: function(value) {
      try {
        return Tent.Formatting.date.unformat(value, this.get('dateFormat'));
      } catch (error) {
        return null;
      }
    }
  });

}).call(this);



<span id='Tent-DateRangeField'>/**
</span>* @class Tent.DateRangeField
* @extends Tent.TextField
* 
* This widget wraps the Filament Date Range Picker control. The selected value will consist of
* two dates which are bound to the {@link #startDate} and {@link #endDate} properties. 
* The {@link #value} property is also bound with the string value of the range, as seen in the 
* input control ('date1 - date2').
*
* The initial value can be sourced from the value property if provided. If no value is provided,
* then the startDate and endDate properties will be used to initialize the control.
* 
* Usage
*       {{view Tent.DateRangeField label=&quot;&quot; 
			valueBinding=&quot;&quot; 
			startDateBinding=&quot;&quot;
			endDateBinding=&quot;&quot;
			showOtherMonths=true  
			dateFormat=&quot;&quot;
         }}
*/


(function() {
Tent.DateRangeField = Tent.TextField.extend({
    classNames: ['tent-date-range-field'],
<span id='Tent-DateRangeField-property-presetRanges'>    /**
</span>    	* @property {Array} presetRanges Array of objects to be made into menu range presets. 
    	* 
    	* Each object requires 3 properties:
    	* - text: string, text for menu item
    	* - dateStart: date.js string, or function which returns a date object, start of date range
    	* - dateEnd: date.js string, or function which returns a date object, end of date range
    */

    presetRanges: null,
<span id='Tent-DateRangeField-property-presets'>    /**
</span>    	* @property {Array} 
    	* Available options are: 
    	* - 'specificDate'
    	* - 'allDatesBefore'
    	* - 'allDatesAfter'
    	* - 'dateRange'. 
    	*
    	* Each can be passed a string for link and label text. (example: presets: {specificDate: 'Pick a date'} )
    */

    presets: null,
<span id='Tent-DateRangeField-property-rangeSplitter'>    /**
</span>    	* @property {String} rangeSplitter The character to use between two dates in the range
    */

    rangeSplitter: ',',
<span id='Tent-DateRangeField-property-earliestDate'>    /**
</span>    	* @property {Date} earliestDate The earliest date allowed in the system. e.g. the 'All Dates Before'
    	* range will use this as the first date in the range
    */

    earliestDate: null,
<span id='Tent-DateRangeField-property-latestDate'>    /**
</span>    	* @property {Date} latestDate The latest date allowed in the system. e.g. the 'All Dates After'
    	* range will use this as the last date in the range
    */

    latestDate: null,
<span id='Tent-DateRangeField-property-closeOnSelect'>    /**
</span>    	* @property {Boolean} closeOnSelect will close the rangepicker when a full range is selected
    */

    closeOnSelect: false,
<span id='Tent-DateRangeField-property-arrows'>    /**
</span>    	* @property {Boolean} arrows will add date range advancing arrows to input.
    */

    arrows: false,
<span id='Tent-DateRangeField-property-startDate'>    /**
</span>    	* @property {Date} startDate The selected start date in the range
    */

    startDate: null,
<span id='Tent-DateRangeField-property-endDate'>    /**
</span>    	* @property {Date} endDate The selected end date in the range
    */

    endDate: null,
<span id='Tent-DateRangeField-property-dateFormat'>    /**
</span>    	* @property {String} dateFormat The expected format for each date in the range
    */

    dateFormat: Tent.Formatting.date.getFormat(),
    operators: null,
    init: function() {
      return this._super();
    },
    didInsertElement: function() {
      var widget;
      this._super(arguments);
      widget = this;
      this.initializeWithStartAndEndDates();
      this.$('input').daterangepicker({
        presetRanges: this.get('presetRanges') != null ? this.get('presetRanges') : void 0,
        presets: this.get('presets') != null ? this.get('presets') : void 0,
        rangeSplitter: this.get('rangeSplitter') != null ? this.get('rangeSplitter') : void 0,
        dateFormat: this.get('dateFormat'),
        earliestDate: this.get('earliestDate') != null ? this.get('earliestDate') : void 0,
        latestDate: this.get('latestDate') != null ? this.get('latestDate') : void 0,
        closeOnSelect: this.get('closeOnSelect'),
        arrows: this.get('arrows'),
        datepickerOptions: {
          dateFormat: this.get('dateFormat')
        },
        onChange: function() {
          return widget.change();
        }
      });
      this.handleReadonly();
      this.handleDisabled();
      return this.set('filterOp', Tent.Constants.get('OPERATOR_RANGE'));
    },
<span id='Tent-DateRangeField-method-getValue'>    /**
</span>    	* @method getValue Return the current value of the input field
    	* @return {String}
    */

    getValue: function() {
      return this.$('input').val();
    },
<span id='Tent-DateRangeField-method-setValue'>    /**
</span>    	* @method setValue Set the value of the input field
    	* @param {String} value
    */

    setValue: function(value) {
      return this.$('input').val(value);
    },
    initializeWithStartAndEndDates: function() {
      var end, start;
      if (!(this.get('value') != null)) {
        if (this.get('startDate') != null) {
          start = Tent.Formatting.date.format(this.get('startDate'), this.get('dateFormat'));
        }
        if (this.get('endDate') != null) {
          end = Tent.Formatting.date.format(this.get('endDate'), this.get('dateFormat'));
        }
        return this.setValue(start + &quot; &quot; + this.get('rangeSplitter') + &quot; &quot; + end);
      }
    },
    placeholder: (function() {
      return this.get('dateFormat') + &quot; &quot; + this.get('rangeSplitter') + &quot; &quot; + this.get('dateFormat');
    }).property('dateFormat'),
    change: function() {
      var unformatted;
      this.set(&quot;formattedValue&quot;, this.format(this.getValue()));
      this.set('isValid', this.validate());
      if (this.get('isValid')) {
        unformatted = this.unFormat(this.get('formattedValue'));
        this.set('value', unformatted);
        return this.set('formattedValue', this.format(unformatted));
      }
    },
    validate: function() {
      var endDate, endString, isValid, isValidEndDate, isValidStartDate, startDate, startString;
      isValid = this._super();
      isValidStartDate = isValidEndDate = true;
      if ((this.get('formattedValue') != null) &amp;&amp; this.get('formattedValue') !== &quot;&quot;) {
        startString = this.getValue().split(this.get('rangeSplitter'))[0];
        if (startString != null) {
          try {
            startDate = Tent.Formatting.date.unformat(startString.trim(), this.get('dateFormat'));
            this.set('startDate', startDate);
          } catch (e) {
            isValidStartDate = false;
            this.set('startDate', null);
          }
        }
        endString = this.getValue().split(this.get('rangeSplitter'))[1];
        if (endString != null) {
          try {
            endDate = Tent.Formatting.date.unformat(endString.trim(), this.get('dateFormat'));
            this.set('endDate', endDate);
          } catch (e) {
            isValidEndDate = false;
            this.set('endDate', null);
          }
        } else {
          this.set('endDate', this.get('startDate'));
        }
      }
      if (!(isValidStartDate &amp;&amp; isValidEndDate)) {
        this.addValidationError(Tent.messages.DATE_FORMAT_ERROR);
      }
      if (isValid &amp;&amp; isValidStartDate &amp;&amp; isValidEndDate) {
        this.validateWarnings();
      }
      return isValid &amp;&amp; isValidStartDate &amp;&amp; isValidEndDate;
    },
    validateWarnings: function() {
      return this._super();
    },
    format: function(value) {
      return value;
    },
    unFormat: function(value) {
      return value;
    },
    readOnlyHandler: function(e) {
      e.preventDefault();
      e.stopPropagation();
      $('.ui-daterangepicker').hide();
      return false;
    },
    handleReadonly: (function() {
      if ((this.get('readOnly') != null) &amp;&amp; this.get('readOnly')) {
        this.$('input').bind('click', this.get('readOnlyHandler'));
        return this.$('.ui-daterangepicker-prev, .ui-daterangepicker-next').css(&quot;visibility&quot;, &quot;hidden&quot;);
      } else {
        this.$('input, .ui-daterangepicker-prev, .ui-daterangepicker-next').unbind('click', this.get('readOnlyHandler'));
        return this.$('.ui-daterangepicker-prev, .ui-daterangepicker-next').css(&quot;visibility&quot;, &quot;visible&quot;);
      }
    }).observes('readOnly'),
    handleDisabled: (function() {
      if ((this.get('disabled') != null) &amp;&amp; this.get('disabled')) {
        return this.$('.ui-daterangepicker-prev, .ui-daterangepicker-next').css(&quot;visibility&quot;, &quot;hidden&quot;);
      } else {
        return this.$('.ui-daterangepicker-prev, .ui-daterangepicker-next').css(&quot;visibility&quot;, &quot;visible&quot;);
      }
    }).observes('disabled')
  });

}).call(this);


Ember.TEMPLATES['textarea']=Ember.Handlebars.compile(&quot;&lt;label class=\&quot;control-label\&quot;&gt;{{loc view.label}}&lt;span class='tent-required'&gt;&lt;/span&gt;&lt;/label&gt;\n&lt;div class=\&quot;controls\&quot;&gt;\n  &lt;div class=\&quot;input-prepend\&quot;&gt;\n    {{#if view.hasPrefix}}  \n      &lt;span class=\&quot;add-on\&quot;&gt;{{loc view.prefix}}&lt;/span&gt;\n    {{/if}}     \n    {{#if view.textDisplay}}\n      &lt;span class=\&quot;text-display\&quot;&gt;{{view.formattedValue}}&lt;/span&gt;\n    {{else}}\n      {{view Tent.TextareaInput \n          classBinding=\&quot;view.inputSizeClass\&quot; \n          valueBinding=\&quot;view.formattedValue\&quot; \n          placeholderBinding=\&quot;view.translatedPlaceholder\&quot;\n          rowsBinding=\&quot;view.rows\&quot;\n          colsBinding=\&quot;view.cols\&quot;\n      }}\n      {{#if view.hasHelpBlock}}\n        &lt;span class=\&quot;help-block\&quot; {{bindAttr id=\&quot;view.helpId\&quot;}}&gt;{{loc view.helpBlock}}&lt;/span&gt;\n      {{/if}}\n    {{/if}}\n    {{#if view.tooltip}}\n      &lt;a href=\&quot;#\&quot; rel=\&quot;tooltip\&quot; data-placement=\&quot;right\&quot; {{bindAttr data-original-title=\&quot;view.tooltipT\&quot;}}&gt;&lt;/a&gt;\n    {{/if}}\n    {{#if view.hasHelpBlock}}\n      &lt;span class=\&quot;help-block\&quot;&gt;{{loc view.helpBlock}}&lt;/span&gt;\n    {{/if}}\n    {{#if view.hasErrors}}\n      &lt;span class=\&quot;help-inline\&quot; {{bindAttr id=\&quot;view.errorId\&quot;}}&gt;{{#each error in view.validationErrors}}{{error}}{{/each}}&lt;/span&gt;\n    {{/if}}  \n  &lt;/div&gt;\n\n&lt;/div&gt;\n&quot;);


<span id='Tent-Textarea'>/**
</span>* @class Tent.Textarea
* @mixins Tent.FormattingSupport
* @mixins Tent.FieldSupport
* @mixins Tent.TooltipSupport
* @mixins Tent.AriaSupport
* @mixins Tent.Html5Support
* @mixins Tent.ReadonlySupport
* @mixins Tent.DisabledSupport
* Usage
*      {{view Tent.Textarea label=&quot;&quot; valueBinding=&quot;&quot; }}
* @property {String} label
* @property {Boolean} readonly
*/


(function() {
Tent.Textarea = Ember.View.extend(Tent.FormattingSupport, Tent.FieldSupport, Tent.TooltipSupport, {
    templateName: 'textarea',
    classNames: ['tent-textarea', 'control-group'],
    valueForMandatoryValidation: (function() {
      return this.get('formattedValue');
    }).property('formattedValue'),
    didInsertElement: function() {
      this._super();
      return this.set('inputIdentifier', this.$('textarea').attr('id'));
    },
    change: function() {
      var unformatted;
      this._super(arguments);
      this.set('isValid', this.validate());
      if (this.get('isValid')) {
        unformatted = this.unFormat(this.get('formattedValue'));
        this.set('value', unformatted);
        this.set('formattedValue', this.format(unformatted));
        return this.validateWarnings();
      }
    }
  });

  Tent.TextareaInput = Ember.TextArea.extend(Tent.AriaSupport, Tent.Html5Support, Tent.ReadonlySupport, Tent.DisabledSupport);

}).call(this);


Ember.TEMPLATES['collection_filter']=Ember.Handlebars.compile(&quot;&lt;div class=\&quot;btn-group jqgrid-title-button filter\&quot;&gt;\n\t&lt;a class=\&quot;open-dropdown\&quot; href=\&quot;#\&quot;&gt;\n\t\t&lt;i class=\&quot;icon-filter\&quot;&gt;&lt;/i&gt;\n\t\t{{loc tent.filter.filter}}\n\t\t&lt;span class=\&quot;caret\&quot;&gt;&lt;/span&gt;\n\t&lt;/a&gt;\n\t&lt;ul class=\&quot;dropdown-menu filter-panel\&quot;&gt;\n\t\t&lt;li&gt;\n\t\t\t&lt;div class=\&quot;filter-details clearfix\&quot;&gt;\n\t\t\t\t \n\t\t\t\t\t{{#if view.showFilterFields}}\n\t\t\t\t\t\t{{view Tent.FilterFieldsView collectionBinding=\&quot;view.collection\&quot;}}\t\n\t\t\t\t\t{{/if}}\n\t\t\t\t \n\t\t\t\t&lt;div class=\&quot;form-inline buttons\&quot;&gt;\n\t\t\t\t   \t{{view Tent.Button label=\&quot;tent.filter.clear\&quot; type=\&quot;secondary\&quot; action=\&quot;clearFilter\&quot; targetBinding=\&quot;view\&quot; class=\&quot;clear-filter pull-left\&quot;}}\n\t\t\t    \t{{view Tent.Button label=\&quot;tent.filter.filter\&quot; type=\&quot;primary\&quot; action=\&quot;filter\&quot; targetBinding=\&quot;view\&quot; class=\&quot;close-panel pull-right\&quot;}}\n\t\t\t\t&lt;/div&gt;\n\t\t\t&lt;/div&gt;\n\t\t\t\n\t\t&lt;/li&gt;\n\t&lt;/ul&gt;\n&lt;/div&gt;\n\n\n\n\n\n&quot;);

(function() {
<span id='Tent-CollectionFilter'>/**
</span>  * @class Tent.CollectionFilter
  *
  * Displays a filter panel which will apply the filter choices to a collection.
  *
  *
  * ##Usage
  *
  *               {{view Tent.CollectionFilter 
                    collectionBinding=&quot;Pad.remoteCollection&quot;
                   }}
  */


  Tent.CollectionFilter = Ember.View.extend(Tent.ToggleVisibility, {
<span id='Tent-CollectionFilter-property-collection'>    /**
</span>    * @property {Tent.Collection} collection The collection which is to be filtered
    */

    collection: null,
    templateName: 'collection_filter',
    classNames: ['tent-filter'],
    availableFiltersBinding: 'collection.filteringInfo.availableFilters',
    currentFilter: {
      name: &quot;&quot;,
      label: &quot;&quot;,
      description: &quot;&quot;,
      values: {}
    },
    init: function() {
      this._super();
      return this.populateFilterFromCollection();
    },
    didInsertElement: function() {
      this.set('grid', this.get('parentView.grid'));
      return this.setupToggling();
    },
    setupToggling: function() {
      var widget;
      widget = this;
      this.bindToggleVisibility(this.$(&quot;.open-dropdown&quot;), this.$(&quot;.dropdown-menu&quot;));
      return this.$(&quot;.filter-panel .close-panel .btn&quot;).click(function() {
        return widget.hideComponent(widget.$(&quot;.dropdown-menu&quot;));
      });
    },
    filteringInfoDidChange: (function() {
      return this.populateFilterFromCollection();
    }).observes('collection.filteringInfo'),
    populateFilterFromCollection: function() {
      var filter, selectedFilter, _i, _len, _ref, _results;
      if ((this.get('collection.filteringInfo') != null) &amp;&amp; (this.get('collection.filteringInfo.selectedFilter') != null)) {
        _ref = this.get('collection.filteringInfo.availableFilters');
        _results = [];
        for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
          filter = _ref[_i];
          if (filter.name === this.get('collection.filteringInfo.selectedFilter')) {
            selectedFilter = filter;
            this.set('currentFilter.name', selectedFilter.name);
            this.set('currentFilter.label', selectedFilter.label);
            this.set('currentFilter.description', selectedFilter.description);
            this.set('currentFilter.values', selectedFilter.values);
            _results.push(this.ensureAllFieldsRepresented());
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    },
    ensureAllFieldsRepresented: function() {
      var column, filter, _i, _len, _ref, _results;
      filter = this.get('currentFilter');
      _ref = this.get('collection.columnsDescriptor');
      _results = [];
      for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
        column = _ref[_i];
        if (column.filterable !== false) {
          if (!(filter.values[column.name] != null)) {
            _results.push(this.set('currentFilter.values.' + column.name, {
              field: column.name,
              op: &quot;&quot;,
              data: &quot;&quot;
            }));
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    clearFilter: function() {
      return this.clearView(this);
    },
    clearView: function(parentView) {
      var view, _i, _len, _ref, _results;
      _ref = parentView.get('childViews');
      _results = [];
      for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
        view = _ref[_i];
        if (view.clear != null) {
          view.clear();
        }
        if (view.get('childViews') != null) {
          _results.push(this.clearView(view));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    filter: function() {
      this.stopGroupingOnGrid();
      return this.get('collection').doFilter(this.get('currentFilter'));
    },
    showFilterFields: (function() {
      return this.get('collection.isLoaded');
    }).property('collection.isLoaded'),
    stopGroupingOnGrid: function() {
      if (this.get('grid') != null) {
        return this.get('grid').clearAllGrouping();
      }
    },
    saveFilter: function() {
      this.get('collection').saveFilter(this.get('currentFilter'));
      this.set('dropdownSelection', {
        name: this.get('currentFilter').name,
        label: this.get('currentFilter').label
      });
      return true;
    },
    newFilter: function() {
      return this.clearFilter();
    },
    collapsiblePanel: (function() {
      return &quot;#&quot; + this.get('elementId') + ' .filter-details';
    }).property(),
    doSearch: function() {
      return this.get('collection').search(this.get('searchValue'));
    }
  });

  Tent.FilterDefinition = Ember.Object.extend({
    name: &quot;&quot;,
    label: &quot;&quot;,
    description: &quot;&quot;,
    values: {}
  });

  Tent.FilterFieldsView = Ember.ContainerView.extend({
    classNames: ['form-horizontal'],
    collection: null,
    collectionFilterBinding: 'parentView',
    init: function() {
      this._super();
      this.set('collectionFilter', this.get('parentView'));
      return this.populateContainer();
    },
    populateContainer: function() {
      var column, fieldView, _i, _len, _ref, _results;
      if (this.get('collection.columnsDescriptor') != null) {
        _ref = this.get('collection.columnsDescriptor');
        _results = [];
        for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
          column = _ref[_i];
          fieldView = null;
          if (column.filterable !== false) {
            switch (column.type) {
              case &quot;string&quot;:
                fieldView = Tent.TextField.create({
                  label: Tent.I18n.loc(column.title),
                  isFilter: true,
                  valueBinding: &quot;parentView.collectionFilter.currentFilter.values.&quot; + column.name + &quot;.data&quot;,
                  filterOpBinding: &quot;parentView.collectionFilter.currentFilter.values.&quot; + column.name + &quot;.op&quot;,
                  filterBinding: &quot;parentView.collectionFilter.currentFilter&quot;,
                  field: column.name
                });
                break;
              case &quot;date&quot;:
              case &quot;utcdate&quot;:
                fieldView = Tent.DateRangeField.create({
                  label: Tent.I18n.loc(column.title),
                  isFilter: true,
                  valueBinding: &quot;parentView.collectionFilter.currentFilter.values.&quot; + column.name + &quot;.data&quot;,
                  closeOnSelect: true,
                  arrows: true,
                  filterOpBinding: &quot;parentView.collectionFilter.currentFilter.values.&quot; + column.name + &quot;.op&quot;,
                  dateFormat: &quot;yy-mm-dd&quot;
                });
                break;
              case &quot;number&quot;:
              case &quot;amount&quot;:
                fieldView = Tent.NumericTextField.create({
                  label: Tent.I18n.loc(column.title),
                  isFilter: true,
                  serializer: Tent.Formatting.number.serializer,
                  rangeValueBinding: &quot;parentView.collectionFilter.currentFilter.values.&quot; + column.name + &quot;.data&quot;,
                  filterOpBinding: &quot;parentView.collectionFilter.currentFilter.values.&quot; + column.name + &quot;.op&quot;,
                  filterBinding: &quot;parentView.collectionFilter.currentFilter&quot;,
                  field: column.name
                });
                break;
              case &quot;boolean&quot;:
                fieldView = Tent.Checkbox.create({
                  label: Tent.I18n.loc(column.title),
                  isFilter: true,
                  checkedBinding: &quot;parentView.collectionFilter.currentFilter.values.&quot; + column.name + &quot;.data&quot;,
                  filterOpBinding: &quot;parentView.collectionFilter.currentFilter.values.&quot; + column.name + &quot;.op&quot;,
                  filterBinding: &quot;parentView.collectionFilter.currentFilter&quot;,
                  field: column.name
                });
            }
            if (fieldView != null) {
              _results.push(this.get('childViews').pushObject(fieldView));
            } else {
              _results.push(void 0);
            }
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    }
  });

}).call(this);


(function() {

  Tent.Breadcrumb = Ember.View.extend({
    router: null,
    homeState: 'home',
    classNames: ['tent-breadcrumb'],
    template: Ember.Handlebars.compile('{{#collection tagName=&quot;ul&quot; contentBinding=&quot;view.content&quot;}}\
				&lt;button class=&quot;btn btn-link&quot; {{bindAttr data-state=&quot;view.content.name&quot;}}&gt;{{loc view.content.title}} &lt;i class=&quot;icon-chevron-right&quot;&gt;&lt;/i&gt;&lt;/button&gt;\
			{{/collection}}'),
    init: function() {
      this._super();
      return this.generateBreadcrumb();
    },
    generateBreadcrumb: (function() {
      var currentState, path;
      if (this.get('router') != null) {
        currentState = this.get('router').get('currentState');
        path = [];
        this.addPathItem(currentState, path);
        while (currentState.get('parentState') != null) {
          currentState = currentState.get('parentState');
          if (currentState != null) {
            this.addPathItem(currentState, path);
          }
        }
        return this.set('content', path.reverse());
      }
    }).observes('router.currentState'),
    addPathItem: function(state, arr) {
      if ((state.get('name') != null) &amp;&amp; state.get('title')) {
        arr.push(Ember.Object.create({
          name: state.get('name'),
          title: state.get('title')
        }));
      }
      return arr;
    },
    click: function(e) {
      var state;
      state = $(e.target).attr(&quot;data-state&quot;);
      if (state != null) {
        return this.get('router').transitionTo(state);
      }
    }
  });

}).call(this);


Ember.TEMPLATES['file_upload']=Ember.Handlebars.compile(&quot;&lt;span&gt;\n  {{#if view.helpText}}&lt;span&gt;Drag &amp;amp; Drop files here...&lt;/span&gt;{{/if}}\n  &lt;input type=\&quot;file\&quot; name=\&quot;files[]\&quot; {{bindAttr data-url=\&quot;view.dataUrl\&quot;}} multiple&gt;\n  {{#if view.applyWait}}\n     {{view Tent.WaitIcon}}\n  {{/if}}\n&lt;/span&gt;\n&quot;);

(function() {
Tent.FileUpload = Ember.View.extend({
    templateName: 'file_upload',
    classNameBindings: ['tent-file-upload'],
    helpText: true,
    didInsertElement: function() {
      var _this = this;
      return this.$('input').fileupload({
        add: function(e, data) {
          _this.set('applyWait', true);
          return data.submit().success(_this.uploadResultFunctionWrapper(_this.get('parentView.controller'), 'Success')).error(_this.uploadResultFunctionWrapper(_this.get('parentView.controller'), 'Error'));
        }
      });
    },
    uploadResultFunctionWrapper: function(context, name) {
      var resultFunction, self;
      resultFunction = this.get('upload' + name + 'Function');
      self = this;
      if (context &amp;&amp; resultFunction) {
        return function(result, textStatus, jqXHR) {
          self.set('applyWait', false);
          return resultFunction.apply(context, arguments);
        };
      } else {
        return function(result, textStatus, jqXHR) {
          self.set('applyWait', false);
          return void 0;
        };
      }
    }
  });

}).call(this);


Ember.TEMPLATES['message_panel']=Ember.Handlebars.compile(&quot;{{#if view.hasErrors}}\n&lt;section class=\&quot;alert-error clearfix\&quot;&gt;\n\t&lt;h5&gt;Errors&lt;/h5&gt;\n\t{{#if view.collapsible}}\n\t\t&lt;div {{bindAttr class=\&quot;view.expandoClass\&quot;}}&gt;\n\t\t\t{{#each view.error}}\n\t\t\t\t&lt;div class=\&quot;error-message\&quot; {{bindAttr data-target=\&quot;this.sourceId\&quot;}}&gt;\n\t  \t\t\t\t{{#if this.label}}&lt;label&gt;{{loc this.label}}: &lt;/label&gt;{{/if}}&lt;ul&gt;{{#each this.messages}}&lt;li&gt;{{this}}&lt;/li&gt;{{/each}}&lt;/ul&gt;\n\t  \t\t\t&lt;/div&gt; \n\t\t  \t{{/each}}\n\t\t  \t{{#if view.hasMoreThanOneError}}\n\t\t\t\t&lt;a href=\&quot;#\&quot; class=\&quot;dropdown-toggle pull-right close\&quot; data-toggle=\&quot;collapse\&quot; data-target=\&quot;.error-expando\&quot;&gt;\n\t\t\t\t\t&lt;b class=\&quot;caret\&quot;&gt;&lt;/b&gt;&lt;/a&gt;\n\t\t\t{{/if}}\n\t\t&lt;/div&gt;\n\t\t\n\t{{else}}\n\t\t&lt;div&gt;\n\t\t\t{{#each view.error}}\n\t\t\t\t&lt;div class=\&quot;error-message\&quot; {{bindAttr data-target=\&quot;this.sourceId\&quot;}}&gt;\n\t  \t\t\t\t{{#if this.label}}&lt;label&gt;{{loc this.label}}: &lt;/label&gt;{{/if}}&lt;ul&gt;{{#each this.messages}}&lt;li&gt;{{this}}&lt;/li&gt;{{/each}}&lt;/ul&gt;\n\t  \t\t\t&lt;/div&gt; \n\t\t  \t{{/each}}\n\t\t&lt;/div&gt;\n\t{{/if}}\n&lt;/section&gt;\n{{/if}}\n\n{{#if view.hasInfos}}\n&lt;section class=\&quot;alert-info clearfix\&quot;&gt;\n\t{{view Tent.Button label=\&quot;x\&quot; type=\&quot;link\&quot; action=\&quot;clearInfos\&quot; targetBinding=\&quot;view\&quot; class=\&quot;close\&quot;}}\n\t&lt;h5&gt;Info&lt;/h5&gt;\n\t&lt;div class=\&quot;info-expando\&quot;&gt;\n\t\t{{#each view.info}}\n\t\t\t&lt;div class=\&quot;info-message\&quot; {{bindAttr data-target=\&quot;this.sourceId\&quot;}}&gt;{{this.messages}}&lt;/div&gt; \n\t  \t{{/each}}\n\t&lt;/div&gt;\n&lt;/section&gt;\n{{/if}}\n\n{{#if view.hasSuccesses}}\n&lt;section class=\&quot;alert-success clearfix\&quot;&gt;\n\t{{view Tent.Button label=\&quot;x\&quot; type=\&quot;link\&quot; action=\&quot;clearSuccesses\&quot; targetBinding=\&quot;view\&quot; class=\&quot;close\&quot;}}\n\t&lt;h5&gt;Success&lt;/h5&gt;\n\t&lt;div class=\&quot;info-expando\&quot;&gt;\n\t\t{{#each view.success}}\n\t\t\t&lt;div class=\&quot;success-message\&quot; {{bindAttr data-target=\&quot;this.sourceId\&quot;}}&gt;{{this.messages}}&lt;/div&gt; \n\t  \t{{/each}}\n\t&lt;/div&gt;\n&lt;/section&gt;\n{{/if}}\n\n{{#if view.hasWarnings}}\n\t{{#each view.warning}}\n\t\t&lt;section class=\&quot;alert clearfix\&quot; {{bindAttr data-target=\&quot;this.sourceId\&quot;}} data-type=\&quot;warning\&quot;&gt;\n\t\t\t{{view Tent.Button label=\&quot;x\&quot; type=\&quot;link\&quot; action=\&quot;removeMessageCommand\&quot; targetBinding=\&quot;view\&quot; class=\&quot;close\&quot;}}\n\t\t\t&lt;h5&gt;Warning&lt;/h5&gt;\n\t\t\t\t&lt;div&gt;\n\t\t\t\t\t&lt;div class=\&quot;error-message\&quot; {{bindAttr data-target=\&quot;this.sourceId\&quot;}}&gt;\n\t\t  \t\t\t\t&lt;label&gt;{{loc this.label}}:&lt;/label&gt; {{this.messages}}\n\t\t  \t\t\t&lt;/div&gt; \n\t\t\t \t&lt;/div&gt;\n\t\t&lt;/section&gt;\n\t{{/each}}\n{{/if}}\n\n&quot;);

(function() {
<span id='Tent-MessagePanel'>/**
</span>   * @class Tent.MessagePanel
   * @extends Ember.View
   *
   * A panel for displaying error and information messages for the application.
   *
   * All Tent widgets will publish messages when they are in an error state and these will
   * be displayed dynamically by the MessagePanel. If there are no errors, the panel will be hidden.
   * Each error message will identify the source of the error, if provided, and can also send focus
   * to the source widget when clicked.
   *
   * Error messages can also be displayed by explicitly publishing them, setting type='error'
   *
   * 			$.publish('/message', {
   					type:'error', 
   					messages:['Date format incorrect'], 
   					sourceId: 'ember13'
   					label: 'Date'
   			})
   *
   * - **type**: The type of message, can be 'error', 'info', 'success' or 'warning'
   * - **messages**: An array of messages to display
   * - **sourceId**: If the message refers to a Tent widget, provide the elementId of the widget
   * so that focus can be transferred to it when the error is clicked
   * - **label**: The label to display beside the messages for this source
   *
   * Each source will be allocated one line in the MessagePanel. If there are no messages for
   * a source, it will be removed from the MessagePanel. So in effect, to clear the messages for a source, send an
   * empty messages array
   * 			
   * 			$.publish('/message', {
   					type:'error', 
   					messages:[], 
   					sourceId: 'ember13'
   			})
   * 
   * Information messages are displayed as-is, with no linking to source widgets.
   *
   * 			$.publish('/message', {
   					type:'info', 
   					messages:['Please call this number for assistance..']
   			})
   *
   * If you wish to display more than one message, use different sourceId's in the published message.
   *
   * The default state of the MessagePanel is collapsed and showing the first message. The panel can 
   * be expanded if there is more than one message. The panel can be permanently expanded by setting the 
   * {@link #collapsible} property to false. The default collapse state can be set with the {@link #collapsed}
   * property.
   *
   * 
   *
   * ##Usage
   *         {{view Tent.MessagePanel}}
   *
  */


  Tent.MessagePanel = Ember.View.extend({
    templateName: 'message_panel',
    classNames: ['tent-message-panel'],
    classNameBindings: ['type', 'isActive:active'],
    title: null,
<span id='Tent-MessagePanel-property-type'>    /**
</span>    	* @property {String} type Defines the type of message panel. Typically there will be one 'primary'
    	* panel per application. Modal dialogues may also have 'secondary' panels which become active when the
    	* panels are displayed
    */

    type: 'primary',
<span id='Tent-MessagePanel-property-collapsible'>    /**
</span>     	* @property {Boolean} collapsible A boolean indicating that the panel is collapsible
    */

    collapsible: true,
<span id='Tent-MessagePanel-property-collapsed'>    /**
</span>     	* @property {Boolean} collapsed A boolean indicating that the panel is collapsed by default
    */

    collapsed: true,
<span id='Tent-MessagePanel-property-isActive'>    /**
</span>    	* @property {Boolean} isActive One message panel should be active at a time, usually the primary one.
    	* When a popup is displayed, it's message panel will usually become active, with the primary panel becoming
    	* inactive.
    */

    isActive: true,
    init: function() {
      this._super();
      this.clearAll();
      this.set('handler', $.proxy(this.handleNewMessage(), this));
      this.showContainerWhenVisible();
      return $.subscribe('/message', this.get('handler'));
    },
    didInsertElement: function() {
      return this.getParentContainer();
    },
    willDestroy: function() {
      $.unsubscribe('/message', this.get('handler'));
      return this._super();
    },
    setActive: function(isActive) {
      return this.set('isActive', isActive);
    },
    handleNewMessage: function() {
      return function(e, msg) {
        var arrayWithMessageRemoved;
        if (this.get('isActive')) {
          if (!(msg.type != null)) {
            throw new Error('Message must have a type');
          }
          if (msg.type === 'clearAll') {
            return this.clearAll();
          } else {
            arrayWithMessageRemoved = [];
            if (msg.messages != null) {
              arrayWithMessageRemoved = this.get(msg.type).filter(function(item, index, enumerable) {
                return item.sourceId !== msg.sourceId;
              });
              if (msg.messages.length &gt; 0) {
                arrayWithMessageRemoved.pushObject($.extend({}, msg));
              }
              return this.set(msg.type, arrayWithMessageRemoved);
            }
          }
        }
      };
    },
    getParentContainer: function() {
      var header;
      header = this.$('').parents('header.hideable:first');
      if (header.length &gt; 0) {
        return this.set('parentContainer', Ember.View.views[header.attr('id')]);
      }
    },
    showContainerWhenVisible: (function(forceShow) {
      if (forceShow == null) {
        forceShow = false;
      }
      if (this.get('parentContainer') != null) {
        if (this.get('hasErrors') || this.get('hasInfos') || this.get('hasSuccesses') || this.get('hasWarnings')) {
          return this.get('parentContainer').show(forceShow);
        } else {
          return this.get('parentContainer').hide();
        }
      }
    }).observes('hasErrors', 'hasInfos', 'hasWarnings', 'hasSuccesses'),
    expandoClass: (function() {
      if (this.get('collapsed')) {
        return &quot;error-expando collapse&quot;;
      } else {
        return &quot;error-expando collapse in&quot;;
      }
    }).property('collapsed'),
<span id='Tent-MessagePanel-method-getErrorsForView'>    /**
</span>    	 * return the error messages
    */

    getErrorsForView: function(viewId) {
      var error, errors, _i, _len, _ref;
      errors = [];
      _ref = this.get('error');
      for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
        error = _ref[_i];
        if (error.sourceId === viewId) {
          $.merge(errors, error.messages);
        }
      }
      return errors.uniq();
    },
    getInfosForView: function(viewId) {
      var info, infos, _i, _len, _ref;
      infos = [];
      _ref = this.get('info');
      for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
        info = _ref[_i];
        if (info.sourceId === viewId) {
          $.merge(infos, info.messages);
        }
      }
      return infos.uniq();
    },
    getSuccessesForView: function(viewId) {
      var success, successes, _i, _len, _ref;
      successes = [];
      _ref = this.get('success');
      for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
        success = _ref[_i];
        if (success.sourceId === viewId) {
          $.merge(successes, success.messages);
        }
      }
      return successes.uniq();
    },
    removeMessage: function(type, id) {
      var msgArr;
      msgArr = this.get(type);
      return this.set(type, msgArr.filter(function(item, index, enumerable) {
        return item.sourceId !== id;
      }));
    },
    removeMessageCommand: function(button) {
      var id, section, type;
      section = button.$().parent('section');
      type = section.attr('data-type');
      id = section.attr('data-target');
      this.removeMessage(type, id);
      return this.stopProcessingWarnings(id);
    },
    stopProcessingWarnings: function(id) {
      var view;
      view = Ember.View.views[id];
      if (view != null) {
        view.set('processWarnings', false);
        return view.flushValidationWarnings();
      }
    },
    hasErrors: (function() {
      return this.get('error').length &gt; 0;
    }).property('error', 'error.@each'),
    hasInfos: (function() {
      return this.get('info').length &gt; 0;
    }).property('info', 'info.@each'),
    hasSuccesses: (function() {
      return this.get('success').length &gt; 0;
    }).property('success', 'success.@each'),
    hasWarnings: (function(severity) {
      return this.get('warning').length &gt; 0;
    }).property('warning', 'warning.@each'),
    hasSevereWarnings: (function() {
      var hasW, w, _i, _len, _ref;
      hasW = false;
      _ref = this.get('warning');
      for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
        w = _ref[_i];
        if (w.severity === 'high') {
          return true;
        }
      }
      return hasW;
    }).property('warning', 'warning.@each'),
    hasFirstLongTextError: (function() {
      var _this = this;
      return Ember.run.next(this, function() {
        var firstError;
        firstError = _this.$('.error-message:first');
        if (firstError != null) {
          return _this.$('.error-expando').css('min-height', firstError.height() + &quot;px&quot;);
        }
      });
    }).observes('error', 'error.@each'),
    ensureContainerResizesAfterDomRenders: (function() {
      var _this = this;
      return Ember.run.next(this, function() {
        return _this.showContainerWhenVisible(true);
      });
    }).observes('error', 'warning', 'success', 'info', 'error.@each', 'warning.@each', 'success.@each', 'info.@each'),
    hasMoreThanOneError: (function() {
      return this.get('error').length &gt; 1;
    }).property('error', 'error.@each'),
    clearAll: function() {
      this.clearErrors();
      this.clearInfos();
      this.clearSuccesses();
      return this.clearWarnings();
    },
    clearErrors: function() {
      return this.set('error', []);
    },
    clearInfos: function() {
      return this.set('info', []);
    },
    clearSuccesses: function() {
      return this.set('success', []);
    },
    clearWarnings: function() {
      return this.set('warning', []);
    },
    click: function(e) {
      var target, targetId, wrappingMessage;
      target = $(e.target);
      wrappingMessage = target.closest('.error-message', this.$());
      if ((wrappingMessage != null) &amp;&amp; wrappingMessage.length &gt; 0) {
        targetId = wrappingMessage.attr('data-target');
        if (Ember.View.views[targetId] != null) {
          return Ember.View.views[targetId].focus();
        }
      }
    }
  });

  Tent.Message = Ember.Object.extend({
    messages: null,
    params: null,
    type: null,
    sourceId: null
  });

  Tent.Message.ERROR_TYPE = 'error';

  Tent.Message.INFO_TYPE = 'info';

  Tent.Message.SUCCESS_TYPE = 'success';

  Tent.Message.WARNING_TYPE = 'warning';

}).call(this);



<span id='Tent-Spinner'>/**
</span>* @class Tent.Spinner
* @extends Tent.TextField
* Usage
*       {{view Tent.Spinner label=&quot;&quot; 
					valueBinding=&quot;&quot; 
					minBinding=&quot;&quot; 
					maxBinding=&quot;&quot;
         }}
  value can be entered maually in the spinner. 
  To put restrictions on that use custom validation: valueBetween
			  {{view Tent.Spinner label=&quot;&quot; 
						valueBinding=&quot;&quot; 
						minBinding=&quot;&quot; 
						maxBinding=&quot;&quot; 
						validations=&quot;valueBetween&quot;
			      validationOptions=&quot;{valueBetween:{min:2, max:20}}&quot;}}
  To restrict only one min/max value, give the other as null   
  			eg: validationOptions = &quot;{valueBetween:{min:null, max:20}}&quot;
*/


(function() {
Tent.Spinner = Tent.NumericTextField.extend(Tent.JQWidget, {
    uiType: 'spinner',
    uiEvents: ['change'],
    uiOptions: ['max', 'min', 'icons', 'culture', 'disabled', 'incremental', 'numberFormat', 'step', 'page'],
    classNames: ['tent-spinner'],
    defaultOptions: {
      min: 0,
      change: this.change
    },
    init: function() {
      return this._super();
    },
    didInsertElement: function() {
      this._super(arguments);
      return this.$('input').spinner(this.get('options'));
    },
    optionsDidChange: (function() {
      if (this.get('min')) {
        this.$('input').spinner({
          'min': this.get('min')
        });
      }
      if (this.get('max')) {
        this.$('input').spinner({
          'max': this.get('max')
        });
      }
      if (this.get('disabled') || this.get('isReadOnly') || this.get('readOnly')) {
        return this.$('input').spinner('disable');
      } else {
        return this.$('input').spinner('enable');
      }
    }).observes('min', 'max', 'disabled', 'readOnly', 'isReadOnly'),
    change: function(event, ui) {
      if (isNaN(Number(this.$('input').attr('value')))) {
        this.$('input').attr('value', null);
      }
      return this.set('value', this.$('input').spinner('value'));
    }
  });

}).call(this);


(function() {

  Tent.WaitIcon = Ember.View.extend({
    template: Ember.Handlebars.compile('&lt;div class=&quot;wait&quot;&gt;&lt;i class=&quot;icon-spinner icon-spin icon-2x&quot;&gt;&lt;/i&gt;&lt;/div&gt;')
  });

}).call(this);



<span id='Tent-Tree'>/**
</span>* @class Tent.Tree
*
* Usage
*        {{view Tent.Tree
            contentBinding=&quot;&quot; 
            selectionBinding=&quot;&quot; 
            aria=&quot;&quot;
            activeVisible=&quot;&quot;
            autoActivate=&quot;&quot;
            autoScroll=&quot;&quot;
            checkbox=&quot;&quot;
            folderOnClickShould=&quot;&quot;
            disabled=&quot;&quot;
            icons=&quot;&quot;
            keyboard=&quot;&quot;
            nodeSelection=&quot;&quot;
            tabbable=&quot;&quot;
            radio=&quot;&quot;
          }}
*/


(function() {

  Tent.Tree = Ember.View.extend({
    template: (function() {
      var guid;
      guid = Ember.guidFor(this);
      return Ember.Handlebars.compile(&quot;&lt;div id=\&quot;&quot; + guid + &quot;-tree\&quot; {{bindAttr class=\&quot;view.radio:fancytree-radio\&quot;}}&gt;&lt;/div&gt;&quot;);
    }).property(),
<span id='Tent-Tree-property-aria'>    /**
</span>    * @property {Boolean} [aria=false] A boolean property which enables/disables WAI-ARIA support.
    */

    aria: false,
<span id='Tent-Tree-property-activeVisible'>    /**
</span>    * @property {Boolean} [activeVisible=true] A boolean property which makes sure active nodes
    * are visible (expanded).
    */

    activeVisible: true,
<span id='Tent-Tree-property-autoActivate'>    /**
</span>    * @property {Boolean} [autoActivate=true] A boolean property indicating whether to
    * automatically activate a node when it is focused (using keys).
    */

    autoActivate: true,
<span id='Tent-Tree-property-autoCollapse'>    /**
</span>    * @property {Boolean} [autoCollapse=false] A boolean property indicating whether to
    * automatically collapse all siblings, when a node is expanded.
    */

    autoCollapse: false,
<span id='Tent-Tree-property-autoScroll'>    /**
</span>    * @property {Boolean} [autoScroll=false] A boolean property indicating whether to
    * automatically scroll nodes into visible area
    */

    autoScroll: false,
<span id='Tent-Tree-property-checkbox'>    /**
</span>    * @property {Boolean} [checkbox=false] A boolean property responsible for displaying
    * checkboxes on the nodes.
    */

    checkbox: false,
<span id='Tent-Tree-property-folderOnClickShould'>    /**
</span>    * @property {String} folderOnClickShould The property responsible for the folder click behaviour
    * If the value is 'expandOnDblClick' the folder expands only on double click
    * If the value is 'activate' the folder gets activated (not selected) on click
    * If the value is 'expand' the folder expands on click (not selected &amp; activated)
    * If the value is 'activateAndExpand' the folder is expanded &amp; activated on click
    */

    folderOnClickShould: 'expandOnDblClick',
<span id='Tent-Tree-property-disabled'>    /**
</span>    * @property {Boolean} [disabled=false] A boolean property responsible for enabling/disabling
    * the entire tree
    */

    disabled: false,
<span id='Tent-Tree-property-extensions'>    /**
</span>    * @property {Array} extensions built for the fancytree widget which we wish to load
    * must be specified here.
    */

    extensions: [],
<span id='Tent-Tree-property-generateIds'>    /**
</span>    * @property {Boolean} [generateIds=true] A boolean property indicating whether to generate
    * unique ids for li elements.
    */

    generateIds: false,
<span id='Tent-Tree-property-icons'>    /**
</span>    * @property {Boolean} [icons=true] when true icons for the nodes are displayed on the UI
    */

    icons: false,
<span id='Tent-Tree-property-keyboard'>    /**
</span>    * @property {Boolean} [keyboard=true] A boolean property indicating keyboard navigation support
    */

    keyboard: true,
<span id='Tent-Tree-property-nodeSelecion'>    /**
</span>    * @property {String} nodeSelecion The property resposible for node selection behaviour
    * If the value is 'singleSelect' user can select only one node
    * If the value is 'multiSelect' user can select multiple nodes
    * If the value is 'heirMultiSelect' user can select all the children on selecting parent node
    */

    nodeSelection: 'multiSelect',
<span id='Tent-Tree-property-tabbable'>    /**
</span>    * @property {Boolean} [tabbable=true] a boolean indicating whether the whole tree behaves as one single control
    */

    tabbable: true,
<span id='Tent-Tree-property-minExpandLevel'>    /**
</span>    * @property {Integer} minExpandLevel Locks expand/collapse for all the nodes on the given minExpandLevel value
    */

    minExpandLevel: 1,
<span id='Tent-Tree-property-radio'>    /**
</span>    * @property {Boolean} [radio=false] Displays radio buttons instead of checkboxes when set to true
    * property checkbox must be set to true in order to see the radio button.
    * To simulate radio group behavior the property nodeSelection must be set to 'singleSelect'
    * else we will have multi-select radio buttons.
    */

    radio: false,
<span id='Tent-Tree-property-content'>    /**
</span>    * @property {Array} content an array of parent child relationship which is responsible for 
    * rendering the tree.
    * Example:
    * [
    *  {
    *    title: 'Node Title', 
    *    folder: true, // the value must be set to true else folderOnClickShould value wont have any effect
    *    tooltip: 'tooltip that needs to be displayed for the node on hover',
    *    extraClasses: 'class1 class2', //Adding classes to nodes,
    *    expanded: true, //Will be expanded on load
    *    lazy: true, //TODO, children will be loaded via AJAX call
    *    children: [
    *      {
    *        title: &quot;&lt;span&gt;can enter HTML too using a span tag &lt;/span&gt;&quot;,
    *        value: 100 // if it is a leaf node then we must specify the value, which will be 
    *                  // collected in selection array on selection.
    *      },
    *      {title: 'child 2', value: 'can be any data type'}
    *    ]
    *  }
    * ]
    *
    */

    content: Em.A(),
<span id='Tent-Tree-property-selection'>    /**
</span>    * @property {Array} selection an array which holds selected leafnode values from the tree.
    */

    selection: Em.A(),
    selectMode: (function() {
      switch (this.get('nodeSelection')) {
        case 'singleSelect':
          return 1;
        case 'multiSelect':
          return 2;
        case 'heirMultiSelect':
          return 3;
        default:
          return 2;
      }
    }).property('nodeSelection'),
    clickFolderMode: (function() {
      switch (this.get('folderOnClickShould')) {
        case 'activate':
          return 1;
        case 'expand':
          return 2;
        case 'activateAndExpand':
          return 3;
        case 'expandOnDblClick':
          return 4;
        default:
          return 4;
      }
    }).property('folderOnClickShould'),
    addArrayObservers: function(array) {
      var _this = this;
      return array.addArrayObserver(Em.Object.create({
        arrayWillChange: function(array, start, removeCount, addCount) {
          if (removeCount &amp;&amp; removeCount === array.get('length')) {
            _this.get('selection').clear();
            _this.reloadTree([]);
            return _this.rerender();
          } else if (removeCount) {
            return _this.removeNodes(array.slice(start, start + removeCount));
          }
        },
        arrayDidChange: function(array, start, removeCount, addCount) {
          if (addCount &amp;&amp; addCount === array.get('length')) {
            return _this.reloadTree(array);
          } else if (addCount) {
            return _this.addNodes(array.slice(start, start + addCount));
          }
        }
      }));
    },
    contentDidChange: (function() {
      this.reloadTree(this.get('content'));
      this.addArrayObservers(this.get('content'));
      return this.get('selection').clear();
    }).observes('content'),
    optionsDidChange: (function() {
      var element, name, optionDidChange, options, value, _i, _len, _results;
      options = ['activeVisible', 'autoActivate', 'aria', 'autoCollapse', 'autoScroll', 'minExpandLevel', 'clickFolderMode', 'checkbox', 'disabled', 'icons', 'keyboard', 'selectMode', 'tabbable'];
      element = this.getTreeDom();
      _results = [];
      for (_i = 0, _len = options.length; _i &lt; _len; _i++) {
        name = options[_i];
        value = this.get(name);
        optionDidChange = value !== element.fancytree('option', name);
        if (optionDidChange) {
          _results.push(element.fancytree('option', name, value));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    }).observes('activeVisible', 'autoActivate', 'aria', 'autoCollapse', 'autoScroll', 'clickFolderMode', 'checkbox', 'disabled', 'icons', 'keyboard', 'selectMode', 'tabbable', 'minExpandLevel'),
    didInsertElement: function() {
      var options;
      options = $.extend({
        source: this.get('content')
      }, this.getTreeEvents(), this.getNodeEvents(), this.getDefaultSettings());
      this.getTreeDom().fancytree(options);
      if (!this.get('hasArrayObservers')) {
        this.addArrayObservers(this.get('content'));
        return this.set('hasArrayObservers', true);
      }
    },
    getTreeEvents: function() {
      var event, options, treeEvents, _i, _len,
        _this = this;
      options = {};
      treeEvents = ['treeInit', 'create'];
      for (_i = 0, _len = treeEvents.length; _i &lt; _len; _i++) {
        event = treeEvents[_i];
        if (this[event] != null) {
          options[event] = (function(e, data, flag) {
            return _this[event].call(_this, e, data, flag);
          });
        }
      }
      return options;
    },
    getNodeEvents: function() {
      var event, nodeEvents, options, widget, _i, _len;
      options = {};
      nodeEvents = ['beforeActivate', 'activate', 'deactivate', 'beforeSelect', 'select', 'beforeExpand', 'collapse', 'expand', 'loadChildren', 'focustree', 'blurtree', 'focus', 'blur', 'click', 'dblclick', 'keydown', 'keypress', 'createnode', 'rendernode', 'lazyload', 'lazyread'];
      widget = this;
      for (_i = 0, _len = nodeEvents.length; _i &lt; _len; _i++) {
        event = nodeEvents[_i];
        if (widget[event.toLowerCase()] != null) {
          options[event] = (function(e, data) {
            return widget[e.type.slice(9)](e, data);
          });
        }
      }
      return options;
    },
    getDefaultSettings: function() {
      var defaultSettings, options, setting, _i, _len;
      options = {};
      defaultSettings = ['aria', 'activeVisible', 'autoActivate', 'autoCollapse', 'autoScroll', 'checkbox', 'clickFolderMode', 'disabled', 'extensions', 'generateIds', 'icons', 'keyboard', 'nolink', 'selectMode', 'tabbable', 'minExpandLevel'];
      for (_i = 0, _len = defaultSettings.length; _i &lt; _len; _i++) {
        setting = defaultSettings[_i];
        options[setting] = this.get(setting);
      }
      return options;
    },
    removeNodes: function(options) {
      var option, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = options.length; _i &lt; _len; _i++) {
        option = options[_i];
        _results.push(this.removeChildFromRootNode(option));
      }
      return _results;
    },
    addNodes: function(nodes) {
      var node, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = nodes.length; _i &lt; _len; _i++) {
        node = nodes[_i];
        _results.push(this.addChildrenToRootNode(node));
      }
      return _results;
    },
    getTreeDom: (function() {
      return this.$(&quot;#&quot; + (Ember.guidFor(this)) + &quot;-tree&quot;);
    }),
    getTree: (function() {
      return this.getTreeDom().fancytree('getTree');
    }),
    enable: function() {
      if (this.getTreeDom().fancytree('option', 'disabled')) {
        return this.getTreeDom().fancytree('enable');
      }
    },
    disable: function() {
      if (!this.getTreeDom().fancytree('option', 'disabled')) {
        return this.getTreeDom().fancytree('disable');
      }
    },
    reloadTree: (function(content) {
      return this.getTree().reload(content);
    }),
    getRootNode: (function() {
      return this.getTreeDom().fancytree('getRootNode');
    }),
    expandAll: (function() {
      return this.getRootNode().visit(function(node) {
        return node.setExpanded(true);
      });
    }),
    collapseAll: (function() {
      return this.getRootNode().visit(function(node) {
        return node.setExpanded(false);
      });
    }),
    toggleExpand: (function() {
      return this.getRootNode().visit(function(node) {
        return node.toggleExpanded();
      });
    }),
    selectAll: (function() {
      return this.getTree().visit(function(node) {
        return node.setSelected(true);
      });
    }),
    deselectAll: (function() {
      return this.getTree().visit(function(node) {
        return node.setSelected(false);
      });
    }),
    toggleSelect: (function() {
      return this.getTree().visit(function(node) {
        return node.toggleSelected();
      });
    }),
    getActiveNode: (function() {
      return this.getTreeDom().fancytree('getActiveNode');
    }),
    toJSON: (function() {
      return JSON.stringify(this.getTree().toDict(true));
    }),
    getNode: (function(id) {
      return this.getTree().getNodeByKey(id);
    }),
    focusNode: (function(id) {
      return this.getTree().activateKey(id);
    }),
    setNodeTitle: function(title, id) {
      if (id != null) {
        return this.getNode(id).setTitle(title);
      } else {
        return this.getActiveNode().setTitle(title);
      }
    },
    sortTree: function(compareFunction, deepSort) {
      if (deepSort == null) {
        deepSort = true;
      }
      return this.getRootNode().sortChildren(compareFunction, deepSort);
    },
    sortActiveBranch: function(compareFunction, deepSort) {
      if (deepSort == null) {
        deepSort = true;
      }
      return this.getActiveNode().sortChildren(compareFunction, deepSort);
    },
    addChildren: (function(node, options) {
      return node.addChildren(options);
    }),
    addChildrenToActiveNode: (function(options) {
      return this.addChildren(this.getActiveNode(), options);
    }),
    addChildrenToRootNode: function(options) {
      return this.addChildren(this.getRootNode(), options);
    },
    addChildrenToNode: (function(nodeId, options) {
      return this.addChildren(this.getNode(nodeId), options);
    }),
    removeChild: function(node, options) {
      var childNode, index, title;
      title = options.title;
      childNode = node.findFirst(function(n) {
        return n.title === title;
      });
      if (childNode.isFolder()) {
        if (childNode.isSelected()) {
          this.recursivelyRemoveNodeChildren(childNode);
        }
      } else {
        index = this.get('selection').indexOf(childNode.data.value);
        if (index !== -1) {
          this.get('selection').removeAt(index);
        }
      }
      return node.removeChild(childNode);
    },
    removeChildFromActiveNode: (function(options) {
      return this.removeChild(this.getActiveNode(), options);
    }),
    removeChildFromRootNode: (function(options) {
      return this.removeChild(this.getRootNode(), options);
    }),
    removeChildFromNode: (function(nodeId, options) {
      return this.removeChild(this.getNode(nodeId), options);
    }),
    replaceChildren: (function(node, options) {
      return node.fromDict(options);
    }),
    replaceRootChildren: (function(options) {
      return this.replaceChildren(this.getRootNode(), options);
    }),
    replaceActiveNodeChildren: (function(options) {
      return this.replaceChildren(this.getActiveNode(), options);
    }),
    reinitialize: (function() {
      return this.getTreeDom().fancytree();
    }),
    recursivelyAdd: function(node) {
      if (node.isFolder()) {
        return this.recursivelyAddNodeChildren(node);
      } else {
        if (!node.isSelected()) {
          return this.get('selection').pushObject(node.data.value);
        }
      }
    },
    recursivelyAddNodeChildren: function(node) {
      var child, _i, _len, _ref, _results;
      _ref = node.children;
      _results = [];
      for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
        child = _ref[_i];
        _results.push(this.recursivelyAdd(child));
      }
      return _results;
    },
    recursivelyRemove: function(node) {
      var index;
      if (node.isFolder()) {
        return this.recursivelyRemoveNodeChildren(node);
      } else {
        index = this.get('selection').indexOf(node.data.value);
        if (index !== -1) {
          return this.get('selection').removeAt(index);
        }
      }
    },
    recursivelyRemoveNodeChildren: function(node) {
      var child, _i, _len, _ref, _results;
      _ref = node.children;
      _results = [];
      for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
        child = _ref[_i];
        _results.push(this.recursivelyRemove(child));
      }
      return _results;
    },
    beforeselect: function(e, data) {
      var index;
      if (data.node.isFolder()) {
        if (this.get('nodeSelection') !== 'heirMultiSelect') {
          return;
        }
        if (data.node.isSelected()) {
          return this.recursivelyRemoveNodeChildren(data.node);
        } else {
          return this.recursivelyAddNodeChildren(data.node);
        }
      } else {
        if (data.node.isSelected()) {
          index = this.get('selection').indexOf(data.node.data.value);
          if (index !== -1) {
            return this.get('selection').removeAt(index);
          }
        } else {
          return this.get('selection').pushObject(data.node.data.value);
        }
      }
    }
  });

}).call(this);


Ember.TEMPLATES['application/main_menu']=Ember.Handlebars.compile(&quot;&lt;ul class=\&quot;sci-main-menu nav-tabs\&quot;&gt;\n\t{{#each menugroup in content}}\n\t\t{{#if menugroup.entitled}}\n\t\t\t&lt;li&gt;\n\t\t\t\t{{#if view.isFlattened}}\n\t\t\t\t\t{{#each item in menugroup.items}}\n\t\t\t\t\t\t{{view Tent.Application.MenuItemView contentBinding=\&quot;item\&quot;}}\n\t\t\t\t\t{{/each}}\n\t\t\t\t{{else}}\n\t\t\t\t\t{{#view Tent.Panel collapsible=true collapsedBinding=\&quot;menugroup.collapsed\&quot; hasChildViews=true}}\n\t\t\t\t        {{#view Tent.PanelHead}}\n\t\t\t\t          &lt;h4&gt;&lt;i {{bindAttr class=\&quot;menugroup.icon\&quot;}}&gt;&lt;/i&gt; {{loc menugroup.title}}&lt;/h4&gt;  \n\t\t\t\t        {{/view}}\n\t\t\t\t        {{#view Tent.PanelBody}}\n\t\t\t\t        \t{{#each item in menugroup.items}}\n\t\t\t\t        \t\t{{view Tent.Application.MenuItemView contentBinding=\&quot;item\&quot;}}\n\t\t\t\t\t        {{/each}}\n\t\t\t\t        {{/view}}\n\t\t\t\t    {{/view}}\n\t\t\t\t{{/if}}\n\t\t\t&lt;/li&gt;\n\t\t{{/if}}\n\t{{/each}}\n&lt;/ul&gt;&quot;);

(function() {

  Tent.Application = Tent.Application || Em.Namespace.create();
Tent.Application.MainMenuView = Ember.View.extend({
    templateName: 'application/main_menu',
    classNames: ['sci-main-menu'],
    collapsedDashboard: false,
<span id='Tent-Tree-property-collapseAutomatically'>    /**
</span>    * @property {Boolean} collapseAutomatically Defines whether the menu should collapse when the content area recieves focus.
    */

    collapseAutomatically: true,
<span id='Tent-Tree-property-isFlattened'>    /**
</span>    * @property {Boolean} isFlattened Render all menu items in a single hierarchy, ignoring grouping.
    */

    isFlattened: false,
    didInsertElement: function() {
      var _this = this;
      this._super();
      this.highlightSelectedItem();
      return this.$('.nav-tabs .menu-link').click(function(e) {
        _this.switchMenu(e);
        return true;
      });
    },
    highlightSelectedItem: function(path) {
      var current;
      path = path || window.location.pathname;
      if ((this.$() != null)) {
        this.$(&quot;.active-menu&quot;).removeClass('active-menu');
        this.$(&quot;[data-route],[data-route-exact]&quot;).each(function() {
          if (path.indexOf($(this).attr('data-route')) !== -1) {
            $(this).addClass('active-menu');
          }
          if (path === $(this).attr('data-route-exact')) {
            return $(this).addClass('active-menu');
          }
        });
        current = null;
        return this.$(&quot;active-menu&quot;).each(function() {
          if (!(current != null)) {
            return current = $(this);
          } else {
            if ($(this).attr('data-route').length &gt; current.attr('data-route').length) {
              current.removeClass('active-menu');
              return current = $(this);
            }
          }
        });
      }
    },
    menuClicked: function(e) {
      var action;
      action = $(e.target).attr('data-action') || $(e.target).parents('[data-action]:first').attr('data-action');
      return this.get('controller').menuClicked(action);
    },
    switchMenu: function(event) {
      var selected, target;
      target = event.target;
      selected = this.$('.active-menu');
      if (selected !== undefined) {
        $(selected).removeClass('active-menu');
      }
      if ($(target).is('.menu-link')) {
        $(target).addClass('active-menu');
      } else {
        $(target).parents('.menu-link:first').addClass('active-menu');
      }
      if (this.get('collapseAutomatically')) {
        return this.collapseDashboard();
      }
    },
    collapseDashboard: function() {
      var mainPanel;
      if (!this.get('collapsedDashboard')) {
        mainPanel = this.getMainPanel();
        mainPanel.removeClass('expanded');
        this.set('collapsedDashboard', true);
        this.$(&quot;span[rel=tooltip]&quot;).tooltip('enable');
        this.$('.tent-panel.collapsible').each(function() {
          var elem, view;
          view = Ember.View.views[$(this).attr('id')];
          if (view.get('collapsed')) {
            elem = $(&quot;.pull-right&quot;, $(this));
            if (elem.length &gt; 0) {
              elem.removeClass(&quot;collapsed&quot;);
            }
            return view.show();
          }
        });
      }
      return this.$('a i, button i').tooltip('enable');
    },
    expandDashboard: function() {
      var mainPanel;
      if (this.get('collapsedDashboard')) {
        mainPanel = this.getMainPanel();
        mainPanel.addClass('expanded');
        this.set('collapsedDashboard', false);
      }
      return this.$('a i, button i').tooltip('disable');
    },
    toggleCollapse: function() {
      if (this.get('collapsedDashboard')) {
        return this.expandDashboard();
      } else {
        return this.collapseDashboard();
      }
    },
    getMainPanel: function() {
      return $('.main-content');
    }
  });

}).call(this);


Ember.TEMPLATES['application/menu_item']=Ember.Handlebars.compile(&quot;{{#if view.isEntitled}}\n\t{{#if item.entitled}}\n    \t&lt;a href=\&quot;#\&quot; class=\&quot;menu-link\&quot; {{bindAttr data-route=\&quot;item.route\&quot;}} {{bindAttr data-action=\&quot;item.action\&quot;}} {{action menuClicked target=\&quot;view\&quot;}}&gt;\n\t\t\t&lt;i {{bindAttr class=\&quot;item.icon\&quot;}} {{bindAttr data-title=\&quot;view.title\&quot;}} data-placement=\&quot;right\&quot; data-animation=\&quot;false\&quot;&gt;&lt;/i&gt;\n\t\t\t&lt;span class=\&quot;content\&quot;&gt;{{loc item.title}}&lt;/span&gt;\n      \t&lt;/a&gt;\n\t{{/if}}\n{{/if}}&quot;);

(function() {

  Tent.Application = Tent.Application || Em.Namespace.create();
Tent.Application.MenuItemView = Ember.View.extend({
    isEntitled: function() {
      return true;
    },
    templateName: 'application/menu_item',
    collapsed: false,
    title: (function() {
      return Tent.I18n.loc(this.get('content.title'));
    }).property(),
    isEnabled: true,
    isDisabled: (function() {
      return !this.get('content.isEnabled');
    }).property('isEnabled'),
    menuClicked: function(e) {
      var action;
      action = $(e.target).attr('data-action') || $(e.target).parents('[data-action]').attr('data-action');
      return this.get('controller').menuClicked(action);
    }
  });

}).call(this);


(function() {

  Tent.Application = Tent.Application || Em.Namespace.create();

  Tent.Application.PanelToggleView = Ember.View.extend({
    elementId: &quot;dashboard-toggle&quot;,
    classNames: ['dashboard-toggle'],
    template: Ember.Handlebars.compile('&lt;a&gt;&lt;i class=&quot;icon-reorder&quot;&gt;&lt;/i&gt;&lt;/a&gt;'),
    attributeBindings: ['rel'],
    rel: 'popover',
    targets: ['sci-main-menu'],
    didInsertElement: function() {
      return this._super();
    },
    click: function() {
      var target, _i, _len, _ref, _results;
      _ref = this.get('targets');
      _results = [];
      for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
        target = _ref[_i];
        if (this.getViewForTarget(target) != null) {
          _results.push(this.getViewForTarget(target).toggleCollapse());
        } else {
          _results.push($('.' + target).toggleClass('expanded'));
        }
      }
      return _results;
    },
    getViewForTarget: function(target) {
      return Ember.View.views[$('.' + target).attr('id')];
    }
  });

}).call(this);


(function() {
}).call(this);



/*
GridController
- content: bind to Model
- modelType: 
- store
- rowSelection holds the object represented by the selected row
*/


(function() {

  Tent.Controllers.GridController = Ember.ArrayController.extend({
    content: null,
    modelType: null,
    store: null,
    rowSelection: null,
    list: (function() {
      if (this.get('content')) {
        return this.getArrayFromRecordArray(this.get('content'));
      }
    }).property('content'),
    rowSelectionDidChange: (function() {
      var obj, _i, _len, _ref, _results;
      console.log('#####################');
      _ref = this.get('rowSelection');
      _results = [];
      for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
        obj = _ref[_i];
        _results.push(console.log(obj.id + &quot;  :  &quot; + obj.title));
      }
      return _results;
    }).observes('rowSelection'),
    getArrayFromRecordArray: function(recordArray) {
      var item, _i, _len, _list, _ref;
      _list = [];
      _ref = recordArray.toArray();
      for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
        item = _ref[_i];
        if (item != null) {
          _list.push(item.toJSON());
        }
      }
      return _list;
    },
    page: function(pageInfo) {
      var query;
      query = $.extend(pageInfo, {
        type: 'paging'
      });
      return this.set('content', this.store.findQuery(this.modelType, query));
    },
    sort: function(args, pagingInfo) {
      var query, result;
      if (args.multiColumnSort) {
        query = this.getMultiColumnQuery(args, pagingInfo);
      } else {
        query = this.getSingleColumnQuery(args, pagingInfo);
      }
      query = $.extend(query, pagingInfo, {
        multiColumn: args.multiColumnSort
      });
      result = this.store.findQuery(this.modelType, query);
      return this.set('content', result);
    },
    getMultiColumnQuery: function(args, pagingInfo) {
      var cols, query;
      cols = args.sortCols;
      return query = this.generateQueryFromCols(cols);
    },
    getSingleColumnQuery: function(args, pagingInfo) {
      var ascending, col, query;
      col = args.sortCol;
      ascending = args.sortAsc;
      return query = this.generateQueryFromCol(col, ascending);
    },
    generateQueryFromCols: function(cols) {
      var col, fields, query, _i, _len;
      fields = [];
      for (_i = 0, _len = cols.length; _i &lt; _len; _i++) {
        col = cols[_i];
        fields.push({
          sortAsc: col.sortAsc,
          field: col.sortCol.field
        });
      }
      query = {
        type: 'sorting',
        fields: fields
      };
      return query;
    },
    generateQueryFromCol: function(col, ascending) {
      var query;
      return query = {
        type: 'sorting',
        field: col.field,
        sortAsc: ascending
      };
    }
  });

}).call(this);


(function() {

  Tent.Application = Tent.Application || Em.Namespace.create;

  Tent.Application.MainMenuController = Ember.Controller.extend({
    content: [],
    init: function() {
      return this.applyEntitlements();
    },
    applyEntitlements: function() {
      var hasAnyEntitlements, item, menuGroup, parentEntitled, _i, _j, _len, _len1, _ref, _ref1, _results;
      _ref = this.get('content');
      _results = [];
      for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
        menuGroup = _ref[_i];
        parentEntitled = false;
        _ref1 = menuGroup.items;
        for (_j = 0, _len1 = _ref1.length; _j &lt; _len1; _j++) {
          item = _ref1[_j];
          hasAnyEntitlements = this.processItemEntitlements(item);
          if (hasAnyEntitlements) {
            parentEntitled = true;
          }
        }
        _results.push(menuGroup.entitled = this.processItemEntitlements(menuGroup) &amp;&amp; parentEntitled);
      }
      return _results;
    },
    processItemEntitlements: function(item) {
      var entitlement, hasEntitlement, operation, _i, _len, _ref;
      item.entitled = true;
      if (!(item.operations != null)) {
        return true;
      }
      hasEntitlement = false;
      if (Object.prototype.toString.call(item.operations) === '[object Array]') {
        entitlement = false;
        _ref = item.operations;
        for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
          operation = _ref[_i];
          entitlement = entitlement || this.isEntitled(operation);
        }
        if (entitlement) {
          hasEntitlement = entitlement;
        }
        item.entitled = entitlement;
      }
      return hasEntitlement;
    },
    isEntitled: function(operation) {
      if (operation != null) {
        return Endeavour.policy(operation);
      }
      return true;
    },
    menuClicked: function(action) {
      return this.get('target').send(action);
    }
  });

}).call(this);


(function() {
}).call(this);


(function() {
  var getPath, normalizePath;

  getPath = Ember.Handlebars.getPath;

  normalizePath = Ember.Handlebars.normalizePath;

  Tent.Handlebars = Ember.Namespace.create({
    getPath: function(property, options) {
      var context, normalized, path, pathRoot;
      context = (options.contexts &amp;&amp; options.contexts[0]) || this;
      normalized = normalizePath(context, property, options.data);
      pathRoot = normalized.root;
      path = normalized.path;
      return getPath(pathRoot, path, options) || Ember.get(path) || path;
    }
  });

}).call(this);



<span id='Handlebars-helpers-formatAmount'>/**
</span>* `formatAmount` allows you to present a numeric value formatted as a money amount 
* according to the current locale
*		
*		{{formatAmount amount}}
*
* @class Handlebars.helpers.formatAmount
* @param {Number} amount
* @returns {String} HTML string
*/


(function() {

  Ember.Handlebars.registerHelper('formatAmount', function(property, options) {
    var amount;
    amount = Tent.Handlebars.getPath(property, options);
    return Tent.Formatting.amount.format(amount, options.hash);
  });

}).call(this);



<span id='Handlebars-helpers-formatDate'>/**
</span>* `formatDate` allows you to present a Date value formatted to the current locale
*		
*		{{formatDate date}}
*
* @class Handlebars.helpers.formatDate
* @param {Date} date
* @returns {String} HTML string
*/


(function() {

  Ember.Handlebars.registerHelper('formatDate', function(context, options) {
    var date;
    date = Tent.Handlebars.getPath(context, options);
    return Tent.Formatting.date.format(date, options.hash.format);
  });

}).call(this);



<span id='Handlebars-helpers-formatNumber'>/**
</span>* `formatNumber` allows you to present a numeric value formatted  
* according to the current locale
*		
*		{{formatNumber number}}
*
* @class Handlebars.helpers.formatNumber
* @param {Number} number
* @returns {String} HTML string
*/


(function() {

  Ember.Handlebars.registerHelper('formatNumber', function(context, options) {
    var number;
    number = Tent.Handlebars.getPath(context, options);
    return Tent.Formatting.number.format(number, options.hash.format);
  });

}).call(this);



<span id='Handlebars-helpers-loc'>/**
</span>* `loc` will translate a string key using the bundle for the current locale
*		
*		{{loc string}}
*
* You may optionally pass in an **args** property, which is a space-delimited list of
* values which will be interpolated into the translated key string 
*
*    	{{loc string args='view.firstName view.lastName'}}
*
* @class Handlebars.helpers.loc
* @param {String} key
* @param {}
* @returns {String} translated string
*/


(function() {

  Ember.Handlebars.registerHelper('loc', function(property, options) {
    var arg, args, key;
    key = Tent.Handlebars.getPath(property, options);
    if (key != null) {
      args = [];
      if (options.hash.args != null) {
        args.push((function() {
          var _i, _len, _ref, _results;
          _ref = Ember.String.w(options.hash.args);
          _results = [];
          for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
            arg = _ref[_i];
            _results.push(Ember.get(arg));
          }
          return _results;
        })());
      }
      return Ember.String.htmlSafe(Tent.I18n.loc(key, args[0]));
    }
    return path;
  });

}).call(this);


(function() {
}).call(this);



<span id='Tent-Data-Pager'>/**
</span>* @class Tent.Data.Pager
* Adds paging support
*/


(function() {

  Tent.Data.Pager = Ember.Mixin.create({
    paged: false,
    pageSize: null,
    _page: 1,
    _totalRows: 27,
    init: function() {
      this._super();
      return this.REQUEST_TYPE.PAGE = 'paging';
    },
    currentPage: (function(key, value) {
      if (arguments.length === 1) {
        if (this.isValidPage(this.get('_page'))) {
          return this.get('_page');
        } else {
          return 1;
        }
      } else {
        if (!!this.isValidPage(value)) {
          this.set('_page', value);
        }
        return this.get('_page');
      }
    }).property('data'),
    isValidPage: function(page) {
      return true;
    },
    totalPages: (function() {
      return this.get('_totalPages') || (Math.max(1, Math.ceil(this.get('totalRows') / this.get('pageSize')))) || 1;
    }).property('_totalPages', 'totalRows', 'pageSize'),
    totalRows: (function() {
      return this.get('_totalRows') || this.get('_totalPages') * this.get('pagesize') || 1;
    }).property('_totalRows', '_totalPages', 'pageSize'),
    goToPage: function(page) {
      this.set('currentPage', page);
      if (this.get('isShowingGroupsList')) {
        this.set('currentGroupPage', page);
      }
      return this.update(this.REQUEST_TYPE.PAGE);
    },
    nextPage: function() {
      var newPage;
      newPage = this.get('currentPage') + 1;
      if (!!this.isValidPage(newPage)) {
        this.set('currentPage', newPage);
      }
      return this.update(this.REQUEST_TYPE.PAGE);
    },
    prevPage: function() {
      var newPage;
      newPage = this.get('currentPage') - 1;
      if (!!this.isValidPage(newPage)) {
        this.set('currentPage', newPage);
      }
      return this.update(this.REQUEST_TYPE.PAGE);
    },
    pagingInfo: (function() {
      return {
        pageSize: this.get('pageSize'),
        page: this.get('currentPage'),
        totalRows: this.get('totalRows'),
        totalPages: this.get('totalPages')
      };
    }).property('pageSize', 'currentPage', 'totalPages', 'totalRows'),
    updatePagingInfo: function(info) {
      this.set('_totalRows', info.totalRows);
      return this.set('_page', info.page);
    }
  });

}).call(this);



<span id='Tent-Data-Sorter'>/**
</span>* @class Tent.Data.Sorter
* Adds sorting support
*/


(function() {

  Tent.Data.Sorter = Ember.Mixin.create({
    columnFilters: {},
    sortingInfo: {},
    init: function() {
      this._super();
      return this.REQUEST_TYPE.SORT = 'sorting';
    },
<span id='Tent-Data-Sorter-method-sort'>    /**
</span>    	* @method sort Sort the collection according to the sort fields provided
    	* @param {Object} sortFields An object defining the fields and sort order
    */

    sort: function(args) {
      this.set('sortingInfo', args);
      return this.update(this.REQUEST_TYPE.SORT);
    },
    getSortingInfo: function() {
      return this.get('sortingInfo');
    }
  });

}).call(this);


(function() {

  Tent.Data.ColumnInfo = Ember.Mixin.create({
    init: function() {
      this._super();
      return this.set('columnInfo', {
        titles: {},
        widths: {},
        order: {},
        hidden: {}
      });
    }
  });

}).call(this);



<span id='Tent-Data-Filter'>/**
</span>* @class Tent.Data.Filter
* Adds filtering support
*/


(function() {

  Tent.Data.Filter = Ember.Mixin.create({
    filteringInfo: {
      selectedFilter: 'default',
      availableFilters: [
        {
          name: &quot;default&quot;,
          label: Tent.I18n.loc('tent.filter.noFilter'),
          description: &quot;&quot;,
          values: {}
        }
      ]
    },
    init: function() {
      this._super();
      return this.REQUEST_TYPE.FILTER = 'filtering';
      /*@set('filteringInfo', 
      			selectedFilter: 'task2'
      			availableFilters: [
      				{
      					name: &quot;task1&quot;
      					label: &quot;Task 1&quot;
      					description: &quot;Select the first task&quot;
      					values: {
      						id: {field:&quot;id&quot;, op: &quot;equal&quot;, data: &quot;5&quot;}
      						title: {field:&quot;title&quot;,op: &quot;equal&quot;, data: &quot;Task 1&quot;}
      						duration: {field:&quot;duration&quot;,op: &quot;equal&quot;, data: &quot;5&quot;}
      						#percentcomplete: {field:&quot;percentcomplete&quot;,op: &quot;equal&quot;, data: &quot;41&quot;}
      						effortdriven: {field:&quot;effortdriven&quot;,op: &quot;equal&quot;, data: &quot;-1&quot;}
      						start: {field:&quot;start&quot;,op: &quot;equal&quot;, data: &quot;&quot;}
      						finish: {field:&quot;finish&quot;,op: &quot;equal&quot;, data: &quot;&quot;}
      						completed: {field:&quot;completed&quot;,op: &quot;equal&quot;, data: true}
      					}
      				},
      				{
      					name: &quot;task2&quot;
      					label: &quot;Task 2&quot;
      					description: &quot;Select all tasks 50-59&quot;
      					values: {
      						id: {field:&quot;id&quot;,op: &quot;equal&quot;, data: &quot;5&quot;}
      						title: {field:&quot;title&quot;,op: &quot;equal&quot;, data: &quot;Task 2&quot;}
      					}
      				},
      				{
      					name: &quot;task3&quot;
      					label: &quot;Task 3&quot;
      					description: &quot;Select all tasks 50-59&quot;
      					values: {
      						id: {field:&quot;id&quot;,op: &quot;equal&quot;, data: &quot;5&quot;}
      					}
      				}
      			])
      */

    },
    selectedFilter: (function() {
      return this.getSelectedFilter();
    }).property('filteringInfo', 'filteringInfo.selectedFilter'),
    getSelectedFilter: function() {
      var filter, _i, _len, _ref;
      if ((this.get('filteringInfo') != null) &amp;&amp; (this.get('filteringInfo.selectedFilter') != null)) {
        _ref = this.get('filteringInfo.availableFilters');
        for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
          filter = _ref[_i];
          if (filter.name === this.get('filteringInfo.selectedFilter')) {
            return filter;
          }
        }
      }
    },
    getSelectedFilterName: function() {
      var f;
      f = this.getSelectedFilter();
      return {
        name: f.name,
        label: f.label
      };
    },
    setSelectedFilter: function(name) {
      return this.set('filteringInfo.selectedFilter', name);
    },
    filterNames: (function() {
      return this.get('filteringInfo.availableFilters').map(function(item) {
        return {
          name: item.name,
          label: item.label
        };
      });
    }).property('filteringInfo.availableFilters', 'filteringInfo.availableFilters.@each'),
    updateCurrentFilter: function(currentFilter) {
      var filters, replacedExisting;
      replacedExisting = false;
      if (this.get('filteringInfo') != null) {
        filters = this.get('filteringInfo.availableFilters').map(function(item) {
          if (item.name === currentFilter.name) {
            if (item.label === currentFilter.label) {
              replacedExisting = true;
              return Ember.copy(currentFilter, true);
            } else {
              currentFilter.name = currentFilter.label.split(&quot; &quot;).join('');
              return item;
            }
          } else {
            return item;
          }
        });
        this.get('filteringInfo.availableFilters').clear();
        this.get('filteringInfo.availableFilters').pushObjects(filters);
        if (!replacedExisting) {
          return this.addNewFilter(currentFilter);
        }
      }
    },
    doFilter: function(selectedFilter) {
      if (selectedFilter != null) {
        this.setSelectedFilter(selectedFilter.name);
        this.updateCurrentFilter(selectedFilter);
      }
      return this.update(this.REQUEST_TYPE.FILTER);
    },
    filterTrigger: function() {
      return this.doFilter();
    },
    getFilteringInfo: function() {
      return this.getSelectedFilter();
    },
    saveFilter: function(filterDef) {
      this.updateCurrentFilter(filterDef);
      return this.saveUIState();
    },
    addNewFilter: function(filter) {
      filter.name = filter.name || filter.label.split(&quot; &quot;).join('');
      this.set('filteringInfo.selectedFilter', filter.name);
      return this.get('filteringInfo.availableFilters').push(Ember.copy(filter, true));
    }
  });

}).call(this);


(function() {

  Tent.Data.GroupingSupport = Ember.Mixin.create({
    groupingInfo: {},
    currentGroupPage: 1,
    currentGroupId: null,
    isShowingGroupsList: false,
    init: function() {
      this._super();
      return this.REQUEST_TYPE.GROUP = 'group';
    },
    goToGroupPage: function(page, groupingInfo) {
      if (groupingInfo != null) {
        this.set('groupingInfo', groupingInfo);
      }
      if (page != null) {
        this.set('groupingInfo.page', page);
        this.set('currentGroupPage', page);
      }
      this.set('groupingInfo.currentGroupId', null);
      return this.update(this.REQUEST_TYPE.GROUP);
    },
    setCurrentGroupId: function(id) {
      this.set('currentGroupId', id);
      return this.set('groupingInfo.currentGroupId', id);
    },
    getGroupingInfo: function() {
      return this.get('groupingInfo');
    },
    clearGrouping: function() {
      return this.set('groupingInfo', {
        columnName: null,
        type: null
      });
    }
  });

}).call(this);



<span id='Tent-Data-SearchSupport'>/**
</span>* @class Tent.Data.SearchSupport
* Adds full text search support
*/


(function() {

  Tent.Data.SearchSupport = Ember.Mixin.create({
    init: function() {
      this._super();
      return this.REQUEST_TYPE.SEARCH = 'searching';
    },
<span id='Tent-Data-SearchSupport-method-search'>    /**
</span>    	* @method search Perform a full-text search
    	* @param {String} searchText the text to use for the search
    */

    search: function(searchText) {
      this.set('searchingInfo', searchText);
      console.log('Adding full text search  [' + searchText + ']');
      return this.update(this.REQUEST_TYPE.SEARCH);
    },
    getSearchingInfo: function() {
      return this.get('searchingInfo');
    }
  });

}).call(this);



<span id='Tent-Data-ExportSupport'>/**
</span>* @class Tent.Data.ExportSupport
* Adds support for exporting
*/


(function() {

  Tent.Data.ExportSupport = Ember.Mixin.create({
<span id='Tent-Data-ExportSupport-method-getURL'>    /**
</span>    	* @method getURL Returns the URL hosting the export service
    	* @param {String} type The type of exported data to generate
    */

    getURL: function(type) {
      return '#';
    }
  });

}).call(this);



/*
This mixin allows UI state to be stored by the user, and restored automatically the next time the user uses
the same collection


The json data we expect is:

paging: {
  pageSize: 12
}
sorting: {
  field: 'title'
  asc: 'desc'
}
column: {
  titles: {
    duration: 'Time Elapsed'
  }
  widths: {
    id: 5
    title: 35
    duration: 10
    percentcomplete: 10
    effortdriven: 10
    start: 10
    finish: 10
    completed: 10
  }
  order: {
    id: 1
    title: 3
    duration: 2
    percentcomplete: 4
    effortdriven: 5
    start: 6
    finish: 7
    completed: 8
  }
  hidden: {
    start: true
    finish: true
  }
}
grouping: {
  columnName: 'duration'
  type: 'exact'
}
*/


(function() {

  Tent.Data.Customizable = Ember.Mixin.create({
    isCustomizable: true,
    defaultName: Tent.I18n.loc('tent.jqGrid.saveUi.defaultName'),
    defaultPersonalization: {
      customizationName: Tent.I18n.loc('tent.jqGrid.saveUi.defaultName'),
      paging: {},
      sorting: {},
      columns: {
        titles: {},
        widths: {},
        order: {},
        hidden: {}
      },
      grouping: {},
      filtering: {
        availableFilters: []
      }
    },
    personalizations: [],
    init: function() {
      this._super();
      this.set('customizationName', this.get('defaultName') || &quot;&quot;);
      return this.set('personalizationsRecord', this.fetchPersonalizations());
    },
    personalizationsRecordDidChange: (function() {
      if (this.get('personalizationsRecord').toArray().length &gt; 0) {
        return this.set('personalizations', this.get('personalizationsRecord').toArray());
      } else {
        return this.set('personalizations', []);
      }
    }).observes('personalizationsRecord', 'personalizationsRecord.@each'),
    saveUIState: function(name) {
      var uiState;
      if (name != null) {
        name = name.trim();
        this.set('customizationName', name);
      }
      uiState = $.extend(true, {}, this.gatherGridData(this.get('customizationName')));
      this.savePersonalization(name, uiState);
      return this.addPersonalizationToCollection(name, uiState);
    },
    savePersonalization: function(name, uiState) {
      return this.set('newRecord', this.get('store').savePersonalization('collection', this.get('dataType'), name, uiState));
    },
    addPersonalizationToCollection: function(name, uiState) {
      var newRecord;
      newRecord = this.createPersonalizationRecordForClientSide(name, uiState);
      if (newRecord != null) {
        this.removeExistingCustomization(name);
        return this.get('personalizations').pushObject(newRecord);
      }
    },
    removeExistingCustomization: function(name) {
      var index, p, _i, _len, _ref;
      _ref = this.get('personalizations');
      for (index = _i = 0, _len = _ref.length; _i &lt; _len; index = ++_i) {
        p = _ref[index];
        if (p.get('name') === name) {
          this.get('personalizations').splice(index, 1);
          return;
        }
      }
    },
    createPersonalizationRecordForClientSide: function(name, uiState) {},
    gatherGridData: function(name) {
      var state;
      return state = $.extend({
        customizationName: name
      }, {
        paging: this.get('pagingInfo')
      }, {
        sorting: this.get('sortingInfo')
      }, {
        filtering: this.get('filteringInfo')
      }, {
        columns: this.get('columnInfo')
      }, {
        grouping: this.get('groupingInfo')
      });
    },
    fetchPersonalizations: function() {
      return this.get('store').fetchPersonalizations('collection', this.get('dataType'));
    },
    isShowingDefault: (function() {
      return this.get('customizationName') === this.get('defaultName');
    }).property('customizationName')
  });

}).call(this);


(function() {
  var __hasProp = {}.hasOwnProperty;
<span id='Tent-Data-Collection'>/**
</span>  * @class Tent.Data.Collection
  * An object used to wrap an array of objects, with a facade for paging, sorting and filtering,
  */


  Tent.Data.Collection = Ember.ArrayController.extend(Tent.Data.Pager, Tent.Data.Sorter, Tent.Data.ColumnInfo, Tent.Data.Filter, Tent.Data.ExportSupport, Tent.Data.Customizable, Tent.Data.SearchSupport, Tent.Data.ExportSupport, Tent.Data.GroupingSupport, {
    content: null,
    dataType: null,
    data: [],
    serverPaging: false,
    liveStreaming: false,
    store: null,
    personalizable: true,
    isLoadable: false,
    REQUEST_TYPE: {
      'ALL': 'all'
    },
    init: function() {
      return this._super();
    },
    dataChanged: (function() {
      this.set('totals', this.get('gridTotalsData'));
      return this.set('content', this.get('gridData'));
    }).observes('modelData', 'modelData.totals'),
    gridData: (function() {
      var column, grid, item, model, _i, _j, _len, _len1, _ref, _ref1;
      grid = [];
      _ref = this.get('modelData');
      for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
        model = _ref[_i];
        item = {
          &quot;id&quot;: model.get('id')
        };
        _ref1 = this.get('columnsDescriptor');
        for (_j = 0, _len1 = _ref1.length; _j &lt; _len1; _j++) {
          column = _ref1[_j];
          if (column.field) {
            item[column.field] = model.get(column.field);
          }
        }
        grid.push(item);
      }
      return grid;
    }).property('modelData'),
    gridTotalsData: (function() {
      var key, newKey, newRow, totals, totalsRow, value, _i, _len, _ref;
      totals = [];
      if (this.get('modelData.totals') != null) {
        _ref = this.get('modelData.totals');
        for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
          totalsRow = _ref[_i];
          newRow = {};
          for (key in totalsRow) {
            if (!__hasProp.call(totalsRow, key)) continue;
            value = totalsRow[key];
            newKey = key.split('_sum')[0];
            newRow[newKey] = value === false ? null : value;
          }
          totals.push(newRow);
        }
      }
      return totals;
    }).property('modelData.totals'),
    isLoaded: (function() {
      return this.get('modelData.isLoaded');
    }).property('modelData.isLoaded'),
    columnsDescriptor: (function() {
      return this.get('store').getColumnsForType(this.get('dataType'));
    }).property('dataType'),
    update: function(requestType) {
      var query, response;
      if ((this.get('dataType') != null) &amp;&amp; (this.get('store') != null)) {
        query = $.extend({}, {
          type: requestType
        }, {
          paging: this.get('pagingInfo')
        }, {
          sorting: this.getSortingInfo()
        }, {
          filtering: this.getFilteringInfo()
        }, {
          grouping: this.getGroupingInfo()
        }, {
          searching: this.getSearchingInfo()
        });
        response = this.get('store').findQuery(eval(this.get('dataType')), query);
        this.set('modelData', response.modelData);
        return this.updatePagingInfo(response.pagingInfo);
      }
    }
  });

}).call(this);


(function() {
}).call(this);


(function() {
}).call(this);
</pre>
</body>
</html>
